<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on 互联网没一个好东西</title>
        <link>https://liguangchang.cn/posts/</link>
        <description>Recent content in Posts on 互联网没一个好东西</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Mon, 14 Feb 2022 08:27:01 +0800</lastBuildDate>
        <atom:link href="https://liguangchang.cn/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>Go Tools</title>
            <link>https://liguangchang.cn/posts/go/go-tools/</link>
            <pubDate>Mon, 14 Feb 2022 08:27:01 +0800</pubDate>
            
            <guid>https://liguangchang.cn/posts/go/go-tools/</guid>
            <description>go tool nm go tool compile -l -p main main.go -&amp;gt; OBJ go tool nm main.o 方法列表 package main import &amp;#34;fmt&amp;#34; type People struct { } func (p *People) ShowA() { fmt.Println(&amp;#34;showA&amp;#34;) p.ShowB() } func (p *People) ShowB() { fmt.Println(&amp;#34;ShowB&amp;#34;) } type Teacher struct { People } func (t *Teacher) ShowB() { fmt.Println(&amp;#34;teacher showB&amp;#34;) } func main() { t := Teacher{} t.ShowA() } package main type A</description>
            <content type="html"><![CDATA[<h2 id="go-tool-nm">go tool nm</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">go</span> <span style="color:#a6e22e">tool</span> <span style="color:#a6e22e">compile</span> <span style="color:#f92672">-</span><span style="color:#a6e22e">l</span> <span style="color:#f92672">-</span><span style="color:#a6e22e">p</span> <span style="color:#a6e22e">main</span> <span style="color:#a6e22e">main</span>.<span style="color:#66d9ef">go</span> <span style="color:#f92672">-</span>&gt; <span style="color:#a6e22e">OBJ</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">go</span> <span style="color:#a6e22e">tool</span> <span style="color:#a6e22e">nm</span> <span style="color:#a6e22e">main</span>.<span style="color:#a6e22e">o</span> <span style="color:#a6e22e">方法列表</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">People</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">p</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">People</span>) <span style="color:#a6e22e">ShowA</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;showA&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">ShowB</span>()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">p</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">People</span>) <span style="color:#a6e22e">ShowB</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;ShowB&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Teacher</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">People</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Teacher</span>) <span style="color:#a6e22e">ShowB</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;teacher showB&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">t</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">Teacher</span>{}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">ShowA</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">A</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">a</span> <span style="color:#a6e22e">A</span>) <span style="color:#a6e22e">Value</span>() <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> int(<span style="color:#a6e22e">a</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">a</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">A</span>) <span style="color:#a6e22e">Set</span>(<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">*</span><span style="color:#a6e22e">a</span> = <span style="color:#a6e22e">A</span>(<span style="color:#a6e22e">n</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">B</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">A</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">b</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">C</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">*</span><span style="color:#a6e22e">A</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">c</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>    <span style="color:#ae81ff">454</span><span style="color:#a6e22e">d</span> <span style="color:#a6e22e">T</span> <span style="color:#a6e22e">structA</span>.(<span style="color:#f92672">*</span><span style="color:#a6e22e">A</span>).<span style="color:#a6e22e">Set</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">52</span><span style="color:#a6e22e">b7</span> <span style="color:#a6e22e">T</span> <span style="color:#a6e22e">structA</span>.(<span style="color:#f92672">*</span><span style="color:#a6e22e">A</span>).<span style="color:#a6e22e">Value</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">5319</span> <span style="color:#a6e22e">T</span> <span style="color:#a6e22e">structA</span>.(<span style="color:#f92672">*</span><span style="color:#a6e22e">B</span>).<span style="color:#a6e22e">Set</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">537</span><span style="color:#a6e22e">b</span> <span style="color:#a6e22e">T</span> <span style="color:#a6e22e">structA</span>.(<span style="color:#f92672">*</span><span style="color:#a6e22e">B</span>).<span style="color:#a6e22e">Value</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">543</span><span style="color:#a6e22e">d</span> <span style="color:#a6e22e">T</span> <span style="color:#a6e22e">structA</span>.(<span style="color:#f92672">*</span><span style="color:#a6e22e">C</span>).<span style="color:#a6e22e">Set</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">549</span><span style="color:#a6e22e">f</span> <span style="color:#a6e22e">T</span> <span style="color:#a6e22e">structA</span>.(<span style="color:#f92672">*</span><span style="color:#a6e22e">C</span>).<span style="color:#a6e22e">Value</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">454</span><span style="color:#a6e22e">c</span> <span style="color:#a6e22e">T</span> <span style="color:#a6e22e">structA</span>.<span style="color:#a6e22e">A</span>.<span style="color:#a6e22e">Value</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">53</span><span style="color:#a6e22e">d1</span> <span style="color:#a6e22e">T</span> <span style="color:#a6e22e">structA</span>.<span style="color:#a6e22e">B</span>.<span style="color:#a6e22e">Value</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">54</span><span style="color:#a6e22e">fc</span> <span style="color:#a6e22e">T</span> <span style="color:#a6e22e">structA</span>.<span style="color:#a6e22e">C</span>.<span style="color:#a6e22e">Set</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">5575</span> <span style="color:#a6e22e">T</span> <span style="color:#a6e22e">structA</span>.<span style="color:#a6e22e">C</span>.<span style="color:#a6e22e">Value</span>
</span></span></code></pre></div>]]></content>
        </item>
        
        <item>
            <title>Go Map</title>
            <link>https://liguangchang.cn/posts/go/go-map/</link>
            <pubDate>Sat, 12 Feb 2022 17:59:16 +0800</pubDate>
            
            <guid>https://liguangchang.cn/posts/go/go-map/</guid>
            <description>init </description>
            <content type="html"><![CDATA[<h2 id="init">init</h2>
]]></content>
        </item>
        
        <item>
            <title>Metrics、Tracing、 Logging</title>
            <link>https://liguangchang.cn/posts/distributed/distributed-cornerstone-observability/</link>
            <pubDate>Thu, 10 Feb 2022 00:04:10 +0800</pubDate>
            
            <guid>https://liguangchang.cn/posts/distributed/distributed-cornerstone-observability/</guid>
            <description>分布式的基石 &amp;mdash; 可观测性 可观测性(Observability) 和可控制性(Controllability) 是由匈牙利数学家 Rudolf E·Kålmån 针</description>
            <content type="html"><![CDATA[<h2 id="分布式的基石-----可观测性">分布式的基石 &mdash; 可观测性</h2>
<p>可观测性(Observability) 和可控制性(Controllability) 是由匈牙利数学家 Rudolf E·Kålmån 针对线性动态控制系统提出的一组对偶属性，原本的含义是 <strong>可以由其外部输出推断其内部状态的程度</strong>。</p>
<blockquote>
<p>Peter Bourgon <strong>metric-tracing-and-logging</strong></p>
<p><a href="https://peter.bourgon.org/blog/2017/02/21/metrics-tracing-and-logging.html">https://peter.bourgon.org/blog/2017/02/21/metrics-tracing-and-logging.html</a></p>
</blockquote>
<p><img src="https://s2.loli.net/2022/02/10/8NBKUCrGp6aIjiM.png" alt="metrics-tracing-logging"></p>
<h2 id="logging">logging</h2>
<p>日志的职责是<strong>记录系统运行期间发生过的离散事件</strong>，通过记录<strong>分析程序行为</strong>。</p>
<h3 id="事件日志">事件日志</h3>
<p>日志应该做到像流水账一样，格式统一，内容恰当，没有遗漏，日志内容不该出现的内容不要有，该有的不少。</p>
<ul>
<li><strong>避免打印敏感信息</strong></li>
<li><strong>避免引用慢操作</strong>
<ul>
<li>关注测试调试数据和实际生产数据的差别</li>
</ul>
</li>
<li><strong>避免打印追踪诊断信息</strong>
<ul>
<li>不要打印方法输入参数、输出结果、方法执行时长的调试信息</li>
</ul>
</li>
<li><strong>避免误导他人</strong>
<ul>
<li>异常处理后不要打印堆栈</li>
</ul>
</li>
<li><strong>请求携带 TraceId</strong>
<ul>
<li>请求应该必须始终附带 TraceId (随请求响应返回到客户端)，如果出现异常，能够快读找到与问题相关的日志。</li>
</ul>
</li>
<li><strong>系统运行过程中的关键事件</strong></li>
<li><strong>启动时输出配置信息</strong>
<ul>
<li>系统启动时或检测到配置更新，应将非敏感的配置信息输出</li>
<li>连接的数据库、临时目录路径</li>
<li>针对只执行一次或者少次的逻辑</li>
</ul>
</li>
</ul>
<h3 id="收集缓冲加工聚合存储查询">收集缓冲、加工聚合、存储查询</h3>
<p>涉及到 Kafka、es、logstash、beats。</p>
<p>加工聚合的方案中 依赖 es 的实时聚合统计用于 <strong>即席查询</strong>，另外通过 logstash 中的聚合插件在收集日志后自动生成某些常用的、固定的聚合指标用于<strong>固定查询</strong>。</p>
<p>日志数据随着时间的推移会逐渐失去价值，可以区分出冷数据和热数据，进而采用不同的硬件策略存储。</p>
<h2 id="tracing">tracing</h2>
<p>单体系统追踪的范畴基本只局限于栈追踪，微服务追踪调用轨迹跨越多个服务，追踪包括服务间网络传输和服务内部的调用堆栈信息。</p>
<p>追踪的目的主要是<strong>排查故障</strong>，分析调用链的哪一部分、哪个方法出现错误或阻塞，输入和输出是否符合预期。</p>
<blockquote>
<p><a href="https://storage.googleapis.com/pub-tools-public-publication-data/pdf/36356.pdf">https://storage.googleapis.com/pub-tools-public-publication-data/pdf/36356.pdf</a></p>
<p><strong>Dapper, a Large-Scale Distributed Systems Tracing Infrastructure</strong></p>
</blockquote>
<p>2010 年 Google 发表的论文提出了 <strong>追踪(Traec)</strong> 与 **跨度(Span)**概念来进行有效的分布式追踪。</p>
<h3 id="追踪与跨度">追踪与跨度</h3>
<p>从客户端发起请求抵达系统的边界开始，记录请求流经的每一个服务，<strong>直到向客户端返回响应为止</strong>，整个过程就称为一次<strong>追踪</strong>。</p>
<p>每次开始调用服务前都需要先埋入一个调用记录，这个记录称为一个<strong>跨度</strong>，Span 的数据结构应足够简洁、完备。</p>
<p>每一次 Trace 实际上都是由若干个<strong>有顺序、有层级关系</strong>的 Span 组成的一棵<strong>追踪树</strong>。</p>
<p><img src="https://s2.loli.net/2022/02/11/c68MnvQBfKT37is.png" alt="trace-tree"></p>
<p><strong>微服务可能是异构语言、协议来进行交互，所以追踪系统需要增加功能应对多种语言和协议。</strong></p>
<ul>
<li><strong>低性能损耗</strong>
<ul>
<li>越慢的服务越需要追踪，不能对服务本身产生明显的性能负担</li>
</ul>
</li>
<li><strong>对应用透明</strong>
<ul>
<li>尽量以非侵入或者少侵入的方式来实现追踪</li>
</ul>
</li>
<li><strong>随应用扩缩</strong>
<ul>
<li>追踪系统跟随系统扩缩</li>
</ul>
</li>
<li><strong>持续的监控</strong>
<ul>
<li>持续监控，防止偶尔的抖动</li>
</ul>
</li>
</ul>
<h3 id="数据收集">数据收集</h3>
<p>追踪系统根据数据收集方式的差异，可分为三种主流的实现方式。</p>
<ul>
<li><strong>基于日志的追踪 Log-Based Tracing</strong>
<ul>
<li>将 Trace、Span 等信息直接输出到日志中</li>
<li>所有节点的日志归集到一起</li>
<li>从全局日志中反推出完整的调用链拓扑关系</li>
<li>对应用侵入和性能影响都较低，但是依赖日志归集过程，不够精准，可能会出现延迟和缺失</li>
<li>代表的有 Spring Cloud Sleuth，SofaTracing</li>
</ul>
</li>
<li><strong>基于服务的追踪 Service-Based Tracing</strong>
<ul>
<li>通过给目标应用注入追踪探针</li>
<li>从目标系统中监控到的服务调用信息，通过请求发送给追踪系统</li>
<li>消耗资源较多，侵入更多，但是追踪精较确、精准</li>
</ul>
</li>
<li><strong>基于边车代理的追踪 Sidecar-Based Tracing</strong>
<ul>
<li>Service mesh 专属方案，目前最理想的方案，Envoy</li>
<li>对应用透明，了解到的大概是承接了网络流量进行处理，<strong>但是只能实现服务调用层面的追踪</strong></li>
<li>通过控制平面上报，保证了最佳的精确性</li>
</ul>
</li>
</ul>
<h3 id="追踪规范化">追踪规范化</h3>
<p>OpenTelemetry</p>
<h2 id="metrics">metrics</h2>
<p>度量是指<strong>对系统中某一类信息的统计聚合</strong>，主要目的是<strong>监控</strong>和<strong>预警</strong>，<strong>在度量的指标达到风险阈值时触发事件</strong>。</p>
<h2 id="heading"></h2>
]]></content>
        </item>
        
        <item>
            <title>Go Slice</title>
            <link>https://liguangchang.cn/posts/go/go-slice/</link>
            <pubDate>Wed, 09 Feb 2022 13:22:09 +0800</pubDate>
            
            <guid>https://liguangchang.cn/posts/go/go-slice/</guid>
            <description>init var s []int **nil 不需要内存分配 ** s := []int{} 空 slice s := []int{5} s := make([]int , 2 , 3) from slice/arr [) s := *new([]int ) type slice struct { array unsafe.Pointer len int cap int } https://asciiflow.com/#/share/eJy9kUEOgjAQRa8ymTULqSJIwkmoi4Z0YYLEIAsI4RbGhcdwzWm8gFfwCwqoaEATm%2F%2BSGTL9%2FS05R2qt2eVtuAo0GxyqTMfoc8mpZHfhCENyhko4FqpEpwkaydRZKo5VRufy4JFvTparKJEygrozlT%2B5Xj3sW669JAr181jvOu3KWhhu6g%2FqN9mXV2qLe57Ku%2Beg7zQ6HpoJMIEAUzADFpgDGzhg0Xjf3%2FpN1D%2Ff4eWpT%2Ftjp7xFxk8mj0Q7%2Frqt%2FfBzggGXo0BtkMh6SDRK2AKPgUElF1xcAC4tva4%3D) 扩容 扩容只关心容量，会把原 slice 的数据拷贝到新 silce 中</description>
            <content type="html"><![CDATA[<h2 id="init">init</h2>
<ul>
<li>var s []int **nil 不需要内存分配 **</li>
<li>s := []int{} <strong>空 slice</strong></li>
<li>s := []int{5}</li>
<li>s := make([]int , 2 , 3)</li>
<li>from slice/arr [)</li>
<li>s := *new([]int</li>
<li>)</li>
</ul>
<pre tabindex="0"><code>type slice struct {
	array unsafe.Pointer
	len   int
	cap   int
}
</code></pre><blockquote>
<p><a href="https://asciiflow.com/#/share/eJy9kUEOgjAQRa8ymTULqSJIwkmoi4Z0YYLEIAsI4RbGhcdwzWm8gFfwCwqoaEATm%2F%2BSGTL9%2FS05R2qt2eVtuAo0GxyqTMfoc8mpZHfhCENyhko4FqpEpwkaydRZKo5VRufy4JFvTparKJEygrozlT%2B5Xj3sW669JAr181jvOu3KWhhu6g%2FqN9mXV2qLe57Ku%2Beg7zQ6HpoJMIEAUzADFpgDGzhg0Xjf3%2FpN1D%2Ff4eWpT%2Ftjp7xFxk8mj0Q7%2Frqt%2FfBzggGXo0BtkMh6SDRK2AKPgUElF1xcAC4tva4%3D">https://asciiflow.com/#/share/eJy9kUEOgjAQRa8ymTULqSJIwkmoi4Z0YYLEIAsI4RbGhcdwzWm8gFfwCwqoaEATm%2F%2BSGTL9%2FS05R2qt2eVtuAo0GxyqTMfoc8mpZHfhCENyhko4FqpEpwkaydRZKo5VRufy4JFvTparKJEygrozlT%2B5Xj3sW669JAr181jvOu3KWhhu6g%2FqN9mXV2qLe57Ku%2Beg7zQ6HpoJMIEAUzADFpgDGzhg0Xjf3%2FpN1D%2Ff4eWpT%2Ftjp7xFxk8mj0Q7%2Frqt%2FfBzggGXo0BtkMh6SDRK2AKPgUElF1xcAC4tva4%3D</a>)</p>
</blockquote>
<p><img src="https://s2.loli.net/2022/02/12/x9yQYwsobrBUgav.png" alt="slice-from-array"></p>
<h2 id="扩容">扩容</h2>
<p>扩容只关心容量，会把原 slice 的数据拷贝到新 silce 中，<strong>追加数据由 append 在扩容后完成</strong>。</p>
<ul>
<li>原 slice 容量小于 1024，新 slice 容量将扩大为原来的 2 倍</li>
<li>原 slice 容量大于或等于 1024，新 slice 容量将扩大为原来的 1.25 倍</li>
</ul>
<h2 id="copy">copy</h2>
<p>将 src 的数据逐个拷贝到 dst 指向的数组中，数量二者最小值，拷贝过程不会发生扩容。</p>
<h2 id="express">express</h2>
<ul>
<li>简单表达式 a[low : high]</li>
<li>拓展表达式 a[low : high : max]</li>
<li>简单表达式操作字符串或数组 0&lt;= low &lt;=high &lt;= len(a)</li>
<li><strong>简单表达式操作切片  0&lt;= low &lt;= high &lt;=cap(a)</strong></li>
<li><strong>操作字符串 -&gt; 产生新的字符串</strong></li>
</ul>
<p><strong>s[low:high]  默认值分别为 0，len(s)</strong></p>
<h2 id="max">max</h2>
<p><strong>拓展表达式限制写覆盖，low 可以省略，只能用于数组和切片，不能用于字符串</strong></p>
<p>a[low:high:max]，max-low 限制新切片的 cap。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> [<span style="color:#ae81ff">5</span>]<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">a</span>[<span style="color:#ae81ff">1</span>:<span style="color:#ae81ff">4</span>]
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;a:%v\n&#34;</span>, <span style="color:#a6e22e">a</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">b</span> = append(<span style="color:#a6e22e">b</span>, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">a</span>[<span style="color:#ae81ff">1</span>:<span style="color:#ae81ff">3</span>:<span style="color:#ae81ff">3</span>]
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;c addr:%p\n&#34;</span>, <span style="color:#a6e22e">c</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;c:%v\n&#34;</span>, <span style="color:#a6e22e">c</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">c</span> = append(<span style="color:#a6e22e">c</span>, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;c addr:%p\n&#34;</span>, <span style="color:#a6e22e">c</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;a:%v\n&#34;</span>, <span style="color:#a6e22e">a</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;b:%v\n&#34;</span>, <span style="color:#a6e22e">b</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;c:%v\n&#34;</span>, <span style="color:#a6e22e">c</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">a</span>:[<span style="color:#ae81ff">1</span> <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">4</span> <span style="color:#ae81ff">5</span>]
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">c</span> <span style="color:#a6e22e">addr</span>:<span style="color:#ae81ff">0xc00012c038</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">c</span>:[<span style="color:#ae81ff">2</span> <span style="color:#ae81ff">3</span>]
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">c</span> <span style="color:#a6e22e">addr</span>:<span style="color:#ae81ff">0xc000122040</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">a</span>:[<span style="color:#ae81ff">1</span> <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">4</span> <span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">b</span>:[<span style="color:#ae81ff">2</span> <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">4</span> <span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">c</span>:[<span style="color:#ae81ff">2</span> <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">0</span>]
</span></span></code></pre></div><blockquote>
<p><a href="https://asciiflow.com/#/share/eJyrVspLzE1VslIqzslMTtVNrSgoSi0uVtJRykmsTC0CilfHKFXEKFlZWpjpxChVAllGFuZAVklqRQmQE6OkgB3kpOYp2CokJxYo2BrFxOThUAUBj6bsgSCgQjgbF8KqXQGuWUEB7BGIKKbSaXtAmAR7CKrDhWDOSSwqSqzEMAdisgEQGwKxERAbA7EJEJsCsRkQmwOxBfFhAicpci0k1owUkM1EDr1NJLkGJYqgNoBTBLINpLqRgBqlWqVaADqdeVA%3D">https://asciiflow.com/#/share/eJyrVspLzE1VslIqzslMTtVNrSgoSi0uVtJRykmsTC0CilfHKFXEKFlZWpjpxChVAllGFuZAVklqRQmQE6OkgB3kpOYp2CokJxYo2BrFxOThUAUBj6bsgSCgQjgbF8KqXQGuWUEB7BGIKKbSaXtAmAR7CKrDhWDOSSwqSqzEMAdisgEQGwKxERAbA7EJEJsCsRkQmwOxBfFhAicpci0k1owUkM1EDr1NJLkGJYqgNoBTBLINpLqRgBqlWqVaADqdeVA%3D</a>)</p>
</blockquote>
<p><img src="https://s2.loli.net/2022/02/12/W23dNa7ClsShxVc.png" alt="slice-express"></p>
<blockquote>
<p><a href="https://go.dev/play/p/iKtfAiv4upU">https://go.dev/play/p/iKtfAiv4upU</a></p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">a</span>[:<span style="color:#ae81ff">2</span>:<span style="color:#ae81ff">2</span>]
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;addr a: %p, b: %p\n&#34;</span>, <span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;b len: %d,cap: %d\n&#34;</span>, len(<span style="color:#a6e22e">b</span>), cap(<span style="color:#a6e22e">b</span>))
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;slice b %v\n&#34;</span>, <span style="color:#a6e22e">b</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">b</span> = append(<span style="color:#a6e22e">b</span>, <span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;slice b %v\n&#34;</span>, <span style="color:#a6e22e">b</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;a len: %d,cap: %d\n&#34;</span>, len(<span style="color:#a6e22e">a</span>), cap(<span style="color:#a6e22e">a</span>))
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;b len: %d,cap: %d\n&#34;</span>, len(<span style="color:#a6e22e">b</span>), cap(<span style="color:#a6e22e">b</span>))
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;addr a: %p, b: %p\n&#34;</span>, <span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><pre tabindex="0"><code>addr a: 0xc0000b8000, b: 0xc0000b8000
b len: 2,cap: 2
slice b [1 2]
slice b [1 2 5]
a len: 3,cap: 3
b len: 3,cap: 4
addr a: 0xc0000b8000, b: 0xc0000bc000
</code></pre>]]></content>
        </item>
        
        <item>
            <title>Go Chan</title>
            <link>https://liguangchang.cn/posts/go/go-chan/</link>
            <pubDate>Wed, 09 Feb 2022 13:22:06 +0800</pubDate>
            
            <guid>https://liguangchang.cn/posts/go/go-chan/</guid>
            <description>FIFO ，数据总是按照写入的顺序流出管道。 声明和初始化 var ch chan int ch := make(chan int) ch := make(chan int, 1) 管道操作 操作符 &amp;lt;- , -&amp;gt; 表示数据流向，默认双向可读写，在函数间传递时可</description>
            <content type="html"><![CDATA[<p>FIFO ，数据总是按照写入的顺序流出管道。</p>
<h2 id="声明和初始化">声明和初始化</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">ch</span> <span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span> 
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">ch</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">ch</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">1</span>)
</span></span></code></pre></div><h2 id="管道操作">管道操作</h2>
<p>操作符 &lt;- , -&gt; 表示数据流向，默认双向可读写，在函数间传递时可以使用操作符限制读写。</p>
<h3 id="没有缓存区">没有缓存区</h3>
<p>读会阻塞，直到有 G 写数据</p>
<p>写会阻塞，知道有 G 读数据</p>
<h3 id="有缓存区无数据">有缓存区无数据</h3>
<p>读会阻塞，知道有 G 写数据</p>
<h3 id="有缓冲区满了">有缓冲区满了</h3>
<p>写会阻塞，直到有 G 读</p>
<h3 id="nil">nil</h3>
<p>读写永久阻塞</p>
<h3 id="close">close</h3>
<p>close(ch)，关闭 chan，关闭的 chan 写操作会 panic，关闭后仍然可读</p>
<h3 id="读表达式">读表达式</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">val</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">ch</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">val</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">ch</span>
</span></span></code></pre></div><p><strong>第二个变量表示是否读取成功</strong></p>
<ul>
<li>chan 关闭，缓冲区没数据
<ul>
<li>读取返回类型零值，false</li>
</ul>
</li>
<li>chan 关闭，缓冲区有数据
<ul>
<li>读取 chan 数据，true</li>
<li>chan 关闭，并且缓冲区没有数据，false = 管道的关闭状态</li>
</ul>
</li>
</ul>
<h2 id="hchan">hchan</h2>
<p><code>runtime/chan.go</code></p>
<p><code>队列</code> <code>类型信息</code> <code>协程等待队列</code></p>
<pre tabindex="0"><code>type hchan struct {
	qcount   uint           // total data in the queue
	dataqsiz uint           // size of the circular queue
	buf      unsafe.Pointer // points to an array of dataqsiz elements
	elemsize uint16 //每个元素的大小
	closed   uint32 //标识关闭状态
	elemtype *_type // element type
	sendx    uint   // send index
	recvx    uint   // receive index
	recvq    waitq  // list of recv waiters
	sendq    waitq  // list of send waiters

	// lock protects all fields in hchan, as well as several
	// fields in sudogs blocked on this channel.
	//
	// Do not change another G&#39;s status while holding this lock
	// (in particular, do not ready a G), as this can deadlock
	// with stack shrinking.
	lock mutex
}
</code></pre><h3 id="环形队列">环形队列</h3>
<blockquote>
<p><a href="https://asciiflow.com/#/share/eJyrVspLzE1VssorzcnRUcpJrEwtUrJSqo5RqohRsjI0MDTRiVGqBDKNLMyBrJLUihIgJ0bp0ZQ9ZKCYmDwgqYAGUCUykjMS8%2BASGCpphyBuIANhuJF4Cu7vwuT80rwSBVsFI1R%2Fo1g1bRdYygCiwhCFMsBCUewjGJMO4a6gkJJYklhYnFkFDAQz9DCgmk9g3GmbUDjICTOpNI2o5IYl0qnnXmxJCs10EKc4NS%2BlAhhgxrSOJLTYoqLPEJ4pSk0uA3nGkFqeIdutMUq1SrUA6MnbaQ%3D%3D">https://asciiflow.com/#/share/eJyrVspLzE1VssorzcnRUcpJrEwtUrJSqo5RqohRsjI0MDTRiVGqBDKNLMyBrJLUihIgJ0bp0ZQ9ZKCYmDwgqYAGUCUykjMS8%2BASGCpphyBuIANhuJF4Cu7vwuT80rwSBVsFI1R%2Fo1g1bRdYygCiwhCFMsBCUewjGJMO4a6gkJJYklhYnFkFDAQz9DCgmk9g3GmbUDjICTOpNI2o5IYl0qnnXmxJCs10EKc4NS%2BlAhhgxrSOJLTYoqLPEJ4pSk0uA3nGkFqeIdutMUq1SrUA6MnbaQ%3D%3D</a>)</p>
</blockquote>
<p><img src="https://s2.loli.net/2022/02/12/hxWgS9J8kubTf1X.png" alt="make-chan"></p>
<ul>
<li>dataqsiz  表示队列可缓存 6 个元素</li>
<li>buf 指向队列的内存</li>
<li>qcount 表示缓冲区还有两个元素</li>
<li>sendx 表示下一次写入的位置，[0，6)</li>
<li>recvx 表示读取位置，[0，6)</li>
</ul>
<p>数组实现队列比较简单， sendx 和 recvx 相当于队尾和队首。</p>
<h3 id="等待队列">等待队列</h3>
<p><img src="https://s2.loli.net/2022/02/12/WrOtNaCophBHSm5.png" alt="chan-nobuf"></p>
<ul>
<li>读 chan ，buf 为空 或 没有 buf，G 会被阻塞，加入 recvq</li>
<li>写 chan，buf 已满 或 没有 buf，G 会被阻塞，加入 sendq</li>
<li>处于 队列中的 G 会被其他 G 的操作唤醒</li>
</ul>
<h2 id="chan-operator">Chan operator</h2>
<h3 id="write">write</h3>
<ul>
<li>chan buf 有位置，写入 buf</li>
<li>chan buf 没位置， G -&gt; sendq，sleep 等待 G read 唤醒</li>
<li>receq 非空时，表示 buf 没数据，有 G 在等待读，会直接将数据传递给 receq 中的第一个协程，不再写入 buf</li>
</ul>
<h3 id="read">read</h3>
<ul>
<li>chan buf 有数据，读 buf</li>
<li>chan buf 无数据，G -&gt; receq ，sleep 等待 G write 唤醒</li>
<li>sendq 非空，无 buf，直接从 sendq 第一个 G 获取数据</li>
</ul>
<h3 id="close-1">close</h3>
<p>关闭 chan 会唤醒 recess 中所有 G，G 获取到对应类型的零值，同时会唤醒 sendq 中的 G，sendq 中的 G 会 panic。</p>
<p><code>panic operator</code></p>
<ul>
<li>关闭 nil 的 chan</li>
<li>再次关闭</li>
<li>关闭后写操作</li>
</ul>
<h3 id="select-chan">select-chan</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;time&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">send</span>(<span style="color:#a6e22e">ch</span> <span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">e</span> <span style="color:#66d9ef">int</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">ch</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">e</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">ch1</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">10</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">ch2</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">10</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">send</span>(<span style="color:#a6e22e">ch1</span>, <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">send</span>(<span style="color:#a6e22e">ch2</span>, <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">select</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">e</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">ch1</span>:
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;rece from ch1:%d\n&#34;</span>, <span style="color:#a6e22e">e</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">e</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">ch2</span>:
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;rece from ch2:%d\n&#34;</span>, <span style="color:#a6e22e">e</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">default</span>:
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;no element ffrom ch1 and ch2.\n&#34;</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="range">range</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">ch</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">ch</span> <span style="color:#f92672">&lt;-</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">ch</span> <span style="color:#f92672">&lt;-</span> <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>	close(<span style="color:#a6e22e">ch</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">e</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">ch</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;get element from ch:%d\n&#34;</span>, <span style="color:#a6e22e">e</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>]]></content>
        </item>
        
        <item>
            <title>Sentinel Guard</title>
            <link>https://liguangchang.cn/posts/java/sentinel-guard/</link>
            <pubDate>Wed, 09 Feb 2022 11:32:01 +0800</pubDate>
            
            <guid>https://liguangchang.cn/posts/java/sentinel-guard/</guid>
            <description>Install dashboard  git@github.com:lgc523/Sentinel.git
 &amp;lt;repositories&amp;gt;  &amp;lt;repository&amp;gt;  &amp;lt;id&amp;gt;alimaven&amp;lt;/id&amp;gt;  &amp;lt;name&amp;gt;aliyun maven&amp;lt;/name&amp;gt;  &amp;lt;url&amp;gt;https://maven.aliyun.com/nexus/content/repositories/central/&amp;lt;/url&amp;gt;  &amp;lt;releases&amp;gt;  &amp;lt;enabled&amp;gt;true&amp;lt;/enabled&amp;gt;  &amp;lt;/releases&amp;gt;  &amp;lt;snapshots&amp;gt;  &amp;lt;enabled&amp;gt;false&amp;lt;/enabled&amp;gt;  &amp;lt;/snapshots&amp;gt;  &amp;lt;/repository&amp;gt; &amp;lt;/repositories&amp;gt; mci -&amp;gt; jar cat guard-up.sh #!/bin/bash echo &amp;#39;start sentinel-dashboard ...&amp;#39; nohup java -Dserver.port=8080 -Dcsp.sentinel.dashboard.server=localhost:8080 -Dproject.name=sentinel-guard -jar sentinel-dashboard.jar &amp;gt; sentinel-dashboard.log 2&amp;gt;&amp;amp;1 &amp;amp; echo $! &amp;gt; /opt/sentinel-dashboard/sentinel-dashboard.pid  $ cat guard-k.sh #!/bin/sh PID=$(cat /opt/sentinel-dashboard/sentinel-dashboard.pid) kill -9 $PID echo &amp;#39;wait sentinel-dashboard...&amp;#39; </description>
            <content type="html"><![CDATA[<h2 id="install-dashboard">Install dashboard</h2>
<blockquote>
<p><a href="mailto:git@github.com">git@github.com</a>:lgc523/Sentinel.git</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">&lt;</span>repositories<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&lt;</span>repository<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">&lt;</span>id<span style="color:#f92672">&gt;</span>alimaven<span style="color:#f92672">&lt;/</span>id<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">&lt;</span>name<span style="color:#f92672">&gt;</span>aliyun maven<span style="color:#f92672">&lt;/</span>name<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">&lt;</span>url<span style="color:#f92672">&gt;</span>https<span style="color:#f92672">:</span><span style="color:#75715e">//maven.aliyun.com/nexus/content/repositories/central/&lt;/url&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#f92672">&lt;</span>releases<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">&lt;</span>enabled<span style="color:#f92672">&gt;</span><span style="color:#66d9ef">true</span><span style="color:#f92672">&lt;/</span>enabled<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">&lt;/</span>releases<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">&lt;</span>snapshots<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">&lt;</span>enabled<span style="color:#f92672">&gt;</span><span style="color:#66d9ef">false</span><span style="color:#f92672">&lt;/</span>enabled<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">&lt;/</span>snapshots<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>         <span style="color:#f92672">&lt;/</span>repository<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;/</span>repositories<span style="color:#f92672">&gt;</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>mci -&gt; jar
</span></span><span style="display:flex;"><span>cat guard-up.sh
</span></span><span style="display:flex;"><span><span style="color:#75715e">#!/bin/bash</span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;start sentinel-dashboard ...&#39;</span>
</span></span><span style="display:flex;"><span>nohup java -Dserver.port<span style="color:#f92672">=</span><span style="color:#ae81ff">8080</span> -Dcsp.sentinel.dashboard.server<span style="color:#f92672">=</span>localhost:8080 -Dproject.name<span style="color:#f92672">=</span>sentinel-guard -jar sentinel-dashboard.jar &gt; sentinel-dashboard.log 2&gt;&amp;<span style="color:#ae81ff">1</span> &amp;
</span></span><span style="display:flex;"><span>echo $! &gt; /opt/sentinel-dashboard/sentinel-dashboard.pid
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ cat guard-k.sh
</span></span><span style="display:flex;"><span><span style="color:#75715e">#!/bin/sh</span>
</span></span><span style="display:flex;"><span>PID<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>cat /opt/sentinel-dashboard/sentinel-dashboard.pid<span style="color:#66d9ef">)</span>
</span></span><span style="display:flex;"><span>kill -9 $PID
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;wait sentinel-dashboard...&#39;</span>
</span></span></code></pre></div>]]></content>
        </item>
        
        <item>
            <title>Go Design Philosophy</title>
            <link>https://liguangchang.cn/posts/go/go-design-philosophy/</link>
            <pubDate>Tue, 08 Feb 2022 23:48:26 +0800</pubDate>
            
            <guid>https://liguangchang.cn/posts/go/go-design-philosophy/</guid>
            <description>Go history、philosophy。</description>
            <content type="html"><![CDATA[<p>Go  history、philosophy。</p>
]]></content>
        </item>
        
        <item>
            <title>Elasticsearch: 基本概念</title>
            <link>https://liguangchang.cn/posts/es/es-basic/</link>
            <pubDate>Sun, 30 Jan 2022 20:43:01 +0800</pubDate>
            
            <guid>https://liguangchang.cn/posts/es/es-basic/</guid>
            <description>version 7.15.x 节点 GET /{indexName}/_search_shards &amp;#34;roles&amp;#34; : [ &amp;#34;data&amp;#34;, &amp;#34;data_cold&amp;#34;, &amp;#34;data_content&amp;#34;, &amp;#34;data_frozen&amp;#34;, &amp;#34;data_hot&amp;#34;, &amp;#34;data_warm&amp;#34;, &amp;#34;ingest&amp;#34;, &amp;#34;master&amp;#34;, &amp;#34;ml&amp;#34;, &amp;#34;remote_cluster_client&amp;#34;, &amp;#34;transform&amp;#34; ] 每个节点启动，默认是 master eligible 节点，可以设置 node.master:false 禁止 master-eligible 节点可以参加选主流程，成为 master 节点 第一个节点启动时候，</description>
            <content type="html"><![CDATA[<ul>
<li>version 7.15.x</li>
</ul>
<h2 id="节点">节点</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>GET /<span style="color:#f92672">{</span>indexName<span style="color:#f92672">}</span>/_search_shards  
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;roles&#34;</span> : <span style="color:#f92672">[</span>
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;data&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;data_cold&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;data_content&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;data_frozen&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;data_hot&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;data_warm&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;ingest&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;master&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;ml&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;remote_cluster_client&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;transform&#34;</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">]</span>
</span></span></code></pre></div><ul>
<li>每个节点启动，默认是 master eligible 节点，可以设置 node.master:false 禁止</li>
<li>master-eligible 节点可以参加选主流程，成为 master 节点</li>
<li>第一个节点启动时候，会将自己选举成 master 节点</li>
<li>每个节点都保存了集群的状态，只有 master 节点才能修改集群的状态信息
<ul>
<li>node.master: true</li>
<li>集群状态 cluster state 维护了一个集群中的必要信息
<ul>
<li>所有的节点信息</li>
<li>所有的索引和其相关的 mapping 与 setting 信息</li>
<li>分片的路由信息</li>
</ul>
</li>
<li>任意节点都能修改信息将会导致数据不一致</li>
<li>？集中式中心架构？</li>
</ul>
</li>
<li>Data node
<ul>
<li>node.data: true</li>
<li>保存数据的节点，负责保存分片数据</li>
</ul>
</li>
<li>Coordinating node 协调节点
<ul>
<li>请求会跨越多个节点的时候（bulk_indexing，search）</li>
<li>Coordinating 节点负责接收 client 的请求，将请求分发到合适的节点，最终把结果汇集到一起，<strong>scatter-gather</strong>
<ul>
<li><strong>scatter阶段</strong>， 转发请求给含有相关数据的节点</li>
<li>Data 节点在本地执行请求后把结果返回给 coordinating 节点</li>
<li><strong>gather 阶段</strong>，Coordinating 节点汇总结果成一个单一的全局结果集</li>
</ul>
</li>
<li><strong>每个节点默认都起到了 Corrdinating node 的职责</strong></li>
</ul>
</li>
<li>Hot &amp; Warm node
<ul>
<li>不同硬件配置的 data node 实现冷热数据，降低成本</li>
</ul>
</li>
<li>Machine Learning Node
<ul>
<li>负责跑机器学习的 Job，用来做异常检测</li>
</ul>
</li>
<li>ingest node 提取节点
<ul>
<li>node.ingest: true</li>
<li>可以通过 ingest pipeline 对文档执行预处理操作，以便在索引文档之前对文档进行转换或者增强</li>
</ul>
</li>
<li>Client node
<ul>
<li>客户端节点
<ul>
<li>node.master : false</li>
<li>node.data: false</li>
</ul>
</li>
<li>节点只能处理路由请求，处理搜索，分发索引操作等，表现为智能负载平衡器</li>
<li>主节点必须等待每一个节点集群状态的更新确认，客户端节点太多会成为负担。</li>
</ul>
</li>
</ul>
<h2 id="shard">shard</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>GET /_cat/shards?v
</span></span></code></pre></div><h3 id="primary-shard">Primary shard</h3>
<p>主分片，解决数据水平拓展的问题，通过主分片，可以将数据分布到集群内的所有节点之上</p>
<ul>
<li>一个分片是一个运行的 Lucene 的实例</li>
<li>主分片数载索引创建时指定，后续不允许修改，除非 reindex</li>
</ul>
<p>需要提前做好容量规划</p>
<ul>
<li>分片设置过小
<ul>
<li>后续无法增加节点实现水平拓展</li>
<li>单个分片的数据量太大，导致数据重新分配耗时</li>
</ul>
</li>
<li>分片设置过大，7.0 开始，默认主分片设置为1，解决了 over-sharding 的问题
<ul>
<li>影响搜索结果的相关性打分，影响统计结果的准确性</li>
<li>单个节点上过多的分片，会导致资源浪费，同时影响性能</li>
</ul>
</li>
</ul>
<h3 id="replica-shard">Replica shard</h3>
<p>副本，解决数据高可用问题，分片是主分片的拷贝</p>
<ul>
<li>副本分片数，可以动态调整</li>
<li>增加福本数可以在一定程度上提高读取的吞吐</li>
</ul>
<h2 id="cluster-health">Cluster health</h2>
<p><code>GET /_cluster/health</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;cluster_name&#34;</span> : <span style="color:#e6db74">&#34;spider-es-cluster&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;status&#34;</span> : <span style="color:#e6db74">&#34;green&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;timed_out&#34;</span> : false,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;number_of_nodes&#34;</span> : 3,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;number_of_data_nodes&#34;</span> : 3,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;active_primary_shards&#34;</span> : 26,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;active_shards&#34;</span> : 52,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;relocating_shards&#34;</span> : 0,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;initializing_shards&#34;</span> : 0,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;unassigned_shards&#34;</span> : 0,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;delayed_unassigned_shards&#34;</span> : 0,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;number_of_pending_tasks&#34;</span> : 0,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;number_of_in_flight_fetch&#34;</span> : 0,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;task_max_waiting_in_queue_millis&#34;</span> : 0,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;active_shards_percent_as_number&#34;</span> : 100.0
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><ul>
<li>Green 主分片和副本都正常分配</li>
<li>Yellow 主分片全部正常分配，有副本分片未能正常分配</li>
<li>Red 有主分片未能分配
<ul>
<li>磁盘不够时</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>GET /_cat/nodes
</span></span><span style="display:flex;"><span>GET /_cat/shards
</span></span></code></pre></div><h2 id="crud">CRUD</h2>
<ul>
<li>index
<ul>
<li><strong>Id 不存在创建新的 doc，否则删除现有的文档，新的文档被索引，版本信息 +1</strong></li>
</ul>
</li>
<li>create
<ul>
<li>id 存在会失败</li>
</ul>
</li>
<li>read</li>
<li>update
<ul>
<li>文档必须存在，更新只会对相应字段做增量修改</li>
</ul>
</li>
<li>Delete</li>
</ul>
<h3 id="create">Create</h3>
<p><code>PUT index_name/_create/{id}</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>指定 文档id
</span></span></code></pre></div><p><code>POST /index_name/_doc/</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>自动生成id
</span></span></code></pre></div><h3 id="get">GET</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>GET /users/_doc/2
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;_index&#34;</span> : <span style="color:#e6db74">&#34;users&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;_type&#34;</span> : <span style="color:#e6db74">&#34;_doc&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;_id&#34;</span> : <span style="color:#e6db74">&#34;2&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;_version&#34;</span> : 1,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;_seq_no&#34;</span> : 1,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;_primary_term&#34;</span> : 1,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;found&#34;</span> : true,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;_source&#34;</span> : <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;firstName&#34;</span> : <span style="color:#e6db74">&#34;Jack&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;lastName&#34;</span> : <span style="color:#e6db74">&#34;Johnson&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;tags&#34;</span> : <span style="color:#f92672">[</span>
</span></span><span style="display:flex;"><span>      <span style="color:#e6db74">&#34;guitar&#34;</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#e6db74">&#34;stateboard&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>同一个 ID 的文档，即使被删除，version 号也会不断增加。</p>
<h3 id="update">Update</h3>
<ul>
<li>不会删除原来的文档，实现真正的数据更新</li>
<li>Post 方法，Payload 需要包含在 doc 中</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>POST /users/_update/2
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;doc&#34;</span>:<span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;firstName&#34;</span>:<span style="color:#e6db74">&#34;spider&#34;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><h3 id="index">index</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>PUT users/_doc/<span style="color:#f92672">{</span>id<span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>先删除，再更新版本号
</span></span></code></pre></div><h2 id="bulk">Bulk</h2>
<p>支持在一次 API 调用中，对不同的索引进行操作。</p>
<p>支持四种类型操作</p>
<ul>
<li>index</li>
<li>create</li>
<li>update</li>
<li>delete</li>
</ul>
<p>单个操作失败不会影响其他操作，返回每个操作执行的结果。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>POST <span style="color:#f92672">[</span>/<span style="color:#f92672">{</span>index_name<span style="color:#f92672">}</span>/<span style="color:#f92672">]</span>_bulk
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span> <span style="color:#e6db74">&#34;index&#34;</span> : <span style="color:#f92672">{</span> <span style="color:#e6db74">&#34;_index&#34;</span> : <span style="color:#e6db74">&#34;test&#34;</span>, <span style="color:#e6db74">&#34;_id&#34;</span> : <span style="color:#e6db74">&#34;1&#34;</span> <span style="color:#f92672">}</span> <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span> <span style="color:#e6db74">&#34;field1&#34;</span> : <span style="color:#e6db74">&#34;value1&#34;</span> <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span><span style="color:#e6db74">&#34;delete&#34;</span>:<span style="color:#f92672">{</span><span style="color:#e6db74">&#34;_index&#34;</span>:<span style="color:#e6db74">&#34;testa&#34;</span>,<span style="color:#e6db74">&#34;_id&#34;</span>:<span style="color:#e6db74">&#34;1&#34;</span><span style="color:#f92672">}}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span><span style="color:#e6db74">&#34;delete&#34;</span>:<span style="color:#f92672">{</span><span style="color:#e6db74">&#34;_index&#34;</span>:<span style="color:#e6db74">&#34;test&#34;</span>,<span style="color:#e6db74">&#34;_id&#34;</span>:<span style="color:#e6db74">&#34;2&#34;</span><span style="color:#f92672">}}</span>
</span></span></code></pre></div><h2 id="mget">mget</h2>
<p>根据 doc id查询</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>GET <span style="color:#f92672">[{</span>index_name<span style="color:#f92672">}]</span>/_mget
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;docs&#34;</span>:<span style="color:#f92672">[</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>      <span style="color:#e6db74">&#34;_index&#34;</span>:<span style="color:#e6db74">&#34;test&#34;</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#e6db74">&#34;_id&#34;</span>:1
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>      <span style="color:#e6db74">&#34;_index&#34;</span>:<span style="color:#e6db74">&#34;movies&#34;</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#e6db74">&#34;_id&#34;</span>:1
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>,
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>      <span style="color:#e6db74">&#34;_index&#34;</span>:<span style="color:#e6db74">&#34;movies&#34;</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#e6db74">&#34;_id&#34;</span>:29876
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><h2 id="msearch">msearch</h2>
<p>根据查询条件查询</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>POST kibana_sample_data_ecommerce/_msearch
</span></span><span style="display:flex;"><span><span style="color:#f92672">{}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span><span style="color:#e6db74">&#34;query&#34;</span>:<span style="color:#f92672">{</span><span style="color:#e6db74">&#34;match_all&#34;</span>:<span style="color:#f92672">{}}</span>,<span style="color:#e6db74">&#34;size&#34;</span>:1<span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span><span style="color:#e6db74">&#34;index&#34;</span>:<span style="color:#e6db74">&#34;kibana_sample_data_ecommerce&#34;</span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span><span style="color:#e6db74">&#34;query&#34;</span>:<span style="color:#f92672">{</span><span style="color:#e6db74">&#34;match_all&#34;</span>:<span style="color:#f92672">{}}</span>,<span style="color:#e6db74">&#34;size&#34;</span>:1<span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span><span style="color:#e6db74">&#34;index&#34;</span>:<span style="color:#e6db74">&#34;test&#34;</span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span><span style="color:#e6db74">&#34;query&#34;</span>:<span style="color:#f92672">{</span><span style="color:#e6db74">&#34;match_all&#34;</span>:<span style="color:#f92672">{}}</span>,<span style="color:#e6db74">&#34;size&#34;</span>:2<span style="color:#f92672">}</span>
</span></span></code></pre></div><h2 id="err-status_code">Err status_code</h2>
<table>
<thead>
<tr>
<th>问题</th>
<th>原因</th>
</tr>
</thead>
<tbody>
<tr>
<td>无法连接</td>
<td>网络故障/集群down</td>
</tr>
<tr>
<td>连接无法关闭</td>
<td>网络故障活节点出错</td>
</tr>
<tr>
<td>429</td>
<td>集群过于繁忙</td>
</tr>
<tr>
<td>4xx</td>
<td>请求体格式有错</td>
</tr>
<tr>
<td>500</td>
<td>集群内部错误</td>
</tr>
</tbody>
</table>
<h2 id="info">info</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#查看索引相关的信息</span>
</span></span><span style="display:flex;"><span>GET kibana_sample_data_ecommerce
</span></span><span style="display:flex;"><span><span style="color:#75715e">#查看索引的文档个数</span>
</span></span><span style="display:flex;"><span>GET kibana_sample_data_ecommerce/_count
</span></span><span style="display:flex;"><span>GET test
</span></span><span style="display:flex;"><span>POST kibana_sample_data_ecommerce/_search
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>GET /_cat/indices/kibana*?v&amp;s<span style="color:#f92672">=</span>index
</span></span><span style="display:flex;"><span>GET /_cat/indices?v&amp;health<span style="color:#f92672">=</span>green
</span></span><span style="display:flex;"><span>GET /_cat/indices?v&amp;s<span style="color:#f92672">=</span>docs.count:desc
</span></span><span style="display:flex;"><span>GET /_cat/indices/kibana*?pri&amp;v&amp;h<span style="color:#f92672">=</span>health,index,pri,rep,docs.count,mt
</span></span><span style="display:flex;"><span>GET /_cat/indices?v&amp;h<span style="color:#f92672">=</span>i,tm&amp;s<span style="color:#f92672">=</span>tm:desc
</span></span><span style="display:flex;"><span>GET /_cat/nodes?v
</span></span><span style="display:flex;"><span>GET /_cat/nodes?v&amp;h<span style="color:#f92672">=</span>id,ip,port,v,m
</span></span><span style="display:flex;"><span>GET /_cat/shards
</span></span><span style="display:flex;"><span>GET /_cat/indices
</span></span><span style="display:flex;"><span>GET /_cluster/health?level<span style="color:#f92672">=</span>shards
</span></span></code></pre></div><h2 id="analyzer">analyzer</h2>
<p>Analysis 文本分析是把全文本转换一系列单词 term/token 的过程。</p>
<p>Analysis 通过 analyzer 来实现的，可以使用内置的分析器或者按需定制化分析器。</p>
<p>数据写入和匹配 Query 语句时需要用相同的分析器对查询语句进行分析。</p>
<h3 id="组成">组成</h3>
<ul>
<li><strong>character filters</strong>
<ul>
<li>针对原始文本处理，eg 去除 html 标签</li>
</ul>
</li>
<li><strong>tokenizer</strong>
<ul>
<li>按照规则切分单词</li>
</ul>
</li>
<li><strong>token filter</strong>
<ul>
<li>将切分的单词进行加工，大小写转换，删除 stop words</li>
</ul>
</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/04/2uH6VjT5tqAlSEL.png" alt="analyzer"></p>
<h3 id="内置分词器">内置分词器</h3>
<ul>
<li>Standard Analyzer 默认粉刺起，按词切分，小些处理</li>
<li>Simple Analyzer     按照非字母切分，符号被过滤，小写处理</li>
<li>Stop Analyzer 小写处理，停用词过滤（the ,a , is）</li>
<li>Whitespace Analyzer 按照空格切分，不转小写</li>
<li>Keyword Analyzer 不分词，直接将输入当作输出</li>
<li>Patter Analyzer 正则表达式，默认 \W+ （非字符分隔）</li>
<li>Language 提供了30多种常见语言的分词器</li>
<li>Customer Analyzer 自定义分词器</li>
</ul>
<h3 id="_analyzer-api">_analyzer API</h3>
<ul>
<li>
<p>直接指定 Analyzer 进行测试</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>GET /_analyze
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;analyzer&#34;</span>: <span style="color:#e6db74">&#34;standard&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;text&#34;</span>:<span style="color:#e6db74">&#34;Master Elasticsearch,elasticsearch in Action&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div></li>
<li>
<p>指定索引的字段进行测试</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>POST movies/_analyze
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;field&#34;</span>: <span style="color:#e6db74">&#34;title&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;text&#34;</span>: <span style="color:#f92672">[</span><span style="color:#e6db74">&#34;Mastering Elasticsearch&#34;</span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div></li>
<li>
<p>自定义分词器进行测试</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>POST /_analyze
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;tokenizer&#34;</span>: <span style="color:#e6db74">&#34;standard&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;filter&#34;</span>: <span style="color:#f92672">[</span><span style="color:#e6db74">&#34;lowercase&#34;</span><span style="color:#f92672">]</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;text&#34;</span>:<span style="color:#e6db74">&#34;Mastering Elasticsearch&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div></li>
</ul>
<h3 id="standard-analyzer">standard analyzer</h3>
<ul>
<li>默认分词器</li>
<li>按词切分</li>
<li>小写处理</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/04/QYpcJXr7fmjvL5G.png" alt="standard_analyzer"></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>GET /_analyze
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;analyzer&#34;</span>: <span style="color:#e6db74">&#34;standard&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;text&#34;</span>: <span style="color:#f92672">[</span><span style="color:#e6db74">&#34;2 running Quick brown-foxes leap over lazy dogs in the summer evening&#34;</span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>只会对词进行切分，不过过滤停用词 in the
</span></span></code></pre></div><h3 id="simple-analyzer">simple analyzer</h3>
<ul>
<li>非字母切分，非字母的都被去除</li>
<li>小写处理</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>GET /_analyze
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;analyzer&#34;</span>: <span style="color:#e6db74">&#34;simple&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;text&#34;</span>: <span style="color:#f92672">[</span><span style="color:#e6db74">&#34;2 running Quick brown-foxes leap over lazy dogs in the summer evening&#34;</span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>brown
</span></span><span style="display:flex;"><span>foxes
</span></span></code></pre></div><h3 id="whitespace">whitespace</h3>
<ul>
<li>按照空格切分</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>GET /_analyze
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;analyzer&#34;</span>: <span style="color:#e6db74">&#34;whitespace&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;text&#34;</span>: <span style="color:#f92672">[</span><span style="color:#e6db74">&#34;2 running Quick brown-foxes leap over lazy dogs in the summer evening&#34;</span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">12</span> 个 token
</span></span></code></pre></div><h3 id="stop-analyzer">stop analyzer</h3>
<ul>
<li>非字母切分，非字母的都被去除</li>
<li>小写处理</li>
<li>Stop  filter
<ul>
<li>去除 the a is 等修饰性词语</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>GET /_analyze
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;analyzer&#34;</span>: <span style="color:#e6db74">&#34;stop&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;text&#34;</span>: <span style="color:#f92672">[</span><span style="color:#e6db74">&#34;2 running Quick brown-foxes leap over lazy dogs in the summer evening&#34;</span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2</span> 也没有了，
</span></span></code></pre></div><h3 id="keyword-analyzer">Keyword analyzer</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>GET /_analyze
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;analyzer&#34;</span>: <span style="color:#e6db74">&#34;keyword&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;text&#34;</span>: <span style="color:#f92672">[</span><span style="color:#e6db74">&#34;2 running Quick brown-foxes leap over lazy dogs in the summer evening&#34;</span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>不分词
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;tokens&#34;</span> : <span style="color:#f92672">[</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>      <span style="color:#e6db74">&#34;token&#34;</span> : <span style="color:#e6db74">&#34;2 running Quick brown-foxes leap over lazy dogs in the summer evening&#34;</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#e6db74">&#34;start_offset&#34;</span> : 0,
</span></span><span style="display:flex;"><span>      <span style="color:#e6db74">&#34;end_offset&#34;</span> : 69,
</span></span><span style="display:flex;"><span>      <span style="color:#e6db74">&#34;type&#34;</span> : <span style="color:#e6db74">&#34;word&#34;</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#e6db74">&#34;position&#34;</span> : <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><h3 id="pattern-analyzer">Pattern analyzer</h3>
<h3 id="icu-analyzer">ICU Analyzer</h3>
<ul>
<li>Elastic search-plugin install analysis-icu</li>
<li>提供了 unicode 支持，更好的支持亚洲语言</li>
</ul>
<h2 id="倒排索引">倒排索引</h2>
<h2 id="search-api">Search api</h2>
<ul>
<li>
<p>URL Search</p>
<ul>
<li>GET 方法，在 url 中使用查询参数</li>
<li>使用 &lsquo;q&rsquo; 指定查询字符串</li>
<li>&ldquo;query string syntax&rdquo; KV 键值对</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>cu http://localhost:9200/kibana_sample_data_ecommerce/_search?q<span style="color:#f92672">=</span>customer_first_name:Eddie | json
</span></span></code></pre></div><table>
<thead>
<tr>
<th>语法</th>
<th>范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>/_search</td>
<td>集群上所有索引</td>
</tr>
<tr>
<td>/index1/_search</td>
<td>index1</td>
</tr>
<tr>
<td>/index1.index2/_search</td>
<td>index1.index2，一条语句再多个index上执行</td>
</tr>
<tr>
<td>/index*/_search</td>
<td>Index 开头的索引</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Request Body Search</p>
<ul>
<li>基于 JSON 格式的 Query Domain Specific Language</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>cu -XGET/POST http://localhost:9200/kibana_sample_data_ecommerce/_search -H <span style="color:#e6db74">&#34;Content-type:application/json&#34;</span> -d <span style="color:#e6db74">&#39;{&#34;query&#34;:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">			{
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">				&#34;match_all&#34;:{}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">			}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">		 }&#39;</span> | json
</span></span></code></pre></div></li>
</ul>
<h2 id="relevance">Relevance</h2>
<p>Information retrieval 衡量相关性</p>
<ul>
<li>precision 查准率，尽可能返回较少的无关文档</li>
<li>recall 查全率，尽量返回较多的相关文档</li>
<li>ranking 是否能够按照相关度进行排序</li>
</ul>
<h2 id="uri-search">URI Search</h2>
<ul>
<li>q 指定查询语句，query string syntax</li>
<li>df 默认字段，不指定时会对所有字段进行查询</li>
<li>sort 排序,from, size 用于分页</li>
<li>profile 可以查看查询时如何被执行的</li>
</ul>
<h3 id="query-string-syntax">query string syntax</h3>
]]></content>
        </item>
        
        <item>
            <title>Tomcat Architechure</title>
            <link>https://liguangchang.cn/posts/java/tomcat-architecture/</link>
            <pubDate>Mon, 24 Jan 2022 23:00:06 +0800</pubDate>
            
            <guid>https://liguangchang.cn/posts/java/tomcat-architecture/</guid>
            <description>基于 Java 语言的轻量级应用服务器，完全开源免费的 Servlet 容器实现，最初由 sun 公司开发（JavaWebServer），作为 Servlet 容器的参考实现，1999 年与 JServe</description>
            <content type="html"><![CDATA[<p>基于 Java 语言的轻量级<strong>应用服务器</strong>，完全开源免费的 Servlet 容器实现，最初由 sun 公司开发（JavaWebServer），作为 Servlet 容器的参考实现，1999 年与 JServe （Apache）项目合并为 Tomcat，以 Apache License 许可发布。</p>
<blockquote>
<p>微服务架构 <a href="https://martinfowler.com/articles/microservices.html">https://martinfowler.com/articles/microservices.html</a></p>
</blockquote>
<blockquote>
<p>十二要素应用（构建 SAAS APP 方法论）https://12factor.net/</p>
</blockquote>
<blockquote>
<p>JPDA （Java Platform Debugger Architecture） <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/jpda/architecture.html">https://docs.oracle.com/javase/8/docs/technotes/guides/jpda/architecture.html</a></p>
</blockquote>
<h2 id="85-feat">8.5 feat</h2>
<ul>
<li>Servlet 3.1，JSP2.3，EL3.0，WebSocket1.1，Servlet4.0(9.0)</li>
<li>Servlet4Preview</li>
<li>8.0 默认 HTTP、AJP 链接器采用 NIO，8.5 移除了 BIO 的支持</li>
<li>新的资源实现，采用单独、一致的方法配置 Web 应用的附加资源，可以用于实现覆盖，eg: 将一个 WAR 作为多个 Web 应用的基础，同时 Web 应用拥有自己的定制功能。</li>
<li>8.0 链接器新增支持 JDK7 的 NIO2，HTTP/2</li>
<li>默认采用异步日志处理</li>
</ul>
<h2 id="设计">设计</h2>
<h3 id="10">1.0</h3>
<ol>
<li>接受、解析请求，处理，返回响应</li>
<li>socket  监听指定端口</li>
</ol>
<h3 id="20">2.0</h3>
<ol>
<li><strong>Connector，Container 将请求监听和请求处理分离</strong>，应对多种网络协议（HTTP，AJP）</li>
<li>Connector 负责开启 socket 监听客户端请求，返回响应数据</li>
<li>Container 负责具体的请求处理</li>
<li>二者分别拥有自己的 start()，stop() 方法来释放维护的资源</li>
<li><strong>一个 server 可以包含多个 Connector，Container</strong></li>
</ol>
<p><img src="https://s2.loli.net/2022/01/25/lMJSHQafgvuox6E.png" alt="tomcat-server"></p>
<h3 id="30">3.0</h3>
<p>一个 server 包含多个 service （互相独立，共享一个 JVM 以及系统类库）</p>
<p><strong>一个 service 负责维护（mapping）多个 container 和 一个 container</strong> ,这样来自 connector 的请求只能由它所属 service 维护的 container 处理。</p>
<p><img src="https://s2.loli.net/2022/01/25/SAce4noDp8PIJHC.png" alt="container-engine"></p>
<h3 id="40">4.0</h3>
<p>Engine （整个 servlet 引擎），<strong>负责请求的处理，不需要考虑请求链接、协议等的处理</strong>。</p>
<p><strong>应用服务器是一个运行环境</strong>，需要在 Engine 容器中支持管理 Web 应用，接收到 Connector 的处理请求时，Engine 容器能够找到一个合适的 Web 应用来处理。</p>
<p>context 表示一个 web 应用，一个 engine 可以包含多个 context。</p>
<p><img src="https://s2.loli.net/2022/01/25/Ma1QPcoVsxLWmSq.png" alt="container-context"></p>
<p>每个组件通过 start()，stop() 方法在启动时加载资源和停止时释放资源，使得组件充分解耦，提高服务器的可拓展性和可维护性。</p>
<h3 id="50">5.0</h3>
<p>如果<strong>一个服务实例要对多个域名提供服务</strong>，可以将每个域名视为一个<strong>虚拟</strong>的主机，每个虚拟主机下包含多个 web 应用。</p>
<p>Host 表示虚拟主机，一个 Host 可以包含多个 context。</p>
<p><img src="https://s2.loli.net/2022/01/25/8IM9kb4Hcd5uTwj.png" alt="container-host"></p>
<h3 id="60">6.0</h3>
<p>Servlet 规范中一个 Web 应用中可以包含多个 Servlet 实例处理不同链接的请求，需要一个组件的概念来表示 Servlet 定义，Tomcat 中 Servlet 定义被称为 Wrapper。</p>
<p><img src="https://s2.loli.net/2022/01/25/WaZrNIB4FT9A3HV.png" alt="container-wrapper"></p>
<h3 id="70">7.0</h3>
<p>Engine，context 组件的作用就是处理接受客户端的请求并返回数据，具体操作可能会委派到子组件完成。</p>
<p>使用 container 表示容器，container 可以添加并维护子容器，Engine，Host，Context，Wrapper 均继承自 Container。</p>
<p>嵌入式方式启动 Tomcat ,运行简单的请求处理，不必支持多 Web 场景，可以只在 Service 中维护一个简化版的 Engine。</p>
<p>默认实现。</p>
<p><img src="https://s2.loli.net/2022/01/25/FNUAHyYm4nL1Jci.png" alt="tomcat-container"></p>
<h3 id="后台处理">后台处理</h3>
<p>很多情况下，container 需要执行一些异步处理，而且是定期执行（web 文件变更的扫描），Tomcat 针对后台处理，在 Container 上定义了 backgroundProcess() 方法，其基础抽象类（ContainerBase）确保子啊启动组件的同时，异步启动后台处理，大多数情况，各个容器组件仅需要实现 Container 的 backgound-Process() 方法即可，不必考虑创建异步线程。</p>
<h2 id="lifecycle">Lifecycle</h2>
]]></content>
        </item>
        
        <item>
            <title>Refresh File</title>
            <link>https://liguangchang.cn/posts/java/refresh/</link>
            <pubDate>Tue, 18 Jan 2022 22:06:34 +0800</pubDate>
            
            <guid>https://liguangchang.cn/posts/java/refresh/</guid>
            <description>早就想写一下动态刷新方面的东西，主要是项目中的配置文件更新，最近也准备看一下 spring-cloud 方面的东西，大概是 slf4j，nacos，nio，air（go</description>
            <content type="html"><![CDATA[<p>早就想写一下动态刷新方面的东西，主要是项目中的配置文件更新，最近也准备看一下 spring-cloud 方面的东西，大概是 slf4j，nacos，nio，air（golang）动态更新的东西，这都是在刚刚洗澡的时候想起来的，大概的原理都知道，只是没空写。。。</p>
<p>其实想起来的是：项目中引用的外部 sdk，有一些方法的签名涉及到文件的路径，由于springboot maven plugin 打包的原因，导致无法获取到文件路径，现在的方案是通过 io 在 spring 启动过程中写到新的文件夹（固定的），洗澡的时候不知道怎么想起来，准备改成一个 random 文件夹或者带有特定字符串( prefxi/suffix )，项目关闭 通过 hook 去删除创建的文件夹，还有 lazy create 的方法可不可行。</p>
<p>另外就是</p>
<ul>
<li>spring config refresh 对 一些 bean 的影响</li>
<li>另外我在启动时将 io 写到文件夹后，运行过程中文件夹被删除了怎么办？</li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>Redis Skiplist</title>
            <link>https://liguangchang.cn/posts/redis/redis-skiplist/</link>
            <pubDate>Wed, 12 Jan 2022 00:39:52 +0800</pubDate>
            
            <guid>https://liguangchang.cn/posts/redis/redis-skiplist/</guid>
            <description>skiplist 是有序集合键的底层实现之一，有序集合包含的元素数量多或者元素是较长的字符串，redis 就会使用跳表来作为键的底层实现。 Skiplist 在每个节点中维持了</description>
            <content type="html"><![CDATA[<p>skiplist 是有序集合键的底层实现之一，有序集合包含的元素数量多或者元素是较长的字符串，redis 就会使用跳表来作为键的底层实现。</p>
<p>Skiplist 在<strong>每个节点中维持了多个指向其他节点的指针</strong>，从而达到快速访问节点的目的，平均支持 O(logN)，最坏 O(N) 复杂度的节点查找，还可以通过顺序性操作批量处理节点，大部分情况下效率和平衡树相当，实现更加简单。</p>
]]></content>
        </item>
        
        <item>
            <title>Redis Ziplist</title>
            <link>https://liguangchang.cn/posts/redis/redis-ziplist/</link>
            <pubDate>Tue, 11 Jan 2022 01:03:09 +0800</pubDate>
            
            <guid>https://liguangchang.cn/posts/redis/redis-ziplist/</guid>
            <description>Ziplist 底层实现更紧凑，节省内存，没有指针的使用，基于 ziplist 实现了 LIst、Hash、Sorted Set 。 Ziplist 结构 zlbytes 列表长度 4B ，记录整个列表占用的内存字节数</description>
            <content type="html"><![CDATA[<p>Ziplist 底层实现更紧凑，节省内存，没有指针的使用，基于 ziplist 实现了 LIst、Hash、Sorted Set 。</p>
<h2 id="ziplist-结构">Ziplist 结构</h2>
<ul>
<li>zlbytes 列表长度 4B ，记录整个列表占用的内存字节数，内存重分配或则会计算 zlend 时使用。</li>
<li>zltail     列表尾的偏移量</li>
<li>zllen  entry 个数，uint16_t，&lt; 65535 时，就是压缩列表的数量， <strong>= 65535 时，真实数量需要遍历计算</strong>。</li>
<li>中间是entry     可以保存一个字节数组或者整数值
<ul>
<li>prev_len   前一个 entry 的长度 1B/5B，1B=上一个entry.len &lt; 254B，5B=len+zlend，<strong>应用：从表尾遍历到表头</strong></li>
<li>len            自身长度 4B</li>
<li>encoding 编码方式 1B</li>
<li>content   实际数据</li>
</ul>
</li>
<li>zlend 列表结束 1B（default=255/0xFF，表示列表结束）</li>
</ul>
<p>中间 entry 相邻存放，不需要用额外的指针进行链接，可以节省指针占用的空间，同时也减少了在全局哈希表的k、v占用，v(n)。</p>
<h3 id="压缩列表节点的构成">压缩列表节点的构成</h3>
<p>每个列表节点可以保存一个字节数组或者整数值，分别对应的长度</p>
<ul>
<li>字节数组
<ul>
<li>&lt;= 63，2^6-1 B</li>
<li>&lt;=16383，2^14-1 B</li>
<li>&lt;=4 294 967 295， 2^32-1</li>
</ul>
</li>
<li>整数值
<ul>
<li>uint 4bit 0-12</li>
<li>1B int</li>
<li>3B int</li>
<li>int16_t</li>
<li>Int32_t</li>
<li>Int64_t</li>
</ul>
</li>
</ul>
<h3 id="encoding">encoding</h3>
<p>记录节点的 content 属性保存的数据类型以及长度。</p>
<ul>
<li>1B/2B/5B，值的最高位为 00，01，10 表示是字节数组编码，数组的长度由编码除去最高两位之后的其他位记录。</li>
<li>1B，值的最高位以11开头的表示是整数编码，整数值的类型和长度由编码除去最高两位之后的其他位记录。</li>
</ul>
<h3 id="cascade-update">Cascade update</h3>
<p>Entry prev_len 存储的是前一个 entry 的长度，最坏的情况，在<strong>表头插入一个长度大于 254 的 entry</strong>，导致后面所有的 entry 内存一直重分配到最后。</p>
<p>如果<strong>删除列表中 big_entry 后面的 small_entry</strong> ，最坏的情况易导致后面的所有的 entry 级联更新。</p>
<p><strong>最坏的情况需要列表中存在连续并且长度在 250-253 之间的并且数量比较多的节点，才会对性能造成影响。</strong></p>
<p>当列表键包含少量列表项时，Redis 会使用压缩列表来做列表键的底层实现， <strong>object encoding mylist</strong> 可以观察底层实现，benchmark 写入的 10000 个 value 到 mylist，底层就没用 ziplist。</p>
]]></content>
        </item>
        
        <item>
            <title>Redis Sds</title>
            <link>https://liguangchang.cn/posts/redis/redis-sds/</link>
            <pubDate>Tue, 11 Jan 2022 00:09:02 +0800</pubDate>
            
            <guid>https://liguangchang.cn/posts/redis/redis-sds/</guid>
            <description>simple dynamic string SDS 用来表示数据库中的字符串值，还被用做缓冲区（AOF缓冲区、客户端状态中的输入缓冲区）。 SDS 结构 len（4B）buf 已用长度 alloc (4B) buf 实际分</description>
            <content type="html"><![CDATA[<h2 id="simple-dynamic-string">simple dynamic string</h2>
<p>SDS 用来表示数据库中的字符串值，还被用做缓冲区（AOF缓冲区、客户端状态中的输入缓冲区）。</p>
<p>SDS 结构</p>
<ul>
<li>len（4B）buf 已用长度</li>
<li>alloc (4B)  buf 实际分配长度</li>
<li>buf            字节数组</li>
</ul>
<p>由于结构体中包含字符串的长度，所以获取字符串的长度复杂度为 O(1)。</p>
<h3 id="sds空间分配">SDS空间分配</h3>
<p>字符串的修改操作，会导致内存重分配，内存重新分配开销比较大，SDS 实现了<strong>空间预分配</strong>和<strong>惰性空间释放</strong>两种策略来<strong>优化字符串的扩缩容</strong>。</p>
<h4 id="空间预分配">空间预分配</h4>
<p>预分配优化 SDS 字符串增长操作，可能会需要进行空间拓展时，额外分配未使用的空间，来减少扩容的内存重分配次数。</p>
<ul>
<li>修改后 len &lt; 1m，预分配和 len 大小相等的未使用空间(alloc = 2len)</li>
<li>修改后 len &gt; 1m，预分配 1m 的 未使用空间 (alloc = len + 1m)</li>
</ul>
<h4 id="惰性释放">惰性释放</h4>
<p>惰性空间释放优化字符串缩容操作，修改后 SDS 容量缩小，<strong>不会立即进行内存重分配回收多出来的空间</strong>，而是记录起来，作为未使用空间保留，后续可能还会出现扩容的情况，有一点点 GC 的感觉。</p>
<p><strong>SDS API 也提供了释放未使用空间的操作来避免内存浪费。</strong></p>
<h3 id="binary-safe">binary safe</h3>
<p>SDS 结构中的 len 和 buf ，可以不根据 空字符串来判断结束，让 SDS适用于更多的场景（二进制数据）。</p>
<h3 id="compatibility">compatibility</h3>
<p>buf 数组空间最后多分配一个字节容纳空字符，让保存文本数据的 SDS可以重用一部分库函数。</p>
<p>Redis 的数据类型有很多，不同数据类型有相同的元数据要记录(最后一次访问的时间，被引用的次数。。。)，使用 RedisObject 结构体来统一记录元数据，同时指向实际数据。</p>
<h3 id="redisobject">RedisObject</h3>
<ul>
<li>元数据 8B</li>
<li>ptr 8B 指向具体数据类型的实际数据 -&gt; SDS</li>
</ul>
<h2 id="string">String</h2>
<h3 id="int编码模式">int编码模式</h3>
<p>当保存 64 位有符号整数时，String 类型会把它保存为一个 <strong>8 字节</strong>的 Long 类型整数，这个时候 ptr <strong>指针就直接赋值为整数数据</strong>。</p>
<p>当保存的数据中包含字符时，String 类型就会用简单动态字符串结构体来保存。</p>
<h3 id="embstr编码模式">embstr编码模式</h3>
<p>当保存的是字符串数据，并且字符串 &lt;= 44 字节时，RedisObject 中的元数据、指针和 SDS 是一块连续的内存区域，来避免内存碎片。</p>
<h3 id="raw编码模式">raw编码模式</h3>
<p>当字符串 &gt;= 44 字节时，SDS 的数据量变多了，Redis 就不再把 SDS 和 RedisObject 布局在一起，而是会给 SDS 分配独立的空间，用指针指向 SDS 结构。</p>
<p>当存储整数 pair 时，由于使用的全局哈希表存储所有的键值对，每个键值对存储了 key、value、next 的指针（8B*3=24）,int 编码下，RedisObject 为 (8B+8B) * 2，24+32 = 56 &lt; 64，所以存储整数 pair 占用 64B。</p>
<h2 id="jemalloc">jemalloc</h2>
<p>jemalloc 分配内存时，会根据申请的字节数 N ，找一个比 N 大，但是最接近 N 的 2 次幂最为分配的空间，减少频繁分配的次数。</p>
]]></content>
        </item>
        
        <item>
            <title>Redis Sentinel Cluster</title>
            <link>https://liguangchang.cn/posts/redis/redis-sentinel-cluster/</link>
            <pubDate>Mon, 10 Jan 2022 01:11:11 +0800</pubDate>
            
            <guid>https://liguangchang.cn/posts/redis/redis-sentinel-cluster/</guid>
            <description>主从模式下的高可用，通过哨兵机制来保证，哨兵机制可以实现主从库的自动切换，解决主从复制模式下的故障转移，主要任务是 监控、选主、通知。 哨兵是一</description>
            <content type="html"><![CDATA[<p>主从模式下的高可用，通过哨兵机制来保证，哨兵机制可以实现主从库的自动切换，解决主从复制模式下的故障转移，主要任务是 <strong>监控、选主、通知</strong>。</p>
<p>哨兵是一个运行在特殊模式下的一个 Redis 进程，可以看作一个 sidercar。</p>
<h2 id="监控">监控</h2>
<p>哨兵进程运行时，周期性的给所有的主从库发送 PING 命令，检测它们是否仍然在线运行。</p>
<p>如果没有在周期规定时间内响应哨兵的 PING 命令，哨兵就会标记为 <strong>下线状态</strong>，主节点没有正常响应，就会开始切换主库的流程。</p>
<h3 id="主观下线">主观下线</h3>
<p>哨兵发现主库响应超时，哨兵会对它标记为 &ldquo;主观下线&rdquo;，集中式架构下的主节点不能轻易的变换。如果发现从库下线就直接下线，从库的下线一半影响不大，集群对外的服务不会间断。</p>
<p>如果哨兵误判主节点下线，后续的选主和通知的开销都是没必要的，误判一般发生在集群网络压力较大、网络拥塞，或者主库本身压力较大的情况下。</p>
<p>多个哨兵实例一起来判断，避免单个实例由于一些特殊原因误判主节点下线，来提供容错，降低风险。</p>
<h3 id="客观下线">客观下线</h3>
<p>存在 N 个哨兵时，有 N/2 + 1个实例判断主库主观下线，采用少数服从多数的原则，来认定主节点 “客观下线”，开始选主。</p>
<h2 id="选主">选主</h2>
<p>判定主节点确实下线了之后，就从从库中选出来一个从库实例作为主库。</p>
<p>从节点选主通过对从节点筛选和打分的规则，来选出一个从库作为主库。</p>
<ul>
<li>
<p>筛选</p>
</li>
<li>
<p>检查从库的当前在线状态，还要判断之前的网络链接状态，断连次数超过一定的阈值，就认定该从库网络状态不好，过滤掉，可以认为不足以作为主节点 （candidate）。</p>
<p>down-after-milliseconds 认定主从库断连的最大连接超时时间，断连超过10次，就说明这个从库网络状况不好，不适合作为 主节点（candidate）。</p>
</li>
<li>
<p>三轮打分（从库优先级、从库复制进度、从库 ID 号）</p>
<ol>
<li>slave-priority 可根据从库的实际情况（规格、数据量、压力）来设置优先级，优先级最高的从库得分高。</li>
<li>和旧库同步程度最接近的从库得分高，保证新主库的数据最新。slave_repl_offset 最接近 master_repl_offset，从库同步进度一样，就需要第三轮打分。</li>
<li>ID号小的从库得分高（优先级和复制进度都相同的情况下），表明该从节点连接较早且稳定。</li>
</ol>
</li>
</ul>
<h2 id="通知">通知</h2>
<p>主节点切换后，哨兵需要把新主库的链接信息发送给其他从库，让它们执行 replicaof 命令，和新主库建立链接，并进行数据复制，同时哨兵会把新主库的链接信息通知给客户端，让它们把请求操作发送到新主库上。</p>
<h2 id="选主过程中的写入">选主过程中的写入</h2>
<p>在选主过程中，<strong>新的写入会失败</strong>，<strong>业务端无感知需要先将失败的请求缓存或写入MQ，等选完主后，在将这些操作写入</strong>，主从切换时间过长，会导致客户端或MQ 写入请求过多，切换完重放请求时间过长。</p>
<p>down-after-milliseconds 可以让哨兵对主从切换敏感，切换及时对业务影响最小，但是可能会因为网络的抖动导致不必要的切换。配置的时间太长，可以减少哨兵误判的概率，但是在真正发生故障时，业务的写失败会比较久，缓存写入 请求数据量越多。</p>
<h2 id="pubsub-哨兵集群">pub/sub 哨兵集群</h2>
<p>哨兵实例之间的互相发现通过 pub/sub 机制实现，哨兵和主库建立了连接，就可以在主库上发布消息，同时也可以从主库上订阅消息，获得其他哨兵的连接信息，多个哨兵都在主库上做了发布订阅操作后，哨兵实例之间就能够知道彼此之间的 IP 地址和端口。</p>
<p>主从集群中的主库 &lt;<strong>sentinel</strong>:hello&gt; 频道，哨兵通过它来通信实现互相发现，然后建立网络连接，哨兵通过<strong>向主库发送 INFO 命令获取从库列表</strong>，哨兵在和每个从库建立连接，并在建立的连接上持续地对从库进行监控。</p>
<h2 id="客户端通知">客户端通知</h2>
<p>主从切换后，客户端需要知道新的主库信息，<strong>redis 通过事件让客户端知道哨兵工作过程中节点之间的变更事件</strong>，哨兵实例也提供 pub/sub 机制，客户端可以从哨兵订阅消息，消息订阅频道对应不同切换过程中的不同关键事件。</p>
<h2 id="切换关键事件">切换关键事件</h2>
<ul>
<li>主库下线事件
<ul>
<li>+sdown  实例进入 主观下线</li>
<li>-sdown   实例退出 主观下线</li>
<li>+odown  实例进入 客观下线</li>
<li>-odown   实例退出 客观下线</li>
</ul>
</li>
<li>从库重新配置事件
<ul>
<li>+slave-reconf-sent      哨兵发送 slaveof 命令冲洗配置从库</li>
<li>+slave-reconf-inprog  从库配置了新主库，但尚未进行同步</li>
<li>+slave-reconf-done     从库配置了新主库，并且和新主库完成同步</li>
</ul>
</li>
<li>新主库切换
<ul>
<li>+switch-master 主库地址发生变化</li>
</ul>
</li>
</ul>
<h2 id="由哪一个哨兵执行切换">由哪一个哨兵执行切换</h2>
<p>任何一个实例判断出主库 “客观下线“ 后，就会给其他实例发送 ‘<strong>is-master-down-by-addr</strong>&rsquo; 命令，其他实例会根据自己和主库的连接情况，作出 Y/N 响应。</p>
<p>quorum 可以配置获得投票数，也就是能够判定主库 &ldquo;客观下线&quot;的实例个数**。？如果增加实例个数，这个配置怎么更新？**</p>
<p>投票过程中，<strong>想要成为 leader 的哨兵实例需要获得到半数以上的投票 并且 获得票数要大于等于哨兵配置文件中的 quorum 值</strong>。</p>
<p>获得的票数没有满足条件，将继续进行投票，<strong>如果哨兵集群只有两个实例，要想成为 leader 必须获得 2 票</strong>。</p>
<p>哨兵对主库在线检测状态属于时间事件，使用定时器来完成，每个哨兵的定时器会在执行周期上加上一个小小的随机时间偏移，来错开多实例同时检测到主节点下线的时间，减少投票轮数，无法选出 leader，会等待 failover_timeout * 2 时间，进行下一轮投票。</p>
<p>一轮只投一票，这很 raft。</p>
<h2 id="总结">总结</h2>
<ul>
<li>
<p>基于 pub/sub 机制的组成哨兵集群</p>
</li>
<li>
<p>基于 INFO 命令的从库列表，帮助哨兵和从库建立连接</p>
</li>
<li>
<p>基于哨兵自身的 pub/sub 功能，实现了客户端和哨兵之间的事件通知</p>
</li>
</ul>
<p><strong>要保证所有哨兵实例的配置是一致的，尤其是主观下线的判断 down-after-milliseconds</strong>。</p>
<h2 id="q">Q</h2>
<p><strong>？如果增加哨兵实例个数，这个配置怎么更新？</strong></p>
<h2 id="切片集群">切片集群</h2>
]]></content>
        </item>
        
        <item>
            <title>Optimizing Java</title>
            <link>https://liguangchang.cn/posts/java/optimizing-java/</link>
            <pubDate>Fri, 07 Jan 2022 23:19:15 +0800</pubDate>
            
            <guid>https://liguangchang.cn/posts/java/optimizing-java/</guid>
            <description>性能调优没有任何灵丹妙药，任何性能决策，都要通过合理的性能测试来检验。 应用程序的性能很多时候不是用时间而是用人民币来计算的，所有的性能问题都</description>
            <content type="html"><![CDATA[<p>性能调优没有任何灵丹妙药，任何性能决策，都要通过合理的性能测试来检验。</p>
<p>应用程序的性能很多时候不是用时间而是用人民币来计算的，所有的性能问题都没有单一的解决方案，而是有很多解决方案，技巧就是找到那些方案，并把最满足要求的拼凑起来。</p>
<p>性能分析是坚实的经验注意和软件的人类心理学的奇异组合，重点在于，一方面是可观测指标的绝对数字，另一方面是最终用户和干系人如何看待这些数字。</p>
<p>技术一直在革自己的命，不使用量化和可验证的方式来优化性能是有害的。</p>
<p>JVM 性能调优是技术、方法论、可测的量和工具的综合，目的是使以期望的方式产生可以测量的输出，通过一下方式实现预期结果</p>
<ul>
<li>定义期望的结果</li>
<li>测量现有系统</li>
<li>确定要实现需求所需的工作</li>
<li>开始某个改进操作</li>
<li>重新测试</li>
<li>确定目标是否实现</li>
</ul>
<p>性能分析是建立在定义和实现非功能性需求的基础之上的。</p>
<h2 id="可量化的调优目标">可量化的调优目标</h2>
<ul>
<li>吞吐量 throuhtput</li>
<li>延迟 latency</li>
<li>容量 capacity</li>
<li>利用率 utilization</li>
<li>效率 efficiency</li>
<li>可拓展性 scalability</li>
<li>降级 degradation</li>
</ul>
<p>很可能出现的情况：优化一个指标可能会损害另外的指标。</p>
]]></content>
        </item>
        
        <item>
            <title>Consistency Hash</title>
            <link>https://liguangchang.cn/posts/distributed/consistency-hash/</link>
            <pubDate>Fri, 07 Jan 2022 13:18:09 +0800</pubDate>
            
            <guid>https://liguangchang.cn/posts/distributed/consistency-hash/</guid>
            <description>这几天在看 redis 看了不少哈希，昨天晚上又看之前的分布式的东西，看到分布式高可靠的负载均衡，里面也有哈希来做负载均衡，但是都没有解决有状态的，根据</description>
            <content type="html"><![CDATA[<p>这几天在看 redis 看了不少哈希，昨天晚上又看之前的分布式的东西，看到分布式高可靠的负载均衡，里面也有哈希来做负载均衡，但是都没有解决有状态的，根据请求资源消耗来做负载的，之前总听说 go-zero 有一些自适应这，自适应那的东西，正好一块记录一下，后面有空用用 go-zero，目前对 go-zero 的了解只有有一些 tool，redis 只有 0 库，。。。</p>
<p>看了一下 go-zero 自适应负载的大概算法，https://learnku.com/articles/60059，上厕所想到了 TCP 的 RTO ，不过这个是在分布式环境下的，TCP RTO 是针对一个连接的。</p>
]]></content>
        </item>
        
        <item>
            <title>Redis Basic</title>
            <link>https://liguangchang.cn/posts/redis/redis-basic/</link>
            <pubDate>Tue, 04 Jan 2022 21:56:53 +0800</pubDate>
            
            <guid>https://liguangchang.cn/posts/redis/redis-basic/</guid>
            <description>数据结构 Value String List Hash Set Sorted Set 底层数据结构 简单动态字符串 双向链表 压缩列表 哈希表 跳表 整数数组 mapping String 简单动态字符串 List 双向链表 压缩列表 Hash 压缩列表 哈希表 Sorted Set 压</description>
            <content type="html"><![CDATA[<h2 id="数据结构">数据结构</h2>
<h3 id="value">Value</h3>
<ul>
<li>String</li>
<li>List</li>
<li>Hash</li>
<li>Set</li>
<li>Sorted Set</li>
</ul>
<h3 id="底层数据结构">底层数据结构</h3>
<ul>
<li>简单动态字符串</li>
<li>双向链表</li>
<li>压缩列表</li>
<li>哈希表</li>
<li>跳表</li>
<li>整数数组</li>
</ul>
<h3 id="mapping">mapping</h3>
<ul>
<li>String
<ul>
<li>简单动态字符串</li>
</ul>
</li>
<li>List
<ul>
<li>双向链表</li>
<li>压缩列表</li>
</ul>
</li>
<li>Hash
<ul>
<li>压缩列表</li>
<li>哈希表</li>
</ul>
</li>
<li>Sorted Set
<ul>
<li>压缩列表</li>
<li>跳表</li>
</ul>
</li>
<li>Set
<ul>
<li>哈希表</li>
<li>整数数组</li>
</ul>
</li>
</ul>
<h3 id="键值对存储结构">键值对存储结构</h3>
<p>redis 使用 哈希表来保存所有的键值对，哈希桶存储指向具体值的指针，对外提供一个很简洁的操作接口 O(1) ，屏蔽了不同的数据类型。</p>
<h3 id="hash-散列冲突">Hash 散列冲突</h3>
<p><strong>key0  !=  key1，hash(key0) = hash (key1) ，就会放到一个桶的位置，数据量越大哈希冲突的概率就会变大，n -&gt; [0,len(array)]</strong></p>
<h3 id="解决冲突">解决冲突</h3>
<ul>
<li>
<p>链地址法</p>
<p>冲突的数据排成链表，头插（新的数据在链表的末尾），链表顺序遍历速度慢，hash 算法不好会退化成链表 O(n)。</p>
<p>看具体的实现，java hashMap 在桶内数据 &gt; 8 并且数组长度&gt; 64 ，就把链表转化为红黑树，根据 hash 算法的分布概率情况，以及均摊分析后，时间复杂度还是 O(1)。</p>
</li>
<li>
<p>开放地址探测法</p>
<p>出现冲突，继续找合适的位置。</p>
<ul>
<li>
<p>线性探测法</p>
<p>直接判断使用下一个空闲单元，步长为1。</p>
</li>
<li>
<p>平方探测法</p>
<p>使用公式 冲突单元索引  + 1^2/2^2/3^2&hellip; 不是线性查找， 步长较大，一般探测一半就足够了。</p>
</li>
<li>
<p>双散列函数探测法</p>
<p>使用另外一个散列函数作为步长增量探测，<strong>不太理解</strong>。</p>
</li>
</ul>
</li>
<li>
<p>再哈希</p>
<ul>
<li>同时构造多个不同的哈希函数，发生冲突时用其他哈希函数计算，知道冲突不在产生，不易产生聚集，增加了计算时间。</li>
</ul>
</li>
<li>
<p>建立公共溢出区</p>
<ul>
<li>将哈希表氛围公共表和溢出表，溢出发生时，将所有溢出数据统一放到溢出区。</li>
</ul>
</li>
</ul>
<p>Redis 解决 hash 冲突也是通过链式 hash，不过会做 rehash 操作，通过增加现有的 hash 桶数量，让逐渐增多的元素分散存储，减少单个桶的元素数量，减少单个桶的冲突。</p>
<h3 id="两个全局哈希表">两个全局哈希表</h3>
<p>Redis 采用了两个全局哈希表，一开始默认使用表1，此时表2 没有被分配空间，随着数据增多，开始 rehash，增加现有桶的数量，让元素能够更分散，减少单个桶的元素数量。</p>
<ol>
<li>给 表2 分配更大的空间</li>
<li>把表1 中的数据重新映射并拷贝到表2</li>
<li>释放表1 空间</li>
</ol>
<h3 id="渐进式-rehash">渐进式 rehash</h3>
<p>Rehash 的过程中表数据迁移会阻塞线程，无法服务其他请求。</p>
<p>Redis 在拷贝数据的时候，每处理一个请求时，从表1中第一个索引位置开始，顺带将这个索引位置上的所有数据拷贝到表2中，等待下一个请求时，在顺带拷贝表1 中的下一个索引位置的数据。</p>
<p><strong>将迁移的工作量分散到了多次的请求中，避免了长时间迁移导致的不可用，但是会长时间存在两个哈希表。</strong></p>
<p><strong>？Golang rehash</strong></p>
<h3 id="集合数据效率">集合数据效率</h3>
<p>整数数组和双向链表都是顺序读写，时间复杂度为 O(N)，操作效率比较低。</p>
<h3 id="压缩列表">压缩列表</h3>
<p>压缩列表类似数组，每一个元素都对应保存一个数据，和数组不同的是，表头有三个字段 <strong>zlbytes、zltail、zllen</strong>，分别表示<strong>列表长度</strong>、<strong>列表尾的偏移量</strong>和<strong>列表中的 entry 个数</strong>，<strong>表尾 zlend，表示列表结束</strong>。</p>
<p>基于这样的结构，压缩列表访问第一个和最后一个元素的时间复杂度是 O(1)，访问中间元素的时间复杂度是 O(N)。</p>
<h3 id="跳表">跳表</h3>
<p>跳表结构在链表基础上构建多级索引，有了索引就比大小，跳来跳去定位到元素，减少了链表的顺序寻找次数，当数据量很大的时候，时间复杂度就是 O(logN)。</p>
<h3 id="时间复杂度">时间复杂度</h3>
<ul>
<li>整数数组</li>
<li>压缩列表</li>
<li>跳表</li>
<li>双向列表</li>
<li>哈希表 O(1)</li>
</ul>
<h3 id="常见复杂度">常见复杂度</h3>
<ul>
<li>
<p>单元素操作</p>
<ul>
<li>Hash (Hset,Hget,HDel )</li>
<li>Set (SADD,SREM,SRANDMEMBER)</li>
</ul>
<p>底层数据类型是哈希结构时，对单元素的操作时间复杂度是 O(1)，支持多个参数时，时间复杂度也会随着参数个数增加。</p>
</li>
<li>
<p>范围操作</p>
<ul>
<li>
<p>Hash HGETALL</p>
</li>
<li>
<p>Set SMEMBERS</p>
</li>
<li>
<p>List LRANGE</p>
</li>
<li>
<p>ZSet ZRANGE</p>
<p>这类操作比较耗时，会造成阻塞。</p>
</li>
<li>
<p>SCAN （HSCAN、SSCAN、ZSCAN）渐进式遍历，可以避免阻塞。</p>
</li>
</ul>
</li>
<li>
<p>统计操作</p>
<ul>
<li>集合类型对集合中的所有元素个书的记录</li>
</ul>
</li>
<li>
<p>LLEN，SCARD  O(1)</p>
<ul>
<li>集合类型采用压缩列表、双向链表、整数数组存储时，有专门记录元素的个数统计，可以高效完成统计。</li>
</ul>
</li>
<li>
<p>例外</p>
<ul>
<li>LPOP,RPOP,LPUSH,RPUSH 在队列的头尾增删元素，可以通过偏移量直接定位，负责度也只有O(1)。</li>
</ul>
</li>
</ul>
<h3 id="内存利用率">内存利用率</h3>
<p>底层紧凑的数据结构：数组和压缩列表可以提高内存利用率，另外数组对 CPU 高速缓存支持更友好，在集合元素较少的情况下，默认采用紧凑排列的方式存储，利用 CPU 高速缓存不会降低访问速度，数据量超过设定阈值后，转为哈希和跳表存储来保证查询效率。</p>
<h2 id="单线程快">“单线程快”</h2>
<p>Redis <strong>网络IO 和键值对读写由一个线程完成</strong>，放弃多线程并发访问带来的控制开销，其他的功能eg:持久化、异步删除、集群数据同步等由额外的线程执行。</p>
<p>Redis 利用<strong>单线程 + 多路复用（socket） + 高效数据结构</strong>来提供并发高性能，网络IO 过程为 bind/listen，<strong>accept，recv</strong>，开始建立 socket 链接后，会存在阻塞。</p>
<h3 id="socket-非阻塞模式">Socket 非阻塞模式</h3>
<ul>
<li>socket  返回  主动套接字</li>
<li>listen    返回  监听套接字     可设置非阻塞模型 服务端监听连接请求，没有链接就空闲不处理，等待链接通知</li>
<li>Accept  返回  已链接套接字 可设置非阻塞模型 服务端监听等待数据到达</li>
</ul>
<h3 id="io-多路复用">IO 多路复用</h3>
<p>这个没啥写的。</p>
<h3 id="单线程处理-io-性能瓶颈">单线程处理 IO 性能瓶颈</h3>
<p>任意一个请求发生耗时，会影响整个性能</p>
<ul>
<li>操作 bigkey，读写都耗时</li>
<li>大量 key 集中过期，<strong>过期机制在主线程中执行</strong>（4.0 feat lazy-free 异步释放）</li>
<li>使用复杂度过高的命令，操作数据量大</li>
<li>淘汰策略，淘汰策略也是在主线程中执行，内存超过上限后，每次写入都需要额外做淘汰策略，增加耗时（前提是配置了淘汰策略）</li>
<li>AOF 开启always 每次写操作都要额外写磁盘</li>
<li>主从全量同步生成 RDB，fork 子进程一瞬间会阻塞整个线程</li>
<li>并发量非常大，虽然IO 多路复用，单线程同步读写客户端 IO ，无法利用到多核，就像一直工作的发牌机器（6.0 feat 多线程读写客户端数据，依然单线程执行命令）</li>
</ul>
<p>利用审计平台，严格避免复杂度搞的命令。</p>
<h2 id="aof">AOF</h2>
<p>Append Only File，AOF 日志流程： 执行命令写内存，记录日志，<strong>在主线程中执行</strong>。</p>
<h3 id="日志格式">日志格式</h3>
<p>*n 表示命令有几个部分，每部分都是 $+数字开头，后面跟着具体的命令、k/v，数字表示这部分中的命令、k/v 一共有多少字节。</p>
<pre tabindex="0"><code>set testkey testval -&gt; 
*3
$3
set
$7
testkey
$7
testval
</code></pre><p><strong>为了避免额外的检查开销，写 AOF 日志的时候，不会对命令进行语义检查（不阻塞当前操作），所以日志只会记录执行成功的命令。</strong></p>
<ul>
<li>刚执行完还没写入日志，如果宕机就会丢失数据，并且无法恢复。</li>
<li>执行完当前命令，写日志如果很慢，会阻塞后续操作。</li>
</ul>
<h3 id="appendfsync">appendfsync</h3>
<ul>
<li>always		同步写回，执行完命令立马写到磁盘</li>
<li>everysec    每秒写回，先写到 AOF 文件的内存缓冲区，每秒把缓冲区中的内容写回磁盘</li>
<li>no               由操作系统的写决定何时将缓冲区内容写回磁盘</li>
</ul>
<p>明显 always 最可靠，也最影响性能，every sec 可能会丢失 1s 数据，no 性能最高，最不可靠。</p>
<p>针对 AOF 日志文件的增大、写缓慢，和故障恢复重新执行的缓慢问题，redis 提供了 AOF 重写功能，来把文件变小。</p>
<h3 id="aof重写">AOF重写</h3>
<p>多变一，针对同一个键值对，只存在一条命令，恢复时只执行一条命令。</p>
<ul>
<li>每次重写时，fork 子进程，通过共享页表来共享内存数据，逐一拷贝数据写入重写日志</li>
<li>冲写过程中有新的操作，会写入AOF重写缓冲，如果宕机，旧的 AOF 还是全量数据，不会丢失</li>
<li>主线程处理新的请求，会把操作写到缓冲区（AOF,AOF重写）</li>
<li>重写期间所有数据写完，就会切换到新的 AOF 日志</li>
<li><strong>重写过程不会阻塞主线程</strong></li>
<li><strong>过期时间保存为绝对时间，利用 AOF恢复数据如果过期不会分配内存</strong></li>
</ul>
<h3 id="重写时机">重写时机</h3>
<ul>
<li>auto-aof-rewrite-min-size 64mb AOF 文件体量超过 64m</li>
<li>auto-aof-rewrite-percentage 100，比上次重写后的增加的百分比</li>
</ul>
<p><strong>COW 过程中出现读写操作，内存页(大小，HUGO PAGE)拷贝会影响性能。</strong></p>
<h3 id="bgrewriteaof">bgrewriteaof</h3>
<p>异步执行AOF文件重写操作，即使 Bgrewriteaof 执行失败，也不会有任何数据丢失，旧的 AOF 文件在 bgrewriteaof 成功之前不会被修改。</p>
<h2 id="rdb">RDB</h2>
<p>Redis DataBase，记录某时刻的<strong>全量数据</strong>，恢复数据可以直接读入内存。</p>
<ul>
<li>save        主线程中执行，会阻塞</li>
<li>bgsave    创建子进程，专门写入 RBD 文件，默认配置</li>
</ul>
<p>fork 创建子进程会阻塞主线程，为了避免频繁的 fork ，Redis 4.0 提出<strong>混合使用 AOF日志和内存快照</strong>的方法，<strong>aof-use-rdb-preamble</strong>，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作，<strong>第二次全量快照同步的时候，就会清空 AOF 日志。</strong></p>
<p>在AOF 重写时就直接把内存中的数据以RDB的格式写入到 aof 文件中，将增量数据以指令的方式 append 到 aof 重写的文件开头。</p>
<p><strong>RDB + AOF 仅仅能保证数据尽量的少丢失。</strong></p>
<h2 id="读写分离">读写分离</h2>
<p>Redis 的主从模式，在我看来只能分摊主节点读的压力，并且从节点读取有延迟（不是双写），写入主节点后同步到从节点上去，典型的集中式架构，主节点和从节点通信量就会很大，但是 Redis 支持从节点作为中继节点，向下游的从节点同步数据来分担主节点的压力，只是最下游的从节点延迟更高。</p>
<h3 id="主从同步">主从同步</h3>
<p>Slaveof  ip port 、replicaof（5.0+）需要设置主库密码。<strong>masterauth</strong></p>
<ul>
<li>主从库建立链接、协商同步，为全量复制做准备
<ul>
<li>从库发送 psync 命令，表示要进行数据同步，主库根据这个命令的参数来启动复制</li>
<li>psync 命令包含了主库的 runID 和复制进度 offset 两个参数</li>
<li>Redis 实例启动都会自动生成一个随机 ID 用来标记实例 info server可以看到 runId</li>
<li>首次同步 offset 为 -1</li>
<li>主库收到 psync 命令后，会用 fullresync 响应表示第一次复制采用的全量复制，主库会把当前所有的数据都复制给从库</li>
</ul>
</li>
<li>主库将所有数据同步给从库，从库收到数据后，在本地完成数据加载
<ul>
<li>主库执行 bgsave 生成 RDB 文件，将文件发给从库</li>
<li>从库收到 RDB 文件后，先清空当前数据库，然后加载RDB文件，避免之前存在数据的影响</li>
</ul>
</li>
<li>主库将数据同步给从库的过程中，主库不会被阻塞，仍然可以正常接受请求</li>
<li>为了保证数据的一致性，主库会在内存中用 replication buffer 记录RDB 文件生成后收到的写操作</li>
<li>主库最后把同步过程中的新收到的命令，再发送给从库（replication buffer 中的修改操作），从库重新执行，实现同步</li>
</ul>
<p>主从完成了全量复制后，会一直维护一个网络链接，主库会把之后收到的命令通过这个链接同步给从库，基于长链接的命令传播，避免频繁建立链接的开销。</p>
<h3 id="主从断开增量复制">主从断开增量复制</h3>
<p>主从网络断开后，主从采用<strong>增量复制</strong>的方式继续同步，通过 <strong>repl_backlog_buffer</strong> 环形缓冲区实现，有从节点存在 缓冲区就存在。</p>
<p>主库会把断开期间的写操作命令写入 replication buffer ，同时会把这些操作命令也写入 repl_backlog_buffer 缓冲区，real_backlog_buffer ，主库会记录写到的位置，从库会记录独到的位置，各自对应的偏移量为 <strong>master_repl_offset</strong>，<strong>slave_repl_offset</strong> ，正常情况下，这两个便宜量基本相等。</p>
<p>replication buffer 在主从增量同步时分配的 buffer，专门用来传播用户的写命令到从苦，保证主从一致，client-output-buffer-limit 可以限制 buffer 大小，超过限制，大概率是从库处理的非常慢，主库会强制断开这个链接，主从复制被中断，如果从库再次发起复制请求，可能会因此恶行循环。</p>
<p>client-output-buffer-limit normal 0 0 0
client-output-buffer-limit replica 256mb 64mb 60
client-output-buffer-limit pubsub 32mb 8mb 60</p>
<p><strong>恢复链接</strong>后，从库会先给主库发送 psync 命令，把自己当前的 slave_repl_offset 发给主库，主库判断自己的 master_repl_offset 和 slave_repl_offset 之间的差距，主库会收到新的写操作命令也就是   master_repl_offset 和 slave_repl_offset 之间的命令操作同步给从库就行。</p>
<p>由于是环形缓冲区，<strong>从库写入太慢，就会导致从库未读的数据被覆盖，最终数据不一致</strong>，<strong>从节点断开时间太长导致数据被覆盖会进行全量复制</strong>。</p>
<p>看情况调整 <strong>repl_backlog_size</strong> 缓冲区的大小，同时要考虑一些突发的请求压力场景来降低增量复制中数据不一致的风险。</p>
<h3 id="repl-diskless-sync">repl-diskless-sync</h3>
<p>复制同步策略，disk/diskless</p>
<ul>
<li>DUMP RDB 到硬盘，在读到内存，在发送给slave</li>
<li>Socket 传输到从节点的进程中</li>
</ul>
<p>repl-diskless-sync-delay  配置等待时间，让更多的从节点到达，减少主节点阻塞时间。</p>
<blockquote>
<p><a href="https://redis.io/topics/replication">https://redis.io/topics/replication</a></p>
</blockquote>
]]></content>
        </item>
        
        <item>
            <title>Class load</title>
            <link>https://liguangchang.cn/posts/java/class-load/</link>
            <pubDate>Sun, 12 Dec 2021 13:07:55 +0800</pubDate>
            
            <guid>https://liguangchang.cn/posts/java/class-load/</guid>
            <description>Class load jvm 装载 class 分为 加载 -&amp;gt; 连接（验证-&amp;gt;准备-&amp;gt;解析）-&amp;gt; 初始化。 condition Class 文件只有在必须要使用的时候才会被装载，NoClassDe</description>
            <content type="html"><![CDATA[<h2 id="class-load">Class load</h2>
<p>jvm 装载 class 分为 加载 -&gt; 连接（验证-&gt;准备-&gt;解析）-&gt; <strong>初始化</strong>。</p>
<h3 id="condition">condition</h3>
<p>Class 文件只有在必须要使用的时候才会被装载，NoClassDefFoundError 不会在编译的时候出现。</p>
<p>Jvm 规定，一个类或接口在<strong>初次主动使用</strong>前，必须进行初始化。</p>
<p>主动使用</p>
<ul>
<li>创建类实例，new/reflect/clone/deserialize</li>
<li>调用类的静态方法，字节码的 invokestatic 指令</li>
<li>使用类或接口的静态字段（final 常量除外）</li>
<li>reflect 反射类的方法</li>
<li>初始化子类</li>
<li>启动 jvm 的main 方法所在类</li>
</ul>
<p>其他情况属于被动使用，不会引起类的初始化，都会进行加载、连接。</p>
<ul>
<li>通过子类访问父类的 static 域，只会初始化父类 -XX:+TraceClassLoading 参数可以看到 Loaded 日志</li>
<li>访问 final 常量 ，常量被放在常量池中，编译时将常量直接植入目标类，不实用被引用的类。</li>
</ul>
<h3 id="load">load</h3>
<p>加载类时，jvm 必须完成的工作</p>
<ul>
<li>通过类全名获取类的二进制数据流</li>
<li>解析类的二进制数据流为方法区内的数据结构</li>
<li>创建 java.lang.Class 类的实例，表示该类型（元数据）</li>
</ul>
<h3 id="verify">verify</h3>
<p>连接-验证：保证加载的字节码合法、合理符合规范。</p>
<ul>
<li>格式检查
<ul>
<li>魔数检查</li>
<li>版本检查</li>
<li>长度检查</li>
</ul>
</li>
<li>语义检查
<ul>
<li>是否继承 final</li>
<li>是否有 super class</li>
<li>是否实现 abstract method</li>
</ul>
</li>
<li>字节码验证
<ul>
<li>跳转指令是否指向正确位置</li>
<li>操作数类型是否合理</li>
</ul>
</li>
</ul>
<p>前面三次检查，可以排除文件格式错误、语义错误及字节码的不正确，依然不能保证类是没问题的。</p>
<ul>
<li>符号引用验证
<ul>
<li>符号引用的直接引用是否存在</li>
<li>Class 文件在常量池会通过字符串记录自己将要使用的其他类或者方法，这个时候校验器会检查这些类或者方法是否确实存在，并且确定当前类有权限访问这些数据。如果一个需要使用的类无法在系统中找到，会抛出 NoClassDefFoundError，如果一个方法无法在系统中找到，会抛出 NoSuchMethodError。</li>
</ul>
</li>
</ul>
<h3 id="prepare">prepare</h3>
<p>当类验证通过，虚拟机就会进入准备阶段，虚拟机为类分配响应的内存空间，设置初始值。</p>
<p><strong>如果存在常量字段，常量字段也会在准备阶段被赋上正确的值，赋值行为属于虚拟机行为，属于变量的初始化，准备阶段不会有任何 Java 代码被执行。</strong></p>
<h3 id="parse">parse</h3>
<p>解析阶段将类、接口、字段和方法的<strong>符号引用转为直接引用</strong>，<strong>得到类或者字段、方法在内存中的指针偏移或者偏移量</strong>。如果直接引用存在，可以肯定系统中存在该类、方法或者字段，只有符号引用存在，不能确定系统中一定存在该对象。</p>
<p>符号引用就是一些字面量的引用（常量池），和虚拟机的内部数据结构与内存布局无关。</p>
<p>解析字节码，找到常量池中的符号引用，在通过类的方法表，通过偏移量找到方法，完成转换，调用方法成功。</p>
<h3 id="constant_string">CONSTANT_string</h3>
<p>Java 代码中直接使用字符串常量时，会在类中出现 CONSTANT_String，表示字符串常量，会引用一个 CONSTANT_UTF8 常量项。</p>
<p>虚拟机内部运行时的常量池中，会维护一张字符串拘留表（intern），会保存所有出现过的字符串常量，没有重复项。</p>
<p>使用 String.intern() 可以得到一个字符串在拘留表中的引用，</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>        String a <span style="color:#f92672">=</span> Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">toString</span><span style="color:#f92672">(</span>1<span style="color:#f92672">)</span> <span style="color:#f92672">+</span> Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">toString</span><span style="color:#f92672">(</span>2<span style="color:#f92672">)</span> <span style="color:#f92672">+</span> Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">toString</span><span style="color:#f92672">(</span>3<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        String b <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;123&#34;</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>a<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>b<span style="color:#f92672">));</span> <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>a<span style="color:#f92672">==</span>b<span style="color:#f92672">);</span> <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>a<span style="color:#f92672">.</span><span style="color:#a6e22e">intern</span><span style="color:#f92672">()==</span>b<span style="color:#f92672">);</span> <span style="color:#66d9ef">true</span>
</span></span></code></pre></div><h3 id="init">init</h3>
<p>前面的步骤都没有问题，类就可以顺利装载到系统中，这个时候才开始执行 Java 字节码。</p>
<p><strong>初始化最重要的工作时执行类的初始化方法  clinit，方法  clinit 是由编译器自动生成的，是由静态成员的赋值语句及 static 语句快共同产生的</strong>。</p>
<p>存在继承的类，父类的 clint 方法总是在子类的 clint 方法之前被调用，并且虚拟机内部保证多线程环境安全（锁），但是还是有可能会出现死锁。</p>
<p>如果类没有 static 赋值语句或者静态代码块，编译器就不会生成 clint 方法，static final 赋值在准备阶段完成。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">StaticA</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">sleep</span><span style="color:#f92672">(</span>1000<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span><span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>Exception e<span style="color:#f92672">){</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            Class<span style="color:#f92672">.</span><span style="color:#a6e22e">forName</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;dev.spider.jvm.clint.StaticB&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span><span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>Exception e<span style="color:#f92672">){</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;StaticB init OK&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">StaticB</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">sleep</span><span style="color:#f92672">(</span>1000<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span><span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>Exception e<span style="color:#f92672">){</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            Class<span style="color:#f92672">.</span><span style="color:#a6e22e">forName</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;dev.spider.jvm.clint.StaticA&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span><span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>Exception e<span style="color:#f92672">){</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;StaticB init OK&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">StaticDeadLockMain</span> <span style="color:#66d9ef">extends</span> Thread<span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">char</span> flag<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">StaticDeadLockMain</span><span style="color:#f92672">(</span><span style="color:#66d9ef">char</span> flag<span style="color:#f92672">){</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">flag</span><span style="color:#f92672">=</span>flag<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">setName</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Thread&#34;</span><span style="color:#f92672">+</span>flag<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            Class<span style="color:#f92672">.</span><span style="color:#a6e22e">forName</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;dev.spider.jvm.clint.Static&#34;</span><span style="color:#f92672">+</span>flag<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span><span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>Exception e<span style="color:#f92672">){</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>getName<span style="color:#f92672">()+</span><span style="color:#e6db74">&#34; over&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ClintDeadLock</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        StaticDeadLockMain loadA <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> StaticDeadLockMain<span style="color:#f92672">(</span><span style="color:#e6db74">&#39;A&#39;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        loadA<span style="color:#f92672">.</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        StaticDeadLockMain loadB <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> StaticDeadLockMain<span style="color:#f92672">(</span><span style="color:#e6db74">&#39;B&#39;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        loadB<span style="color:#f92672">.</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><h2 id="classloader">ClassLoader</h2>
<p>Classloader 在 Class 装载的加载阶段，从系统外部获得 Class 二进制数据流。</p>
]]></content>
        </item>
        
        <item>
            <title>Class</title>
            <link>https://liguangchang.cn/posts/java/class/</link>
            <pubDate>Sun, 12 Dec 2021 10:21:27 +0800</pubDate>
            
            <guid>https://liguangchang.cn/posts/java/class/</guid>
            <description>Jvm 的跨平台可以让一份 Class 文件运行在不通的平台上，Class 作为异构语言和 JVM 之间的重要桥梁，可以由源代码被编译成 Class 文件，并最终在 JVM 上执行，Clo</description>
            <content type="html"><![CDATA[<p>Jvm 的跨平台可以让一份 Class 文件运行在不通的平台上，Class 作为异构语言和 JVM 之间的重要桥梁，可以由源代码被编译成 Class 文件，并最终在 JVM 上执行，Clojure、Groovy、Scala、Jython等语言都可以活跃在 JVM 平台上。</p>
<h2 id="class-file">Class File</h2>
<ul>
<li>类的属性</li>
<li>类的方法
<ul>
<li>访问标记</li>
<li>名称</li>
<li>描述符</li>
<li>属性
<ul>
<li>行号属性</li>
<li>局部变量表</li>
<li>栈映射帧</li>
</ul>
</li>
</ul>
</li>
<li>类的字段
<ul>
<li>访问标记</li>
<li>名称</li>
<li>描述符</li>
<li>属性</li>
</ul>
</li>
<li>实现的接口</li>
<li>父类</li>
<li>magic number  Class 文件的特征</li>
<li>小版本号</li>
<li>大版本号</li>
<li>常量池
<ul>
<li>各种常量</li>
<li>整数</li>
<li>字符串</li>
<li>Class</li>
</ul>
</li>
<li>访问标记
<ul>
<li>public</li>
<li>static</li>
</ul>
</li>
<li>当前类</li>
</ul>
<p>虚拟机规范中，Class 文件使用一种类似于 C 语言结构体的方式描述，统一使用无符号整数作为基本数据类型，u1、u2、u3、u4、u8 分别表示无符号的单字节、2字节、4字节、8字节整数，字符串用 u1 数组表示。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ClassFile<span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>	u4 magic<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>	u2 minor_version<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>	u2 major_version<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>	u2 constant_pool_count<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>	cp_info constant_pool<span style="color:#f92672">[</span>constant_pool_count<span style="color:#f92672">-</span>1<span style="color:#f92672">];</span>
</span></span><span style="display:flex;"><span>	u2 access_flags<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>	u2 this_class<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>	u2 super_class<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>	u2 interfaces_count<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>	u2 interfaces<span style="color:#f92672">[</span>interfaces_count<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>	u2 fields_count<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>	field_info fields<span style="color:#f92672">[</span>fields_count<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>	u2 methods_count<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>	method_info methods<span style="color:#f92672">[</span>methods_count<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>	u2 attributes_count<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>	attribute_info attributes<span style="color:#f92672">[</span>attributes_count<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><h3 id="magic-number">Magic Number</h3>
<p>魔数作为 Class 文件的标志，告诉虚拟机这个是 Class 文件，4字节无符号整数，固定为 0xCAFEBABE</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Simple</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> TYPE <span style="color:#f92672">=</span> 1<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> id<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> String name<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setId</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> id<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">id</span> <span style="color:#f92672">=</span> id<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>IllegalStateException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>e<span style="color:#f92672">.</span><span style="color:#a6e22e">toString</span><span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> String <span style="color:#a6e22e">getName</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> name<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setName</span><span style="color:#f92672">(</span>String name<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> name<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>hexdump 查看 class</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#ae81ff">0000000</span> ca fe ba be <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span> 3d <span style="color:#ae81ff">00</span> 2f 0a <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">02</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">03</span> <span style="color:#ae81ff">07</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0000010</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">04</span> 0c <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">05</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">06</span> <span style="color:#ae81ff">01</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">10</span> 6a <span style="color:#ae81ff">61</span> <span style="color:#ae81ff">76</span> <span style="color:#ae81ff">61</span> 2f 6c
</span></span><span style="display:flex;"><span>......
</span></span></code></pre></div><h3 id="version">Version</h3>
<p>魔数后面跟着 小版本号和大版本号（都是2字节）</p>
<p>十进制转换十六进制</p>
<p><strong>echo &ldquo;obase=16; 52&rdquo; | bc</strong></p>
<p><strong>printf &lsquo;%x\n&rsquo; 52</strong></p>
<table>
<thead>
<tr>
<th>小版本</th>
<th>大版本</th>
<th>编译器版本</th>
</tr>
</thead>
<tbody>
<tr>
<td>3</td>
<td>45</td>
<td>1.1</td>
</tr>
<tr>
<td>0</td>
<td>46</td>
<td>1.2</td>
</tr>
<tr>
<td>0</td>
<td>47</td>
<td>1.3</td>
</tr>
<tr>
<td>0</td>
<td>48</td>
<td>1.4</td>
</tr>
<tr>
<td>0</td>
<td>49</td>
<td>1.5</td>
</tr>
<tr>
<td>0</td>
<td>50 0x32</td>
<td>1.6</td>
</tr>
<tr>
<td>0</td>
<td>51 0x33</td>
<td>1.7</td>
</tr>
<tr>
<td>0</td>
<td>52 0x34</td>
<td>1.8</td>
</tr>
<tr>
<td>0</td>
<td>53 0x35</td>
<td>1.9</td>
</tr>
<tr>
<td>0</td>
<td>54 0x36</td>
<td>10</td>
</tr>
<tr>
<td>0</td>
<td>55 0x37</td>
<td>11</td>
</tr>
<tr>
<td>0</td>
<td>56 0x38</td>
<td>12</td>
</tr>
<tr>
<td>0</td>
<td>57 0x39</td>
<td>13</td>
</tr>
<tr>
<td>0</td>
<td>58 0x3a</td>
<td>14</td>
</tr>
<tr>
<td>0</td>
<td>59 0x3b</td>
<td>15</td>
</tr>
<tr>
<td>0</td>
<td>60 0x3c</td>
<td>16</td>
</tr>
<tr>
<td>0</td>
<td>61 0x3d</td>
<td>17</td>
</tr>
</tbody>
</table>
<p>Java -target 可以使用指定版本的发行版编译器进行编译。</p>
<h3 id="constant_pool">constant_pool</h3>
<p>版本号后面跟着的是常量池的数量和若干个常量池表项，</p>
<p><code>常量池 0 为空缺页，不存放实际内容，常量池的每一项以类型、长度、内容或者类型、内容的格式依次排列。</code></p>
]]></content>
        </item>
        
        <item>
            <title>Java-KeyWord</title>
            <link>https://liguangchang.cn/posts/java/java-keyword/</link>
            <pubDate>Sun, 12 Dec 2021 09:37:51 +0800</pubDate>
            
            <guid>https://liguangchang.cn/posts/java/java-keyword/</guid>
            <description>final 关键字可以用在 类、方法、参数上面，来告知编译器一块数据是恒等不变的。 final 让基本数据类型数值恒定不变，引用对象(包括数组)引用恒定不变。 被 static final</description>
            <content type="html"><![CDATA[<p>final 关键字可以用在 类、方法、参数上面，来告知编译器一块数据是恒等不变的。</p>
<p>final 让基本数据类型数值恒定不变，引用对象(包括数组)引用恒定不变。</p>
<p>被 static final 修饰的域只占据一段不能改变的存储空间，只有 final 修饰的域只在有效的生命周期内不变。</p>
<h2 id="blank-final">blank final</h2>
<p>编译器会保证 final 修饰的域在使用前必须被初始化，blank final 提供了更大的灵活性。</p>
<p>如果只是 final 修饰符 ，所有的 【构造函数】 都要进行初始化，static final 需要直接初始化或者在静态代码块里面初始化。</p>
<h2 id="final-param">final param</h2>
<p>方法参数列表中将参数用 final  修饰，约束方法内的代码块不能更改参数引用/数值，只能读取，引用对象可以修改引用内的数据。</p>
<h2 id="final-method">final method</h2>
<ul>
<li>锁定方法，防止任何继承类修改，约束方法行为</li>
<li>早期编译器 inline 优化，消除方法调用寄存器、栈开销。</li>
<li>private method 默认 final 修饰，无意义。</li>
</ul>
<h2 id="final-class">final class</h2>
<p>Final 类 禁止继承，所有方法都隐式指定为 final。</p>
<h2 id="oriented-future">Oriented future</h2>
<p>不用 final 修饰类，方便后面进行拓展和改造，eg Vector、HashTable。</p>
<h2 id="static">static</h2>
<p>所有 static 对象和代码块都会在加载时按照程序中的顺序加载进行初始化。</p>
<p>static 方法不能访问非 static 修饰的方法（静态对象的引用，可以传入静态方法中，但是一般这个时候对象的状态都是各自类型的零值，当然可以继续修改引用）。</p>
]]></content>
        </item>
        
        <item>
            <title>Elasticsearch 生态，安装</title>
            <link>https://liguangchang.cn/posts/es/es-install/</link>
            <pubDate>Mon, 29 Nov 2021 22:25:44 +0800</pubDate>
            
            <guid>https://liguangchang.cn/posts/es/es-install/</guid>
            <description>Elasticsearch 7.15.2 安装。 Lucene 基于 Java 语言开发的搜索引擎类库 创建于1999年，2005 年成为 Apache 顶级开源项目 高性能、易拓展 局限性 只能基于 Java 语言开发 类库的接口学习曲</description>
            <content type="html"><![CDATA[<p>Elasticsearch 7.15.2 安装。</p>
<h2 id="lucene">Lucene</h2>
<ul>
<li>基于 Java 语言开发的搜索引擎类库</li>
<li>创建于1999年，2005 年成为 Apache 顶级开源项目</li>
<li>高性能、易拓展</li>
<li>局限性
<ul>
<li>只能基于 Java 语言开发</li>
<li>类库的接口学习曲线陡峭</li>
<li>原生并不支持水平拓展</li>
</ul>
</li>
</ul>
<h2 id="elasticsearch">Elasticsearch</h2>
<ul>
<li>2004 年 Shay Bacon 基于 Lucene 开发了 Compass</li>
<li>2010 年 重写 Compass，取名 Elasticsearch
<ul>
<li>支持分布式，可水平拓展</li>
<li>降低全文检索的学习曲线，可以被任何编程语言调用 <a href="https://www.elastic.co/guide/en/elasticsearch/client/index.html">https://www.elastic.co/guide/en/elasticsearch/client/index.html</a></li>
<li>RESTful ，JDBC &amp; ODBC</li>
</ul>
</li>
<li>海量数据的分户式存储以及集群管理
<ul>
<li>服务与数据的高可用，水平拓展</li>
</ul>
</li>
<li>近实时搜索，性能卓越
<ul>
<li>结构化/全文/地址位置/自动完成</li>
</ul>
</li>
<li>海量数据的近实时分析
<ul>
<li>聚合功能</li>
</ul>
</li>
</ul>
<h2 id="version-and-feat">version and feat</h2>
<ul>
<li>0.4 2010.2</li>
<li>1.0 2014.1</li>
<li>2.0 2015.10</li>
<li>5.0 2016.10
<ul>
<li>Lucenn 6.x，性能提升，移除同一文档并发更新的竞争锁</li>
<li>Instant aggregation ，支持分片上聚合的缓存</li>
<li>新增了 Profile API</li>
</ul>
</li>
<li>6.0 2017.10
<ul>
<li>Lucenn 7.x</li>
<li>跨集群复制 CCR、索引生命周期管理、SQL 支持</li>
<li>更友好快速的版本升级和数据迁移</li>
<li>有效存储稀疏字段的新方法，降低了存储成本</li>
<li>在索引时进行排序，可加快排序的查询性能</li>
</ul>
</li>
<li>7.0 2019.4
<ul>
<li>Lucene 8.0</li>
<li>正式废除单个索引下多 Type 的支持</li>
<li>7.1 开始 Security 功能免费使用</li>
<li>ECK Elasticsearch Operator on Kubernetes</li>
<li>New Cluster coordination</li>
<li>Feature-Complete High Level REST Client</li>
<li>Script Score Query</li>
<li>默认的 Primary Shard 数从 5 改为 1，避免 Over Sharding</li>
<li>更快的 Top K</li>
</ul>
</li>
</ul>
<h2 id="ecosphere">Ecosphere</h2>
<p>解决方案 <code>搜索</code> <code>日志分析</code> <code>指标分析</code> <code>安全分析</code></p>
<ul>
<li>开源
<ul>
<li>可视化 Kibana</li>
<li>存储计算 Elasticsearch</li>
<li>数据抓取 Logstash Beat</li>
</ul>
</li>
<li>商业
<ul>
<li>X-Pack  <code>安全</code> <code>告警</code> <code>监控</code> <code>图查询</code> <code>机器学习</code></li>
</ul>
</li>
</ul>
<h2 id="logstash">Logstash</h2>
<p><code>数据处理管道</code>，诞生于 2009，2013 年被 Elasticserach 收购。</p>
<p>最初用来做日志的采集与处理，服务端数据处理通道，支持从不同来源采集数据，转换数据，并将数据发送到不同的存储库中。</p>
<h3 id="feat">Feat</h3>
<ul>
<li>实时解析和转换数据
<ul>
<li>将 IP 地址破译出地理坐标</li>
<li>将 PII 数据匿名化，完全排除敏感字段</li>
</ul>
</li>
<li>可拓展
<ul>
<li>200 多插件 （日志/数据库/Arcsigh/Netflow）</li>
</ul>
</li>
<li>可靠性安全性
<ul>
<li>Logstash 会通过持久化队列来保证至少将运行中的事件送达一次</li>
<li>数据传输加密</li>
</ul>
</li>
<li>监控</li>
</ul>
<h2 id="kibana">kibana</h2>
<p><code>Kiwifruit + Bannan</code></p>
<p>基于 Logstash 的工具，2013 免费被 Elasticsearch 收购。</p>
<h2 id="beats">BEATS</h2>
<p>轻量的数据采集器，GO语言开发。</p>
<ul>
<li>FileBeat         	Real-time insight into log data</li>
<li>Packetbeat       Analyze network packet data</li>
<li>Winlogbeat      Analyze Windows event logs</li>
<li>Mericbeat        Ship and analyze metrics</li>
<li>Heartbeat        Ping your infrastructure</li>
<li>Auditbeat        Send audit data to Elasticsearch</li>
<li>Functionbeat  Ship cloud data with serveless infrastructure</li>
<li>Journalbeat     Analyze journals logs</li>
</ul>
<h2 id="elk--apply">ELK  APPLY</h2>
<ul>
<li>网站搜索/垂直搜索/代码搜索</li>
<li>日志管理与分析/安全指标监控/应用性能监控/WEB抓取舆情分</li>
<li>日志搜集 -&gt; 格式化分析 -&gt; 全文检索 -&gt; 风险告警</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/05/tCAosHfj4Vurc6X.png" alt="elk"></p>
<h2 id="directory-structure">directory structure</h2>
<ul>
<li>bin			脚本文件（启停/插件/统计）</li>
<li>config      elastic search.yml 集群配置文件，user、role based 相关配置</li>
<li>JDK           7.x 内置 java 环境</li>
<li>data         path.data 数据文件</li>
<li>lib             java 类库</li>
<li>logs          path.log 日志文件</li>
<li>modules  所有模块</li>
<li>plugins     已安装插件</li>
</ul>
<h2 id="jvm-opts">JVM OPTS</h2>
<p><code>config/jvm.options</code></p>
<p>7.1 默认设置 1GB</p>
<p>Xmx 不要超过机器内存的 50 %，内存不要超过 30G</p>
<p><a href="https://www.elastic.co/cn/blog/a-heap-of-trouble">https://www.elastic.co/cn/blog/a-heap-of-trouble</a></p>
<ul>
<li>Jvm.options -Xms = -Xmx =2g</li>
<li>Elastic search.yml
<ul>
<li>node.name</li>
<li>discovery.seed_hosts, discovery.seed_providers, cluster.initial_master_nodes 其中一个指定为 node.name</li>
<li>network.host: 0.0.0.0</li>
</ul>
</li>
<li>/etc/sysctl.conf
<ul>
<li>vm.max_map_count 调大 655360</li>
<li>sysctl -p</li>
</ul>
</li>
</ul>
<h2 id="cli">CLI</h2>
<ul>
<li>bin/elasticsearch-plugin list</li>
<li>bin/elasticsearch-plugin install analysis-icu 装完插件重启生效</li>
</ul>
<h2 id="restful">RESTful</h2>
<ol>
<li>_cat/plugin</li>
<li>_cat/nodes</li>
</ol>
<h2 id="q">Q</h2>
<ul>
<li>ssh abrt  timeout</li>
</ul>
<h2 id="feat-1">Feat</h2>
<h2 id="查看外网ip">查看外网ip</h2>
<ul>
<li><em>curl cip.cc</em></li>
<li><em>curl myip.ipip.net</em></li>
<li>curl ip.sb</li>
<li>curl inet-ip.info</li>
<li>curl ipinfo.io (json)</li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>Reference Counting</title>
            <link>https://liguangchang.cn/posts/gc/reference_counting/</link>
            <pubDate>Tue, 16 Nov 2021 21:53:06 +0800</pubDate>
            
            <guid>https://liguangchang.cn/posts/gc/reference_counting/</guid>
            <description>GC本来就是一种释放怎么都无法被引用的对象的机制，1960 年George E·Collins 提出。 count 计数器是无符号的整数，用于计数的位数根据算</description>
            <content type="html"><![CDATA[<p>GC本来就是一种释放怎么都无法被引用的对象的机制，1960 年George E·Collins 提出。</p>
<h2 id="count">count</h2>
<p>计数器是无符号的整数，用于计数的位数根据算法和实现有所不同，在mutator 的处理过程中通过增减计数器的值来进行内存管理。</p>
<p><strong>引用计数法中，除了链接到空闲链表的对象，其他所有对象都是活动对象。</strong></p>
<pre tabindex="0"><code>[ 计数器 |   域   ]
</code></pre><h2 id="newobj">newObj</h2>
<p>生成新对象，分配到合适的分块后，如果对象被某处引用了，把计数器的值定为1。</p>
<h2 id="updateobj">updateObj</h2>
<p>更新指针指向，会进行计数器值的增减。</p>
<ul>
<li>先对指针新引用对象的计数器进行增量操作</li>
<li>再对指针之前引用的对象的计数器进行减量操作，之后会变成垃圾链接到空闲链表，并遍历其子对象进行减量操作</li>
</ul>
<p><strong>先增后减的步骤，为了避免更新的引用是同一个对象，先减可能会使得对象被回收。</strong></p>
<p>引用计数算法会立刻回收垃圾，在分配没有分块的情况下，堆中所有的对象都为活动对象，就没办法进行分配对象，而标记清除算法会在没有合适分块的时候一块清除。</p>
<h2 id="advantage">advantage</h2>
<ul>
<li>
<p><strong>可即刻回收</strong></p>
<p>对象始终知道自己的引用计数，被引用数的值为0时，对象马上就把自己作为空闲空间连接到空闲链表，堆空间中不会有垃圾占用。</p>
</li>
<li>
<p><strong>STW 短</strong></p>
<p>引用计数只有当通过 mutator 更新指针时程序才会执行垃圾回收，每次通过执行 mutator 生成垃圾时都会被回收，大幅度消减了 mutator 的最大暂停时间。</p>
<p><strong>相当于标记清除，对 mutator 来说是两步合一步。</strong></p>
</li>
<li>
<p><strong>没有必要沿指针查找</strong></p>
<p>不用关心对象间的相互引用来判别是否存活</p>
</li>
</ul>
<h3 id="q">Q</h3>
<ol>
<li>立即回收是怎么做到的，trigger 还是 callBack</li>
<li>立即回收可能会存在 race</li>
</ol>
<h2 id="deficiency">deficiency</h2>
<ul>
<li>
<p><strong>计数器值的增减处理繁重，特别是有根的指针，eg:栈空间递归</strong></p>
</li>
<li>
<p><strong>计数器本身占位</strong></p>
<p>根据计算机的位不同，内存能够 load 的对象越多，计数器的最大值就越大，各种引用的增加都需要计数器的位足够大。</p>
</li>
<li>
<p><strong>实现繁琐</strong></p>
<p>书上说，更新对象的引用，要将以往 直接引用的改成两步增减操作，重写容易出现遗漏，产生bug</p>
<p><strong>没看太懂，在我看来 GC 作为 语言处理程序，应该是类似 MySQL 引擎一样的插件形式工作。</strong></p>
</li>
<li>
<p><strong>循环引用无法回收</strong></p>
<p>两个及两个以上的对象互相循环引用形成对象组的情况，即使对象没有被真正的引用，GC程序无法将其回收。</p>
</li>
</ul>
<h2 id="deferred-reference-counting">Deferred Reference Counting</h2>
<p>从根的变化引用变化频繁，会导致计数器值的增减处理繁重，比如 递归、全局变量、循环</p>
<p>既然繁重，L·Peter Deutsh 和 Daniel G· BoBrow  就放弃了<strong>从根引用的指针更新引用维护计数器的操作</strong>。</p>
<p><strong>引用的更新没有反映到计数器上，可能会被误判当成垃圾回收</strong>（这个延迟不是全局的，只是从根引用的对象）。</p>
<h2 id="zct">ZCT</h2>
<p>Zero Count Table，通过一个表，记录计数器变成 0 的对象，这些对象都是从根出发引用的，计数器值为零，但是不一定都是垃圾，通过ZCT 保留。</p>
<h2 id="newobj-1">newObj</h2>
<p>分配时，如果无法从空闲链表分配到合适的分块，就先搜索一遍 ZCT，再次分配，如果不行分配失败。</p>
<h2 id="scan_zct">scan_zct</h2>
<ol>
<li><strong>无法分配 / ZCT 占满，搜索ZCT</strong>，会把所有通过根直接引用的对象的计数器都进行增量，把根引用反应到计数器数值上。</li>
<li><strong>调查与 ZCT 相连的对象，如果存在计数器为 0 的对象，则将此对象从 ZCT 删除</strong>
<ol>
<li><strong>对该对象的子对象的计数器进行减量操作</strong></li>
<li><strong>回收该对象，连接到空闲链表</strong></li>
</ol>
</li>
</ol>
<h3 id="q-1">Q</h3>
<p>满足从 ZCT 删除对象的计数器变化</p>
<ol>
<li>计数器减到 0 加入 ZCT</li>
<li>首次无法分配，扫描 ZCT ，这个时候 ZCT 上对象的计数器都是 0。</li>
<li>扫描 ZCT 先循环一遍，将所有的对象计数器 + 1，现在等于 1。</li>
<li>再次循环，调查每一个对象，如果存在计数器值为 0，将其删除。</li>
<li>最后循环将对象的引用子对象计数 -1，将该对象链接到空闲链表。</li>
</ol>
<p>第四步删除，是因为该对象真正的没有被引用，也就是有一部分计数器增加操作被忽略，使得计数器置为0 被提前。</p>
<p>在扫描的过程中，在第一次循环计数器 + 1，和第二次循环遍历到该对象的时间节点中，至少有一个引用该对象的对象引用被修改或者被回收。</p>
<p>。。。</p>
<p>从根出发的对象，只有 全局变量空间、栈、寄存器，唯一合理的解释就是，在这一段时间内 栈弹出/执行结束，并且后面没有被传递下去，该对象不属于从根引用的对象。</p>
<p>抛开编译器的编译器、运行期优化，代码的质量是会影响对象分配的，另外 <strong>ZCT 的大小直接影响遍历的效率，减小 ZCT 的大小，ZCT 的扫描操作会变得频繁，进而又会降低吞吐量</strong>，显然一个长时间的循环/递归，维护计数器的压力是巨大的。</p>
<p>延迟计数器的增减，垃圾不能马上回收，垃圾就会压迫堆内存空间，这个 trade off 让我难受的窒息。</p>
<h2 id="sticky">Sticky</h2>
]]></content>
        </item>
        
        <item>
            <title>Mark Sweep GC</title>
            <link>https://liguangchang.cn/posts/gc/mark_sweep/</link>
            <pubDate>Mon, 15 Nov 2021 23:10:47 +0800</pubDate>
            
            <guid>https://liguangchang.cn/posts/gc/mark_sweep/</guid>
            <description>标记清楚算法由标记阶段和清除阶段 标记阶段把所有活动对象打上标记 清除阶段把没有标记的对象回收 mark phase 首先标记根直接引用的对象（在内存中存活的对象）</description>
            <content type="html"><![CDATA[<p>标记清楚算法由标记阶段和清除阶段</p>
<ul>
<li>标记阶段把所有活动对象打上标记</li>
<li>清除阶段把没有标记的对象回收</li>
</ul>
<h2 id="mark-phase">mark phase</h2>
<ol>
<li>首先标记根直接引用的对象（在内存中存活的对象）</li>
<li>递归地标记记通过指针数组能访问到的对象，避免重复标记</li>
</ol>
<p>标记未完成，会对活动对象的头部进行置位操作，这个位分配在对象的头中，能够通过对象访问，标识对象是否已经标记。</p>
<p>标记话费时间和内存中活动对象总数成正比，过程就是从根遍历打标记。</p>
<h2 id="dfs-bfs">DFS BFS</h2>
<p>搜索对象并进行标记时使用 DFS/BFS，搜索的步数不会有差别，内存使用量上DFS 更能压低内存使用量，在树变高的情况更明显</p>
<p>？ 这块是局部性导致的吗 ？</p>
<h2 id="sweep-phase">sweep phase</h2>
<p>清除阶段，会遍历整个堆，回收没有打上标记的对象。</p>
<p>对象头上的 size 域，标识对象存储信息。</p>
<ul>
<li><strong>清除从堆的首地址开始，按照顺序遍历一个个对象的标志位，设置了标志位，表明对象时活动对象，取消标志位，准备下一次GC，下一次GC，会先在标记一次，再来清除</strong>。</li>
<li>回收对象就是<strong>把对象作为分块，连接到被称为空闲链表的单向链表的头</strong>，之后分配通过遍历链表进行。</li>
<li>回收修改了当前对象的 next 域，连接单向链表，对象已死，重写域没有问题。</li>
</ul>
<p>同样，堆越大，清除阶段耗时越久。</p>
<h2 id="allocation">allocation</h2>
<p>分配：mutator 申请分块时，搜索空闲链表寻找大小合适的分块，分配给 mutator。</p>
<h3 id="first-fit">First-fit</h3>
<ul>
<li>找到相同的分块大小直接返回</li>
<li>找到大的分块会将其分割，剩余分块返回空闲链表，剩余的分块可能会一直不满足申请分块需求，会一直占用前面的位置</li>
<li>没有找到合适的分块，返回 NULL</li>
</ul>
<h3 id="best-fit">Best-fit</h3>
<p>遍历链表，返回大于等于申请大小的最小分块</p>
<h3 id="worst-fit">Worst-fit</h3>
<p>找到最大分块将其分割，将剩余分块最大化，容易产生大量小分块</p>
<h2 id="coalescing">coalescing</h2>
<p>分配策略可能会产生大量的小分块，如果他们是连续的，就能把所有的小分块连接在一起形成一个大分块，<strong>连接连续分块的操作成为合并，合并在清除阶段进行</strong>。</p>
<h2 id="advantage">advantage</h2>
<ul>
<li>实现简单，与其他算法组合也相应简单</li>
<li>与保守式GC算法兼容 (对象不能移动)</li>
</ul>
<h2 id="deficiency">deficiency</h2>
<p><strong>fragmentation</strong>：<strong>会逐渐产生被细化的分块，导致无数的小分块散布在堆的各处，增加 mutator 负担（访问时间）</strong>。</p>
<h2 id="allocation-speed">allocation speed</h2>
<p><strong>分块不连续，每次分配都必须遍历空闲链表，找到足够大的分块，最快情况每次都遍历到单向链表到最后。</strong></p>
<h2 id="not-compatible-cow">not-compatible COW</h2>
<p>Copy on write 主要是通过 lazy copy ，多用在共享内存读多写少的场景， 涉及到 MMU、虚拟内存映射、页面调度。</p>
<p>在需要对共享内存空间（read_only）写入时，不直接重写共享内存，避免数据不一致，先复制自己私有空间的数据，对私有空间进行重写。复制后只访问这个私有空间，不访问共享内存，在写入时复制。</p>
<p>mark sweep 两个阶段设置取消标志位，都会重写对象，频繁发生不应该的复制，进而压迫内存空间，为了处理这个问题，采用 bitmap marking 标记，bitmap 对字节的一个bit 通过map 进行映射，只是为了减少 copy 的消耗。</p>
<h2 id="multi-listnode">multi listNode</h2>
<p>单个单向链表存储空闲的分块，大小不同的分块在申请的时候寻找合适的分块比较浪费时间，利用多个空闲链表可以加速合适分块的寻找，但是维护空闲链表数组的数量太大也会压迫到内存空间，并且数组空间是连续的，比较占用堆内存的利用率。</p>
<p>通常会给分块大小设定一个上限，如果大于等于阈值，全部采用一个空闲链表处理，有点有限负载隔离的意思。</p>
<h2 id="bibop">BiBOP</h2>
<p><strong>Big Bag Of Pages</strong> ：<strong>将大小相近的对象整理成固定大小的块进行管理，将堆分割成固定大小的块，每个块只能配置同样大小的对象。</strong></p>
<p>相当于提前分配好存放固定大小块链表的数组，这样使得单个块的利用率得到了提高，一定程度的减少了碎片化，但是堆内存的利用率并不高，必要的时候还需要扩缩容操作。</p>
<h2 id="bitmap-mark">bitmap mark</h2>
<ul>
<li>
<p>标记阶段</p>
<p><strong>收集对象的标志位并表格化，不和对象一起管理</strong>，标记阶段在<strong>位图表格</strong>的映射位置置位，利用 bitmap table 来进行 mark。</p>
<p>其实就是降低 COW lazy write 的开销，COW 的影响还是有的，如果堆内存很大，bitmap 也会被放大。</p>
</li>
<li>
<p>清除阶段</p>
<p>之前清除阶段需要遍历整个堆，把非活动对象链接到空闲链表，同时取消活动对象的标志位。</p>
<p>利用 bitmap，清除遍历堆的同时遍历 bitmap，这个时候，<strong>如果设置了标志位，不会消除bitmap 上的位，放到之后一并进行</strong>。</p>
</li>
<li>
<p>多个堆</p>
<p>存在多个堆的情况，单纯的位运算进行地址映射比较困难，通常构建多个 bitmap table。</p>
</li>
</ul>
<h2 id="lazy-sweep">Lazy Sweep</h2>
<p>Mark Sweep 两个阶段都是遍历全部的堆内对象，堆越大，STW 越长，进一步妨碍 mutator 的处理。</p>
<p>标记阶段是必须进行的，清理阶段大部分不是必须的，满足了当下的分配需求可以在进行清除，通过延迟清除可以减少因为清除操作导致的 mutator 最大暂停时间。</p>
<p><strong>分配时直接调用 lazy_sweep，进行消除操作</strong></p>
<ul>
<li>如果能够通过清除来分配，就返回分块</li>
<li>不能分配，返回 NULL，就执行标记操作，在调用 lazy_sweep 分配，还没分配成功， mutator 就 hang 住 ？？？</li>
</ul>
<p>相当于每次从头全量遍历寻找合适的分块， lazy_sweep 通过全局的遍历偏移来减少遍历的时间，但是单向遍历有可能就刚好错过了，如果可以双向遍历是不是好一点，结合多级的空闲链表数组，其实遍历的 round time 也很小了。</p>
<p>极端情况，活动对象和非活动对象在堆内存中形成了两个相邻的分区，在清除活动对象附近时，会增加 mutator 的一次等待，并且可能会周期性的出现。</p>
<h2 id="q">Q</h2>
<ol>
<li>会不会出现内存抖动，什么是内存抖动，内存抖动会影响什么</li>
<li>能不能像 java TLAB 对对象的分配进行有限的负载控制，让到堆上的对象进行均衡</li>
<li>逃逸的问题</li>
</ol>
]]></content>
        </item>
        
        <item>
            <title>Garbage Collection</title>
            <link>https://liguangchang.cn/posts/gc/garbage_collection/</link>
            <pubDate>Mon, 15 Nov 2021 21:57:17 +0800</pubDate>
            
            <guid>https://liguangchang.cn/posts/gc/garbage_collection/</guid>
            <description>1960年，McCarthy 在其论文中首次发布了GC算法，标记清除算法，Mark Sweep GC。 GC要做的事情 找到内存中的垃圾 回收垃圾，使得内存可以</description>
            <content type="html"><![CDATA[<p>1960年，McCarthy 在其论文中首次发布了GC算法，标记清除算法，Mark Sweep GC。</p>
<p>GC要做的事情</p>
<ul>
<li>找到内存中的垃圾</li>
<li>回收垃圾，使得内存可以再次利用</li>
</ul>
<h2 id="memory-leak">memory leak</h2>
<p>内存空间使用完毕后未释放，会发生内存泄漏，我觉得内存漏泄更合适。</p>
<h2 id="dangling-point">dangling point</h2>
<p>释放完内存空间时，忘记初始化指向释放对象的内存空间的指针，这个指针就会一致指着释放完毕的内存空间，因为这个指针没有指向有效的内存空间，处于一种悬挂的状态，称该指针未悬垂指针，如果程序错误引用悬挂指针，就会产生无法预期的bug。</p>
<h2 id="object">object</h2>
<p>GC里面，对象表示通过APP利用的数据的集合，配置在内存空间里，是GC的基本单元。</p>
<h3 id="head">head</h3>
<p><strong>对象中保存对象本身信息的部分，相当于metadata，主要包含对象的大小、种类。</strong></p>
<p><strong>根据对象的大小和种类，就可以判别内存存储对象的边界，头中事先存有运行GC需要的信息，不同GC算法信息也不同</strong>。</p>
<h3 id="field">Field</h3>
<p>对象使用者在对象中可访问的部分称为域，域中的数据类型大致分为 指针、非指针两种。</p>
<p>GC根据对象中的指针指向去搜寻其他对象，对非指针不进行任何操作，这些都以语言处理程序能够判别指针和非指针未前提进行。</p>
<h2 id="mutator">mutator</h2>
<p>Edsger Dijkstra，1978年提出的，就是应用程序，可以改变GC对象间的引用关系，GC 在 mutator 内部工作。</p>
<p>进行的操作</p>
<ul>
<li>生成对象</li>
<li>更新指针</li>
</ul>
<h2 id="heap">heap</h2>
<p>堆是用于动态存放对象的内存空间，mutator 申请存放对象时，所需的内存空间就会从堆中分配给 mutator，GC是管理堆中已分配对象的机制。</p>
<p>开始执行 mutator 前，GC 要分配用于堆的内存空间，开始执行 mutator，程序就会按照 mutator 的要求在堆中存放对象，堆被对象占满，就会启动GC，从而分配可用空间。</p>
<p><strong>内存空间中能够通过 mutator 引用的对象称为活动对象，分配到堆中的不能通过程序引用的对象称为非活动对象。</strong></p>
<p><strong>死了的对象不可能活过来，mutator 找不到非活动对象，不能重新引用。</strong></p>
<h2 id="allocation">allocation</h2>
<p>分配是指的是在<strong>内存空间中分配对象</strong>，当 mutator 需要新对象时，就会向分配器 allocator 申请一个大小合适的空间，分配器在堆中寻找满足要求的空间，返回给 mutator。</p>
<h2 id="chunk">chunk</h2>
<p>分块是为利用对象而事先准备出来的空间</p>
<p><strong>初始状态下，堆被一个大的分块占据，程序根据 mutator 的要求把分块分成合适的大小，作为活动对象使用，活动对象变成垃圾被回收，占用的空间再次成为分块等待下次被利用，循环往复。</strong></p>
<h2 id="root">root</h2>
<p>根是指向对象的指针起点，能够通过 mutator 直接引用。</p>
<p>全局空间中对象间引用的对象被视为活动的对象，都需要 GC 保护。</p>
<ul>
<li><strong>全局变量空间</strong></li>
<li><strong>调用栈</strong></li>
<li><strong>寄存器</strong></li>
</ul>
<p>这些空间都是根，都可以通过 mutator 直接引用，但是 GC 一般情况下无法严谨判断寄存器和调用栈中的值是否为指针。</p>
<h2 id="evaluation-of-performance">evaluation of performance</h2>
<p>四个指标评价GC性能</p>
<ul>
<li>吞吐量</li>
<li>最大暂停时间 STW</li>
<li>堆使用效率</li>
<li>访问的局部性</li>
</ul>
<h3 id="throughput">throughput</h3>
<p>单位时间的处理能力，不同算法，需要考虑 mutator 的动作/算法机制，活动对象的数量、极端情况都会影响吞吐量。</p>
<h3 id="max-stw">MAX STW</h3>
<p>不同的场景，对最大暂停时间的敏感度不一样，有些时间可以等，有些长时间等待会使得程序被用户关闭，需要根据场景 trade off，选举适合的GC算法。</p>
<h3 id="heap-usage">heap usage</h3>
<p>影响堆使用效率的因素：对象头的大小，堆的用法</p>
<p>对象头的大小直接影响堆中能够存放对象的个数，堆中存放的对象越多，GC的效率就越高，吞吐量也高。</p>
<p>不同算法对堆的使用不同，复制算法中将堆等分，交替使用一般，堆的利用率就不高。</p>
<h3 id="访问的局部性">访问的局部性</h3>
<p>通常会把所有的对象放在内存，CPU 访问数据时，仅把要使用的数据从内存读取到缓存，通过内核、预读、页面调度、调用IO设备调度器。。。会把附近的数据都读到缓存中，来压缩读取时间。</p>
<p>通常具有引用关系的对象之间存在连续访问的情况，<strong>把具有关系的对象安排在堆中较近的位置</strong>，能够提高在缓存中读取到想利用的数据概率，从而令 mutator 高速运行。</p>
<p><strong>复制算法会根据引用关系重排对象</strong></p>
]]></content>
        </item>
        
        <item>
            <title>TCP超时和重传</title>
            <link>https://liguangchang.cn/posts/tcp/tcp-timeout-repeat/</link>
            <pubDate>Thu, 21 Oct 2021 22:32:49 +0800</pubDate>
            
            <guid>https://liguangchang.cn/posts/tcp/tcp-timeout-repeat/</guid>
            <description>TCP 的可靠性，在下层网络(IP) 出现丢失、重复、乱序的时候，会重传认为已经丢失的包。 当数据短或确认消息丢失，TCP启动重传操作，重传尚未确认的</description>
            <content type="html"><![CDATA[<p>TCP 的可靠性，在下层网络(IP) 出现丢失、重复、乱序的时候，会重传认为已经丢失的包。</p>
<p>当数据短或确认消息丢失，TCP启动重传操作，重传尚未确认的包，基于时间、确认消息的两套机制。</p>
<p><strong>每次重传间隔时间加倍称为二进制指数退避（binary exponential backoff</strong></p>
<ul>
<li>
<p><strong>RTO</strong> Retransmission TimeOut，重传超时（计时器超时）</p>
<p>TCP 在发送数据的时候会有一个定时器，若到计时器超时仍未收到数据确认消息，会引发相应的超时或基于计时器的重传操作。</p>
</li>
<li>
<p>快速重传</p>
<p>没有延时的情况，TCP累积确认无法返回新的ACK，或者当ACK包含的选择确认消息(SACK)表明出现失序报文段时，快速重传会推断出现丢包。发送端认为接收端可能出现数据丢失时，需要决定发送新数据还是重传。</p>
</li>
</ul>
<h2 id="r1r2">R1、R2</h2>
<p>TCP拥有两个阈值来决定如果重传同一个报文段【主机需求RFC1122】</p>
<ul>
<li>R1 表示TCP在向IP层传递 【消极建议】(重新评估当前的IP路径) 前愿意尝试重传的次数/等待时间</li>
<li>R2  &gt; R1,指示TCP应放弃当前连接的时机。</li>
</ul>
<p>R1，R2 应分别至少设为三次重传和100秒，对连接的建立过程(发送SYN报文段)，阈值设置与数据段传输有所区别，针对SYN报文段的R2应最少设置3分钟。</p>
<p>Linux 中，R1,R2 可以通过应用程序、系统配置变量设置</p>
<ul>
<li>net.ipv4.tcp_retries1 net.ipv4_tcp_retries2 设置，变量值为重传次数。</li>
<li>tcp_retries1 默认为3</li>
<li>tcp_retries2 默认值为 15次，时间根据具体的RTO而定。</li>
<li>对于 SYN 报文段，net.ipv4.tcp_syn_retries 和 net.ipv4.tcp_synack_retries 限定重传次数，默认为5，约180秒。</li>
</ul>
<h2 id="rtt设置rto">RTT设置RTO</h2>
<p>网络状态的变化，导致 RTT（Round-Trip Time）也在动态变化，RTO 先于RTT 开始会引起不必要的重传，在RTT之后开始会使得整体网络的利用率降低。RTT 的测量本身也比较复杂，<strong>TCP跟踪这些变化适时做出调整来维持好的性能</strong>。</p>
<p>RTO 设置得当是保证TCP性能的关键，<strong>TCP 收集一段时间内 RTT样本值，建立好估计值</strong>，RTT 样本通过 <strong>收到数据后返回的确认消息中携带一个字节的数据(特殊序列号)来测量改确认消息所需的时间。</strong></p>
<p><strong>每个TCP连接的 RTT 独立估算，重传计时器会对任何占用序列号的再传数据(包含SYN和FIN报文段)计时。</strong></p>
<h2 id="经典测量方法">经典测量方法</h2>
<p>最初 RFC0793 的平滑 RTT 估计值为</p>
<blockquote>
<p><strong>SRTT  &lt;&mdash; ∂ (SRTT) + (1-∂) RTTs</strong></p>
</blockquote>
<p>SRTT <strong>根据现有的样本和新样本(RTTs) 得到更新结果</strong>，∂ 为平滑因子，推荐值为 0.8 ~ 0.9。</p>
<p>每当得到新的样本值，SRTT 就会做出相应的更新，<strong>新的估计值大概率取决于现存值</strong>，这种算法成为 <strong>指数加权移动平均(Exponentially Weighted Moving Average，EWMA) 或低通过滤器(low-pass filter)</strong>，实现比较简单。</p>
<p>上面的公式目前最新的网络状态表现不明显，RFC0793推荐新的公式：</p>
<blockquote>
<p><strong>RTO = min（ubound，max（lbound，（SRTT）ß））</strong></p>
</blockquote>
<p>ß 为时延离散因子，推荐值为 1.3 ～ 2.0，ubound 为RTO的上边界(可以设定)，lbound 为 RTO 的下边界(可设定)，该经典方法，使得 RTO 为 1 秒，约两倍的 SRTT，对于<strong>相对稳定的RTT分</strong>布来说，这种方法性能不错。</p>
<p>上述经典方法通过设置上下边界固定后，出现<strong>大规模的变动</strong>，特别是<strong>实际的 RTT 远大于估计值时，会导致不必要的重传，进一步加重网络的负担</strong>。<strong>可以通过RTT样本的均值、记录RTT样本的变化情况来设置 RTO</strong>，相对于仅仅使用均值的常数倍来计算RTO 更能适应RTT变化幅度较大的场景。</p>
<h2 id="标准方法太难了">标准方法（太难了）</h2>
<h2 id="时钟粒度和rto边界">时钟粒度和RTO边界</h2>
<p>测量RTT的过程中，TCP的时钟始终运转，没有绝对的精度，并非从零开始计时，通常为某个变量，该变量的值随着系统时钟做出更新(并非同步更新)，TCP时钟的一次[滴答]时间长度称为粒度，粒度会影响RTT的测量以及RTO的设置，粒度用于优化RTO的更新情况，同时给RTO设置了一个下边界。</p>
<blockquote>
<p><strong>RTO = max（srtt  + max（G，4(rttvar)，1000）</strong></p>
</blockquote>
<p>G 为计时器粒度，<strong>1000ms 为整个 RTO 的下边界(RFC6298的建议值)</strong>，可以看出RTO 至少为1s，同时提供了可选的上边界。</p>
<p>sett 为均值的 EWMA，sttvar 为绝对误差的 |Err| 的 EWMA，这个就算了。</p>
<h2 id="rto初始值">RTO初始值</h2>
<p>在首个SYN交换前，TCP无法设置 RTO的初始值，除非系统提供（转发表缓存），否则无法设置估计器的初始值，RFC6298 设置RTO的初始值为1s，初始SYN报文段采用的超时时间间隔为 3s。</p>
<p>当收到首个 RTT 测量结果M，估计器按照以下方式初始化：</p>
<blockquote>
<p><strong>srtt  &lt;&ndash; M</strong></p>
<p><strong>rttvar &lt;&ndash; M/2</strong></p>
</blockquote>
<h2 id="重传二义性">重传二义性</h2>
<p>在测量RTT过程中出现重传，收到的确认消息是对于那一次的确认存在二义性，此时不能确定更新RTT估计值，需要通过排除二义性来解决RTT估算中出现的二义性问题。</p>
<p>RFC6298 要求：</p>
<ul>
<li>设置RTO过程中完全忽略重传问题，可能将网络提供的一些有用信息同时忽略</li>
<li>网络不再出现丢包前降低重传率有助于减轻网络负担</li>
</ul>
<p>就是排除了对第一次的确认，增大了RTO。</p>
<p>TCP 在计算 RTO 过程中采用了一个<strong>退避系数(backoff factor)</strong>，每当重传计时器出现超时，退避系数加倍，一直持续到接收非重传数据。退避系数重新重新设置为1，重传计时器返回正常值。</p>
<p><strong>TCP超时会引发拥塞控制，发送速率也会被改变。</strong></p>
<h2 id="karn-算法">Karn 算法</h2>
<p><strong>当接受到重复传输数据的确认信息时，不进行该数据包的RTT测量，可以避免重传二义性问题。但是如果长时间内都是超时重传，RTO不能够更新，会有大量的重传发生，这个时候可以用二进指数制退避(binart exponential backoff)每重传一次，就把RTO增大。</strong></p>
<p>对该数据之后的包采取退避策略，收到没有重传的数据时，退避系数重置，SRTT 才用于计算 RTO。</p>
<p><strong>带有时间戳选项的情况，可以比避免确认的二义性。</strong></p>
<h2 id="带有时间戳选项的rtt测量">带有时间戳选项的RTT测量</h2>
<p>时间戳选项允许发送者在返回的对应确认消息中携带一个32比特的数，时间戳值携带于初始SYN的TSOPT中，并在 SYN+ACK的TSOPT的TSER部分返回，以此设定 srtt、rttvar 和 RTO的初始值。由于初始SYN可看作数据，应测量其RTT值，结合其他报文段的TSOPT，估算该连接的RTT。</p>
<p>由于<strong>TCP不是对收到的每个报文段都返回ACK</strong>，<strong>当大量数据传输时，TCP通常采取每两个报文段返回一个ACK的方法</strong>，当数据出现丢失时、失序或重传成功时，<strong>TCP的累积确认机制表明与其 ACK之间并非严格的一对一对应关系</strong>。</p>
<h2 id="携带tsv的测量过程">携带TSV的测量过程</h2>
<ol>
<li>TCP发送者在其发送的每个报文段的TSOPT的TSV部分携带一个32bit的时间戳值，包含发送时刻的TCP时钟值。</li>
<li>接收端记录接收到的TSV（TsRecent）并在对应的ACK中返回，并且记录其上一个发送的ACK号（LastACK），ACK 代表接收端期望收到的下一个序号。</li>
<li>当一个新的报文段到达，如果其序列号与 LastACK 的值一致，将其TSV存入TsRecent。</li>
<li>接收端发送的任何一个ACK都包含TSOPT，TsRecent 变量包含的时间戳值被写入其 TSER 部分。</li>
<li>发送端接收到ACK后，将当前TCP时钟减去TSER值，得到的差就是新的 RTT样本估计值。</li>
</ol>
<p>FreeBSD、Linux 以及 Windows 都默认启用了时间戳选项，Linux  配置 net.ipv4.tcp_timestamps 控制是否使用该选项(0 禁用,1使用)。</p>
<h2 id="linux-的-rtt">Linux 的 RTT</h2>
<p>最小RTO 可以更改，需要改变内核配置常量 TCP_RTO_MIN的值。</p>
<p>TCP 对不含数据的报文段不提供可靠性传输，意味着若出现丢包不会重传，因此无需设定重传计时器。</p>
<p>TCP 选项本省并不进行重传货可靠传输，尽当数据段（包含SYN和FIN报文段）中明确规定，才会丢失重传。</p>
<h2 id="基于计时器的重传">基于计时器的重传</h2>
<p>一旦TCP发送端得到了基于时间的变的RTT测量值，就能根据设置RTO，发送报文段时应确保重传计时器设置合理。</p>
<p><strong>设置计时器前，需记录被计时的报文段序列号，若及时收到了该报文段的ACK，那么计时器被取消。</strong></p>
<p>之后发送端发送一个新的数据包时，需要设定一个新的计时器，并记录新的序列号。</p>
<p>因此每一个TCP连接的发送端不断的设定和取消一个重传计时器，如果没有数据丢失，就不会出现计时器超时。</p>
<p><strong>设置的RTO时间内没有收到被计时报文段的ACK，将会触发超时重传，TCP会降低当前数据的发送率来进行快速响应。</strong></p>
<ul>
<li><strong>基于拥塞控制机制减小发送窗口大小</strong></li>
<li><strong>当一个重传报文段被再次重传时，增大RTO的退避因子(Karn)</strong></li>
</ul>
<p>当同一个报文段出现多次重传时，RTO值暂时性的乘上值 y 来形成新的超时退避值 RTO = y RTO。</p>
<p>通常 y = 1, 随着多次重传，y 加倍增长，y 不能超过最大退避因子，linux 设置  RTO 不能超过 TCP_RTO_MAX，默认值为 20s，一旦收到 响应的ACK，y会重置为1。</p>
<p>大多数情况，计时器超时并触发重传是不必要的，因为RTO的设置通常大于RTT，<strong>基于定时器的重传会导致网络利用率下</strong>降，同时需要对每一个连接的每一个报文段设置，取消定时器。</p>
<h2 id="快速重传">快速重传</h2>
<p><strong>快速重传机制</strong>[RFC5681] <strong>基于接收端的反馈信息来引发重传</strong>，相比基于计时器的重传能够更加有效的修复丢包情况。</p>
<p><strong>当接收到失序报文段时，TCP需要立即生成确认信息（重复ACK），不能延迟发送，这个时候接收端缓存出现了空缺，发送端需要尽快的填补空缺。</strong></p>
<p>**重复ACK（**不管是否包含SACK）到达发送端表明先前发送的某个分组已丢失，<strong>接收端没有收到期望的序列号报文段时</strong>，本来期望到达的报文段可能丢失也可能是延迟到达，<strong>不能确定是延迟还是丢失</strong>，<strong>TCP会等待一定数目的重复ACK（重复ACK阈值或 dupthresh）来决定数据是否丢失并触发快速重传。通常 dupthresh 为常量(3)，但一些非标准化的实现可以基于当前的失序程度来动态调节 dupthresh</strong>。</p>
<p>TCP发送端收到至少 dupthresh 个重复ACK后，重传可能丢失的数据分组，不必等到重传计时器超时，重复ACK通常和网络拥塞有关，<strong>快速重传应该出发拥塞控制机制</strong>。</p>
<p>不采用SACK 时，接收到有效ACK前至多只能重传一个报文段，采用SACK，ACK可以包含额外信息，使得发送端在每个RTT时间内可以填补多个空缺。</p>
<h2 id="报文段丢失时的-sack">报文段丢失时的 SACK</h2>
<p>接收端在TCP连接建立期间收到SACK许可选项就可以生成SACK，每当缓存中收到了失序数据时，接收端就可以生成SACK。</p>
<p>SACK 块内包含的是最近收到的报文段序列号，后面的SACK 会重复之前的块信息，防止丢失做了备份。如果SACK不会丢失，每个SACK包含一个SACK块就可以实现SACK的全部功能，但<strong>是SACK和普通的ACK会丢失，如果其中不包含数据(SYN或FIN控制位字段不被置位)就不会被重传。</strong></p>
<p>发送端记录接收到的ACK信息，还要记录接收到的SACK信息，避免重传正确接收到的数据。当接收到相应序列号范围的ACK时，在其重传缓存中标记接收到响应的ACK选择重传成功。</p>
<h2 id="sack对上行网络带宽的影响">SACK对上行网络带宽的影响</h2>
<p>SACK 主要是接收端告知发送端自己缓冲区里面的缺失空洞，主要是携带失序/空缺的报文序列段范围，公共前缀和左边界、右边界组成失序的报文序列段范围，大部分场景下，拥塞窗口较小，<strong>边界描述占用没有达到那么大的空间，SACK 大小的存在对上行网络带宽的浪费</strong>。</p>
<h2 id="接收端sack的变更">接收端SACK的变更</h2>
<p><strong>SACK选项和SACK是建议性的，接收端可能会做出变更</strong>，可能上一个SACK块告知没有报文段缺失，下一个SACK块告知有缺失，因此<strong>发送端不能立即清空其重传缓存中的数据，只有当接收端的普通ACK号大于其最大序列号值时才可清除</strong>。</p>
<p>这种接收端的SACK变更也会影响重传计时器超时，如果启用了基于计时器的重传，应该忽略SACK显示的任何关于接收端数据失序的信息，如果仍然存在失序数据，重传报文段的ACK中就包含附加的SACK块。</p>
<hr>
<p><strong>发送端采用SACK并不能百分百的提高整体性能，RTT较大，丢包严重的场景，SACK能够在RTT内填补多个空缺才能够提供性能。</strong></p>
<h2 id="伪超时和重传">伪超时和重传</h2>
<p>伪重传（Spurious retransmission）没有出现丢失引起不必要重传，主要是由<strong>伪超时（spurious timeout），过早判定超时</strong>、包失序、包重复、ACK丢失等原因导致。<strong>在实际RTT显著增长，超过当前RTO时，可能会出现伪超时</strong>。</p>
<p>处理伪超时问题，包含<strong>检测算法和响应算法</strong>。</p>
<p>detection 用于判断某个超时或基于计时器的超时的重传是否真实，一旦认定出现伪超时则执行 response 算法，用于撤销或减轻该超时带来的影响。</p>
<h2 id="回退n行为">回退N行为</h2>
<p>go-back-N，延迟ACK，发送端判定超时，会连带没有收到ACK相邻的报文重发，会导致多个已经ACK过的包，再次重传。</p>
<h2 id="dsack接收端">DSACK(接收端)</h2>
<p>没有启动SACK的连接中，<strong>ACK只能告知发送端最大的有序报文段，SACK能够告知发送端失序的报文段</strong>，<strong>SACK机制没有规定收到重复的数据段怎么应对</strong>，重复的数据可能是伪重传、网络的重复造成的。</p>
<p>在SACK<strong>接收端采用了DSACK</strong>（D-SACK，重复SACK），结合通常的SACK发送端，<strong>可以在第一个SACK块中告知接收端收到的重复报文段序列号</strong>。</p>
<p>DSACK 的主要目的是<strong>判断何时的重传是不必要的</strong>，并了解网络中的其他事项，这样可以<strong>让发送端推断是否发生了包失序、ACK丢失、包重复或伪重传</strong>。</p>
<p><strong>一个非DSACK与DSACK的TCP共用一个连接，他们会交互操作，非DSACK不能使用DSACK的功能。</strong></p>
<p><strong>接收端允许包含序列号小于等于累积ACK号字段的SACK块</strong>，DSACK 信息之宝在单个ACK中，不会在多个SACK中重复，鲁棒性较低。</p>
<h2 id="eifel-detection">Eifel detection</h2>
<p><strong>利用 TSOPT 来检测伪重传，超时重传时，保存 TSV，等待ACK，比对 ACK 的 TSER，如果 TSER  小于 重传的 TSV ，则表明这次重传为伪重传，因为 等待到的ACK 是对之前的发送的报文段的确认。</strong></p>
<p><strong>Eifel 能比仅采用 DSACK更早的检测到伪重传行为，？？？这个不太能够吧，只有第一次ACK延时回来，并且在第二次重传的ACK回来之前回来，这个时候发送端才能检测到第二次重传是伪重传的。</strong></p>
<p>及早检测伪重传是有利的，能是避免回退N行为，但是ACK丢失这个没办法的，只能重传。</p>
<p>EiFel 搭配 DSACK 使用，可以解决整个窗口的ACK信息都丢失，DSACK的到达能够使得 EiFel 认定相应的重传不是伪重传。</p>
<h2 id="f-rto">F-RTO</h2>
<p>Forward-RTO Recovery，F-RTO，前移RTO恢复，是检测伪重传的标准算法，<strong>不需要对TCP任何选项，只要在发送端实现方法就行</strong>，<strong>只检测由重传计时器超时引起的伪重传。</strong></p>
<p>计时器重传之后，F-RTO 会对TCP的常用行为做出一定的修改，<strong>由于这类重传针对的是没有收到ACK信息的最小序列号，通常情况下，TCP会继续按序发送相邻的分组，也就是会退N行为。</strong></p>
<p>F-RTO 会修改TCP的行为，在超时重传后收到第一个ACK时，TCP会发送新的数据（非重传），之后在响应后一个到达的ACK，如果其中一个为重复的ACK，则认为此次重传没问题，如果两个都不是重复ACK，则表示该重传是伪重传。
?????那就是一个ACK超时返回，两次都收到了，不就是超时了一个吗，重传的是伪重传，但是又和超时机制冲突了。</p>
]]></content>
        </item>
        
        <item>
            <title>Transaction-2PC,3PC,BASE</title>
            <link>https://liguangchang.cn/posts/distributed/distributed-transaction/</link>
            <pubDate>Sun, 17 Oct 2021 23:41:03 +0800</pubDate>
            
            <guid>https://liguangchang.cn/posts/distributed/distributed-transaction/</guid>
            <description>事务 Transaction ，一种机制，将包含一系列操作的工作序列纳入到一个不可分隔的执行单元，只有把操作均被正确执行才能提交事务，任意一个操作失败都会导致整个事</description>
            <content type="html"><![CDATA[<h2 id="事务">事务</h2>
<p>Transaction ，一种机制，将包含一系列操作的工作序列纳入到一个不可分隔的执行单元，只有把操作均被正确执行才能提交事务，任意一个操作失败都会导致整个事务回滚到之前， all or  nothing，想要实现组合指令原子性。</p>
<h2 id="acid特征">ACID特征</h2>
<h3 id="atomicity">Atomicity</h3>
<p>事务的最终状态只有 全部执行成功、全部不执行，不会停留在中间的某个环节。</p>
<h3 id="consistency">Consistency</h3>
<p>事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。</p>
<h3 id="isolation">Isolation</h3>
<p>多个事务并行执行时，使用相同的数据不会相互干扰，每个事务都有一个完整的数据空间，对其他并发事务是隔离的。</p>
<h3 id="durability">Durability</h3>
<p>持久性/永久性，一个食物被执行后，对数据库所做的更新就永久保存了下来。</p>
<hr>
<p><strong>数据操作请求满足上述四个特性，存储系统才能够处于正确的工作状态。</strong></p>
<p><strong>分布式下的事务由多个本地事务组成，要满足Consistency，所有操作均执行成功提交结果来保证数据一致性、完整性，但是分布式的规模下要达到强一致性需要时间周期较长，BASE理论指出采用最终一致性来代替强一致性。</strong></p>
<h2 id="实现分布式事务">实现分布式事务</h2>
<ul>
<li>基于XA协议的两阶段提交协议方法(Consistency)</li>
<li>三阶段提交协议方法 (Consistency)</li>
<li>基于消息的最终一致性方法(BASE)</li>
</ul>
<h2 id="基于xa协议的2pc">基于XA协议的2PC</h2>
<p><strong>XA是一个分布式事务协议，规定了事务管理器和资源管理器接口，包括事务管理器和本地资源管理器两部分。</strong></p>
<p><strong>事务管理器相当于集中式的中央节点服务器负责协调，负责各个本地资源的提交和回滚</strong></p>
<p><strong>资源管理器就是分布式事务的参与者，通常由数据库实现</strong>。</p>
<p><strong>两阶段提交协议执行过程，分为投票(voting)和提交(commit)两个阶段</strong>。</p>
<ul>
<li><strong>第一阶段</strong> 协调者会向事务参与者<strong>发起执行操作的 cancommit 请求</strong>，并<strong>等待参与者响应</strong>
<ul>
<li>参与者收到请求后，会执行请求中的事务操作，<strong>将操作记录记录到事务日志中但是不提交</strong>。</li>
<li><strong>待参与者执行成功</strong>，向协调者发送 YES 消息，表示同意操作，不成功发送NO消息，终止操作。</li>
<li><strong>当所有参与者都返回了操作结果后</strong>，进入第二阶段提交/执行阶段</li>
</ul>
</li>
<li><strong>第二阶段提交/执行</strong>
<ul>
<li>如果协调者收到的<strong>回复都是 YES 消息</strong>，向参与者发送 <strong>DoCommit</strong> 消息</li>
<li>参与者收到 <strong>DoCommit</strong> 消息后，完成剩余的操作并释放资源，向协调者返回 <strong>HaveCommitted</strong> 消息。</li>
<li>如果协调者收到的消息<strong>包含 NO 消息</strong>，<strong>向所有的参与者发送 DoAbort 消息</strong>，之前投票发送 YES 消息的参与者，会根据之前执行操作的事务日志<strong>对操作进行回滚</strong>，然后所有参与者会向协调者<strong>发送 HaveCommitted 消息</strong>。</li>
</ul>
</li>
<li><strong>协调者收到所有参与者的 HaveCommitted 消息后，整个事务结束</strong>。</li>
</ul>
<p>两阶段提交每个阶段都是等待所有节点回复，协调者向参与者下发请求操作，参与者收到请求执行，通知协调者，协调者根据所有参与则会的回复在确定是否提交和回滚，有点四次🤝的感觉，尽量保证了数据的强一致性，但是这显然是不能够保证可靠性和可用性的。</p>
<ul>
<li><strong>同步阻塞等待</strong>，参与者二阶段提交对资源存在竞争，阻塞传递导致真个事务阻塞，不能够支持高并发场景。</li>
<li><strong>单点故障</strong>，协调者故障，整个系统就挂了，如果在二阶段的提交阶段，数据库的资源可能也不能释放。</li>
<li><strong>数据不一致</strong>，提交阶段，协调者 <strong>DoCommit</strong> 通知参与者对操作提交，如果发生了局部网络异常，通知消息丢失，部分事务提交，部分事务没有被提交，导致数据不一致。</li>
</ul>
<p><strong>Q</strong></p>
<p><strong>两阶段提交在协调者通知参与者提交阶段，通知消息丢失。</strong></p>
<ol>
<li><strong>那这个事务结束结束吗？超时自动回滚？</strong></li>
<li><strong>协调者是否等到所有的参与者回复 HaveCommited消息才结束呢，如果失败会重发吗？</strong></li>
<li><strong>如果分布式节点跨数据中心，怎么搞，边缘网络能解决广域网传输问题吗？？？</strong></li>
</ol>
<h2 id="三阶段提交协议3pc">三阶段提交协议3PC</h2>
<p>Three-phase Commit Protocol，3PC，是对两阶段提交 <strong>2PC</strong>的改进，为了处理两阶段提交的同步阻塞和数据不一致问题，3PC 引入了<strong>超时机制和准备阶段</strong>。</p>
<ul>
<li>3PC的超时机制，如果协调者和参与者<strong>在规定的时间内没有收到消息响应，就会根据当前的状态选择提交和终止事务</strong>，从而减少整体阻塞时间，一定程度减轻了阻塞的程度。</li>
<li>在第一阶段和第二阶段中间加入了一个准备阶段，或者将2PC的投票的第一阶段分为两步，<strong>提交阶段前加入一个预提交阶段</strong>，在预提交阶段尽可能排除一些不一致的情况，保证最后提交阶段之前各参与阶段的状态是一致的。</li>
<li>增加一次消息通信确认来尽可能保证数据一致，实现用 UDP 吗？</li>
</ul>
<hr>
<h3 id="cancommitvote">CanCommit(vote)</h3>
<p>协调者向参与者<strong>发送请求询问(CanCommit 请求)</strong>，<strong>询问参与者是否可以顺利?执行事务提交操作</strong>，等待参与者响应。</p>
<p>参与者收到CanCommit 请求之后，回复YES/NO，仅回复是否可以顺利执行事务，不写日志，这会可靠吗？？？</p>
<p>当收到<strong>所有参与者</strong>，还是所有，进入预提交阶段，是要来判断资源有没有争抢？能预料到之后的执行事务的死锁吗？</p>
<h3 id="precommit">PreCommit</h3>
<ul>
<li>如果所有参与者回复的都是YES，协调者会执行事务的预执行。</li>
<li>协调者向参与者发送 PreCommit 请求，进入预提交阶段。</li>
<li>参与者收到PreCommit 请求后执行事务操作，将Undo、Redo 信息记录到事务日志</li>
<li>如果参与者成功执行事务操作，对协调者进行ACK响应，等待最终提交指令</li>
<li><strong>任何一个参与者向协调者发送了No消息，或者等待超时之后协调则会没有收到参与者的响应，就执行中断事务的操作</strong></li>
<li><!-- raw HTML omitted -->Q: 这个超时时间是全局时间还是单个节点都是一个维护时间，能不能广播一下子把消息发出去？**能不能等待一个固定时间没有收到全数的ACK就中断事务回滚？**单个节点维护一个超时时间复杂了一点。<!-- raw HTML omitted --></li>
<li>如果事务被中断，协调者向所有参与者发送 About 消息</li>
<li>参与者收到 About 消息之后，或超时之后仍然未收到协调者的消息，执行事务的中断操作。</li>
<li><!-- raw HTML omitted -->Q: <strong>2PC引入一个超时时间 FAIL FAST 不行吗?，3PC 多一次通信感觉意义不大啊!</strong><!-- raw HTML omitted --></li>
</ul>
<p><strong>这样确实能够保证在最后提交阶段，所有的参与者状态是一致的。</strong></p>
<h3 id="docommit">DoCommit</h3>
<p>根据 PreCommit 阶段协调者发送的消息，进入执行提交或事务中断。</p>
<ol>
<li>提交
<ul>
<li>如果收到所有参与者发送的 ACK响应，向所有参与者发送 DoCommit 消息，开始执行。</li>
<li>参与者收到 DoCommit 消息之后，正式提交事务，完成事务提交之后，释放所有锁住的资源，并向协调者发送ACK响应。</li>
<li>协调者收到所有参与者ACK 响应后，完成事务。</li>
</ul>
</li>
<li>中断
<ul>
<li>协调者向所有参与者发送 Abort 请求</li>
<li>参与者接受到Abort 消息之后，利用其在PreCommit 阶段记录的 Undo 信息执行事务的回滚操作</li>
<li>释放所有锁住的资源，并向协调者发送ACK消息。</li>
<li>协调者收到参与者反馈的ACK消息之后，执行事务的中断，结束事务。</li>
</ul>
</li>
</ol>
<h3 id="参与者超时自动提交docommit">参与者超时自动提交(DoCommit)</h3>
<p><strong>3PC 协议在协调者和参与者中都引入了超时机制，参与者ACK通知协调者，如果等待协调者ACK超时，默认情况下会自动超时提交，减少整个集群的提交，一定程度减轻了2PC的阻塞问题。</strong></p>
<h3 id="3pc的不一致precommit">3PC的不一致(PreCommit)</h3>
<p>PreCommit 阶段，参与者未收到协调者ACK，无法写log，预执行任务，导致数据不一致。</p>
<p>分布式里面，2PC，3PC 需要所有的节点同步参与通信，通信消息密集，并且还是依赖数据库的实现，数据库还得保证网络的稳定，协议也不是FAIL FAST，这个协议不就是个KPI吗。</p>
<h2 id="基于分布式消息的最终一致性">基于分布式消息的最终一致性</h2>
<p>2PC、3PC以集中式架构，同步执行、通信，存在数据不一致情况，根本不能够满足大部分场景。</p>
<p>分布式的事务，通过消息或者日志异步执行，通过承载相应的信息的数据库或者消息队列组件来处理。</p>
<p>引入MQ，以购物事件为例</p>
<ol>
<li>用户下单到订单系统，订单通过消息请求MQ持久化</li>
<li>MQ持久化成功，订单系统持久化订单信息，通知MQ投递订单消息去支付，MQ持久化失败，删除消息，响应订单系统。</li>
<li>支付系统消费消息，进行支付，支付完成在投递到新的状态队列</li>
<li>仓库系统消费支付完成的订单状态队列，完成下单</li>
</ol>
<hr>
<p>异常情况</p>
<ol>
<li>订单信息投递MQ持久化失败，订单系统就没有后续，直接失败</li>
<li>MQ 投递到待支付队列，支付系统支付成功ACK回传MQ失败，订单系统和支付系统不一致，需要MQ进行重试，这个时候不能回滚，不能让支付系统支付成功的退钱吧。</li>
<li>支付成功ACK成功，订单ACK失败，MQ需要确认结果一致性，进行重试或删除。</li>
</ol>
<p>基于MQ 消息的异步通信，避免了通信阻塞，提高了吞吐量，可以确保一致性，并且屏蔽了不同系统协议的规范，需要MQ系统的高可用支撑，避免了2PC、3PC 保证强一致性很大几率的数据不一致，成功率更高。</p>
<p><!-- raw HTML omitted --><strong>Q: 这里的MQ 算是解耦吗？</strong><!-- raw HTML omitted --></p>
<table>
<thead>
<tr>
<th></th>
<th>2PC</th>
<th>3PC</th>
<th>MQ</th>
</tr>
</thead>
<tbody>
<tr>
<td>一致性类别</td>
<td>强一致性</td>
<td>强一致性</td>
<td>最终一</td>
</tr>
<tr>
<td>执行方式</td>
<td>同步</td>
<td>同步</td>
<td>异步</td>
</tr>
<tr>
<td>同步阻塞问题</td>
<td>存在</td>
<td>存在(较轻)</td>
<td>不存在</td>
</tr>
<tr>
<td>单点故障</td>
<td>存在</td>
<td>存在</td>
<td>不存在</td>
</tr>
<tr>
<td>吞吐量/并发</td>
<td>低</td>
<td>中</td>
<td>高</td>
</tr>
<tr>
<td>实现难度</td>
<td>简单</td>
<td>简单</td>
<td>复杂</td>
</tr>
<tr>
<td>性能</td>
<td>低</td>
<td>低</td>
<td>高</td>
</tr>
</tbody>
</table>
<h2 id="刚性柔性事务">刚性/柔性事务</h2>
<ul>
<li>
<p>刚性事务</p>
<p>遵循ACID原则，强一致性</p>
</li>
<li>
<p>柔性事务</p>
<p>根据业务容忍度实现最终一致性，容忍一定时间内数据不一致。</p>
</li>
</ul>
<h2 id="base理论">BASE理论</h2>
<p>eBay 的 Dan Pritchett 提出分布式存储系统的设计模式 - BASE 理论。</p>
<p>**BASE理论包括 **</p>
<p><strong>基本可用(Basically Available)  允许部分功能不可用(降级)，保证核心功能可用。</strong></p>
<p><strong>柔性状态(Soft State) 允许系统存在中间状态，中间状态不会影响系统整体可用性，eg: 数据库的主从延时。</strong></p>
<p><strong>最终一致性(Eventual Consistency) 数据的暂时不一致，最终一致。</strong></p>
<p>分布式MQ 消息通信来延迟达到数据最终一致，就是遵循的 BASE 理论。</p>
<p>MQ 中的需要对处理异常、消费幂等、重试，啊啊啊。</p>
<h2 id="分布式事务一致性分类">分布式事务一致性分类</h2>
<h3 id="宽松一致性">宽松一致性</h3>
<ul>
<li>
<p>无中间态 xa、消息</p>
</li>
<li>
<p>有中间态 TCC，SAGA</p>
</li>
<li>
<p>MSG</p>
</li>
</ul>
<p>回滚问题</p>
<h3 id="方案">方案</h3>
<ul>
<li>seata</li>
<li>himly</li>
<li>tcc-transaction</li>
<li>ByteTCC</li>
<li>本地消息表</li>
<li>对账补偿 允许不一致，检测不一致情况进行补偿，工作量大</li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>Consensus、Consistency、FLP、CAP、Byzantine、PoW</title>
            <link>https://liguangchang.cn/posts/distributed/distributed-consensus/</link>
            <pubDate>Sat, 16 Oct 2021 23:36:46 +0800</pubDate>
            
            <guid>https://liguangchang.cn/posts/distributed/distributed-consensus/</guid>
            <description>Consensus 和 Consistency，前者侧重于集群节点达成一致的过程和算法，后者侧重于节点共识过程最终所有数据状态副本对外表现的数据一致性。 传统分布</description>
            <content type="html"><![CDATA[<p>Consensus 和 Consistency，前者侧重于集群节点达成一致的过程和算法，后者侧重于节点共识过程最终所有数据状态副本对外表现的数据一致性。</p>
<p>传统分布式一致性不考虑拜占庭容错问题，假设不存在拜占庭节点。</p>
<p>区块链系统的共识算法更倾向于运行在更为复杂、开放和缺乏信任的网络环境中，节点数量更多，就有可能存在恶意拜占庭节点。</p>
<p>分布式共识就是在多个节点均可独自操作或记录的情况下，使得所有节点针对某个状态达成一致的过程。</p>
<h2 id="网络模型">网络模型</h2>
<ul>
<li>
<p>同步网络</p>
<p>Synchronous Network，进程执行的每一步的时间都有明确的上下限，每一条消息在网络中传输的时间都有上限，同时每个进程的本地时钟与实际时间的漂移率在已知范围内。分布式系统中，基于这三个条件就可以根据超时机制来检测进程的非拜占庭故障，简化分布式系统的设计。</p>
</li>
<li>
<p>异步网络</p>
<p>Asynchornous Network，对进程的执行速度、消息在网络中的传输时间和时钟漂移率都没有限制。有些故障很难判断和解决，日常使用的互联网就是典型的异步网络模型，大多数区块链共识算法都是基于同步网络模型，实际运行网络环境中一般都是异步网络模型。</p>
</li>
<li>
<p>半异步网络</p>
<p>Partially Synchronous，假设在一段网络扰动后，网络最终会回归到同步状态上，更符合实际的网络场景。</p>
</li>
</ul>
<h2 id="故障模型">故障模型</h2>
<p>分布式系统中的故障一般发生在节点计算和通信链路上。</p>
<h3 id="拜占庭故障">拜占庭故障</h3>
<p>Byzantine Failure，或者随机故障，节点可以任意地、错误地甚至恶意地执行任何动作</p>
<h3 id="时序故障">时序故障</h3>
<p>Timing Failure 程序可以按照逻辑执行，并且可以正常地响应请求，但是不能保证在指定的时间内响应。</p>
<ul>
<li>
<p>信道故障</p>
<p>消息在信道传输过程中超出了规定的延迟范围</p>
</li>
<li>
<p>性能问题</p>
<p>虽然可以正常执行完成任务，由于性能问题导致执行时间过长，超过了预期的范围。</p>
</li>
<li>
<p>本地时钟</p>
<p>本地始终超过了实际的时钟漂移率范围</p>
</li>
</ul>
<h3 id="崩溃故障">崩溃故障</h3>
<p>Crash Failure，当故障发生时必须停止响应和发送消息，不会恢复。</p>
<h3 id="遗漏故障">遗漏故障</h3>
<p>Omission Failure，节点或者信道未能执行本来应该执行的动作，崩溃时，必须保证一些动作记录下来，当崩溃恢复时，就继续执行因为崩溃未执行的动作。</p>
<h2 id="flp">FLP</h2>
<p>1958年，Fischer、Lynch、Patterson 发表了 FLP定理，并获得了Dijkstra 奖。</p>
<p><a href="http://m.8684.cn/today_y1958">1958年，地球发生了什么</a></p>
<p>FLP 表示 <strong>在含有多个确定性的异步系统中，只要有一个进程可能发生故障，那么就不存在协议可以保证在有限时间内所有的进程一致</strong>。</p>
<p>异步系统的假设是FLP定理的关键，假设进程是完全异步的，无法获得任何进程处理速度或消息传输延迟的信息，进程也不能使用同步时钟，因此无法使用基于超时的算法。FLP还假设进程无法判断其他进程是处于完全停止状态还是处于缓慢运行状态。</p>
<p>也就是一个分布式的异步系统中，每一个 leader 都会从提议者处收集提案，当收集到全部提议者发出的提案后就可以达成一致。当没有故障节点时是可行的，只是达成共识的速度会收到最慢节点网络链接的影响。</p>
<p>当提案者中发生了故障或者崩溃，leader 不会知道，更不会知道需要等待多长时间才可以收集到全部的提案，即使重试也无法得知故障节点是否可以恢复，只能死等，导致整个体系无法达成共识。</p>
<h2 id="cap">CAP</h2>
<p>2000年加州大学柏可莱分校的计算机科学家埃里克·布鲁尔在分布式计算原理研讨会(PODC)提出了一个猜想，2002年，麻省理工学院的塞斯·吉尔伯特和南希·林奇发表了布鲁尔猜想的证明，使之成为CAP定理。</p>
<p>CAP定理指出对于一个分布式系统来说，不可能同时满足三个特点，一致性(Consistency)、可用性(Availability)、分区容错性(Partition tolerance)，理论上只能同时满足两个。</p>
<ul>
<li>
<p>Consistency</p>
<p>强一致性，分布式系统中的状态在某一时刻必须保持一致。</p>
</li>
<li>
<p>Availability</p>
<p>当集群中部分节点出现故障时，集群仍然可以处理客户端的请求，所有的读写请求都会在一个有限的时间内得到响应。</p>
</li>
<li>
<p>Partition tolerance</p>
<p>网络出现分区，不同分区的集群节点之间无法相互通行的时候，被分隔的节点仍然能够对外提供服务。</p>
</li>
</ul>
<p><strong>如果同时满足一致性和可用性，网络不能出现分区。如果同时满足可用性和分区容错性，不通分区的网络同时对外提供服务就可能导致状态不一致，如果同时满足一致性和分区容错性，不同分区的网络为了实现状态的一致就必须要等待从而导致不能满足可用性。</strong></p>
<p>工程实践中强一致性几乎是不可能实现的，一般放宽到弱一致性，当用户读到某一操作时，系统特定数据的更新需要一段时间。</p>
<p>区块链系统的最终一致性是弱一致性的表现，绝大多数公有链通常牺牲一致性来同时满足最终一致性、可用性和分区容错性。在某一个时间节点，区块链可能出现分叉，每一个分叉各自独立维护一个交易集合，随着时间推移，总会有一个分支获得越来越多的认可，最后会达到最终一致性，一些联盟链会牺牲可用性来满足强一致性和分区容错性。</p>
<h2 id="区块链中记账共识算法">区块链中记账共识算法</h2>
<p>超级账本采用过 PBFT达成共识，PBFT在少数节点的交易量和吞吐量都比较高，节点数多的话，彼此之间交流信息会长生大量能耗，性能会大幅下降。</p>
<p>分布式系统中，运行环境和拜占庭将军的环境类似，<strong>共识算法的核心是在正常的节点间形成对网络形态的共识</strong>。Raft 对于参与节点比较宽容，无法容忍拜占庭节点，<strong>为了保证Raft算法能够正常进行，一般需要一种带许可证的网络，对每一个参与者发放证书</strong>。</p>
<p><strong>不同的算法保证了在不同场景下节点可以达成一致，共识是一种手段，是集群内部达成一致性的保证过程，一致性是内部达成共识对外的一种表现</strong>，好比一个银行账户在相同的银行的不同网点看到的余额一致。</p>
<p>挖矿虽然在客观上会创造新的比特币，最终目的并不是创造比特币，<strong>只是作为一种激励手段来支撑去中心化的清算机制</strong>，通过挖矿这种方式将去中心化的安全机制与参与者的利益相统一。</p>
<p>挖矿简单来说就是找到一个随机数(nonse)参与hash运算，使得最后得到的区块hash值符合难度要求 Hash(Block Header) &lt;= target。</p>
<p>比特币系统采用的哈希算法是 SHA256 算法，最后会产生256Bit的输出，一共有2^256种可能的取值，找到符合难度要求的hash值用多次穷举nonse计算，同时区块头不是单一的字段，而是多个字段拼接而来的。</p>
<p>比特币的供应是通过挖矿创造的，为了模拟这个过程，产生的比特币数量设计为逐步递减的，大约每四年(每210000块)产生一个新区块，获得的比特币数量将减少一半,2140年后将不会再产生新的比特币。</p>
<h2 id="pow">PoW</h2>
<p>Proof-of-Work，工作量证明，一份用来确认系统做过一定量的工作的证明，以每个节点的算力还竞争记账权。（比特币采用）</p>
<p>区块链参与者（矿工）要在区块链中添加一笔交易，必须解决某种复杂但是无用的计算问题。确保矿工花费了一些资源完成工作，并且不会损害区块链系统，损害系统会导致矿工投入的资源也会有损失，解决问题仅在于完整证明。</p>
<p>当矿工想要打包交易决定记账权时必须消耗一定的资源，来提高门槛确保记账权确实被想要打包区块的矿工获得，获得记账权需要消耗大量的资源，其他节点很容易验证这个过程，利用了 PoW算法中的资源消耗的不对称性。</p>
<p>网络中的任何区块都可以试图创建区块，只有在满足以下条件时创建的区块才会被其他节点认可和接受</p>
<ul>
<li>
<p>区块中包含的交易都是合法的</p>
<p>节点只需要将每笔交易都验证一遍，丢弃掉不合法的交易即可</p>
</li>
<li>
<p>区块hash值要小于或等于一个目标值(争夺记账权)</p>
<p>需要算力争取。</p>
</li>
</ul>
<p>假设每个节点会划分多个区块用于记录用户交易，PoW 算法获取记账权的原理是，利用区块的 index，前一个区块的哈希值、交易的时间戳、区块数据和 nonce 值，通过SHA256哈希算法计算出一个哈希值，并判断前k个值是否都为 0。如果不是，则递增 nonce 重新计算，如果是，本次计算的hash值为要解决的题目的正确答案，谁先算出答案，谁就获得这个区块的。</p>
<p>K为哈希值的前导零的个数，标记了计算的难度，0越多难度越大。</p>
<h3 id="记账过程">记账过程</h3>
<p>客户端产生了一个新的交易，基于PoW记账过程</p>
<ul>
<li>客户端产生新交易，向全网广播，要求对交易进行记账</li>
<li>每个记账节点接收到请求后，将收到的交易信息放入一个区块中</li>
<li>每个节点通过PoW算法，计算本节点的区块的hash值，尝试找到一个具有足够工作量难度的工作量证明</li>
<li>若有节点找到了一个工作量证明向全网广播（区块中所有交易都是有效且之前未存在过的,其他节点才会认同该区块的有效性)</li>
<li>其他节点收到广播消息后，若验证该区块有效，接受该区块，并跟随在该区块的末尾，制造新区块延长该链条，将被接受的区块的随机hash值视为新区块的随机hash值。</li>
</ul>
<p><strong>Pow 的容错机制，允许全网50%的节点出错，要破坏系统需要投入大量节点同时获得记账权，冲突多，会增加达成共识的时间。</strong></p>
<p><strong>Pow 每次达成共识需要全网共同参与运算，增加了每个节点的计算量，如果题目过难，会导致计算时间长，资源消耗多，如果题目过于简单，会导致大量节点同时获得记账权，冲突多，这些问题都会导致达成共识的时间。</strong></p>
<h2 id="pos">PoS</h2>
<p><strong>为了解决 PoW 算法的问题，引入了PoS 算法，由系统权益代替算力来决定区块记账权，拥有的权益越大获得记账权的概率就越大。（以太坊）</strong></p>
<p>权益就是每个节点占有货币的数量和时间，货币就是节点所获得的奖励，鼓励利滚利。</p>
<p>PoS之处在于节点计算获取记账权的方法不一样，PoS是根据节点拥有的股权或权益进行计算。</p>
<p><strong>PoS算法中，节点计算自己的记账权时，通过计算自己的股权或权益来评估，如果发现自己权益最大，则将自己的区块广播给其他节点(保证该区块的有效性)，减少了大部分节点的计算消耗。</strong></p>
<p><strong>PoS 将算力竞争转变为权益竞争，减少了资源消耗，不需要在每个区块中创建新的货币来激励记账者参与当前玩够哦的运行，在一定程度上缩短了共识达成的时间，以太坊每秒大概能处理30笔交易，持币多的人越来越多，容易出现垄断</strong>。</p>
<h2 id="dpos">DPoS</h2>
<p>DPoS 类似于股份制公司的董事会制度，普通股民虽然拥有股权，但进不了董事会，可以投票选举代表(受托人)代他们做决策。</p>
<p>DPoS是由被社区选举的可信账户(得票较多的受托人)来拥有记账权。</p>
<p>成为受托人需要去社区拉票获得足够多的信任，用户根据自己持币数量占比来投票，类似公司股票机制。根据自己的权益，投票选出可代表自己的受托节点，受托节点之间竞争记账权。</p>
<p>通常会选出 k(比如 101) 个受托节点，权利完全相等。受托节点之间争取记账权<strong>也是根据算力进行竞争</strong>的。只要受托节点提供的算力不稳定、宕机或者有恶意行为，随时可以被持有货币的普通节点投票踢出系统，后备的受托节点可以随时顶上去。（高级）</p>
<p>DPoS 受托人的优点</p>
<ul>
<li>
<p>能耗低、交易更快</p>
<p>由投票选出的若干信誉度更高的受托人记账，解决了所有节点均参与竞争导致消息量大、达成一致的周期长的问题</p>
</li>
<li>
<p>每隔一定周期调整受托人，避免受托人造假和独权</p>
</li>
</ul>
<p>DPoS 大多数持币通过受托人参与投票，投票的积极性不高，一旦出现故障，无法及时做出应对，导致安全隐患。？提前准备节点planB，类似主备不行吗。</p>
<h2 id="总结">总结</h2>
<ul>
<li>PoW 算力工作量证明争夺记账权，需要全部节点参与计算，共识时间长，算力消耗浪费资源 （比特币）</li>
<li>PoS 系统权益代替算力决定区块记账权，节能，容易形成垄断</li>
<li>DPoS 委托权益证明算法，持币人投票选举作为代表通过算力竞争记账权，持币人可以投票随时踢出受托人，不够高可用</li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>Byzantine、PBFT</title>
            <link>https://liguangchang.cn/posts/distributed/distributed-pbft/</link>
            <pubDate>Sat, 16 Oct 2021 22:32:43 +0800</pubDate>
            
            <guid>https://liguangchang.cn/posts/distributed/distributed-pbft/</guid>
            <description>Practical Byzantine Fault Tolerance,PBFT，实用拜占庭容错算法，在1999年召开的第三届操作系统设计与实现研讨会上有 Miguel Castro 和 Barbara Liskov 提出，(经常两个人)，</description>
            <content type="html"><![CDATA[<p><strong>Practical Byzantine Fault Tolerance,PBFT，实用拜占庭容错算法</strong>，在1999年召开的第三届操作系统设计与实现研讨会上有 Miguel Castro 和 Barbara Liskov 提出，(经常两个人)，可以用于异步网络，并且在前人所做工作的基础上大幅度提高了系统的响应效率，具有较强的实用性，强啊。</p>
<p><strong>PBFT 算法假设的环境比 Raft 算法更恶劣，Raft 算法只支持容忍故障节点，PBTF算法 还支持拜占庭节点(叛徒节点)。</strong></p>
<p><strong>PBFT 算法中假设系统中存在一个恶意节点</strong>，可以伪装成自身发生了故障或与其他节点的通信产生延迟，以便对整个系统造成最大的破坏。恶意节点造成的破坏在计算机上是受限的，<strong>不能破坏节点间用到的密码学技术</strong>。</p>
<p><strong>拜占庭将军问题</strong>是 Leslie Lamport 在10世纪80年代提出的一个假想问题，将军中有叛徒存在时，如何使得将军们<strong>在存在叛徒的非信任环境中建立对战斗计划的共识</strong>。</p>
<p><strong>共识算法的核心是在正常的节点间形成对网络形态的共识。</strong></p>
<p><strong>PBFT 使用了较少的预选将军数，运行非常高效，交易量和吞吐量比较高</strong>，如果有太多的将军，彼此交流信息的时候产生大量的消耗，性能会大幅下降。</p>
<h2 id="节点角色">节点角色</h2>
<p><strong>PBFT 算法是一种基于状态机复制的共识算法，节点角色有主节点和副本，两种角色可以相互转换。</strong></p>
<p><strong>Primary 节点和 Replica 的转换引入了视图(view)，在每个视图中，只有一个副本为主节点，每当主节点发生变更时，其所对应的视图会随之变化，视图在PBFT算法中起到了逻辑时钟的作用。</strong></p>
<p>PBFT 对每个副本提出了两个限定条件</p>
<ol>
<li><strong>所有节点必须是确定的，在相同状态下给定一组参数，最终的执行结果必须相同</strong></li>
<li><strong>所有节点的起始状态必须一致</strong></li>
</ol>
<p><strong>PBFT 最大的容错即节点数量是 (n-1)/3，Raft 最大容错节点是 (n-1)/2</strong></p>
<h2 id="算法容错">算法容错</h2>
<p>n 个节点，异常节点 f 个，正常节点有 n-f 个，只要收到 n-f 个就能做出决定。</p>
<p>n-f 个节点中也包括因为故障而不能及时回复的消息(非恶意)，正确的节点就是  n-f-f 个，为了一致性，正确的节点占多数，最坏的情况正确的节点数为 n-f-f&gt;f 个， n 最少为 3f +1。</p>
<h2 id="算法流程">算法流程</h2>
<p>PBFT 初始阶段，<strong>主节点由公式 p = v mod n 计算得出，p 是主节点编号，v 是视图编号，n 是集群中节点的个数</strong>。随着 v 的增长 p 不断变化(可优化)，算法采用轮流坐庄的方法。</p>
<p><strong>客户端发送消息 m 给主节点 p 时，主节点就开始了 PBFT 协议的三阶段，预准备、准备、提交</strong></p>
<p>预准备、准备阶段最重要的任务是<strong>保证同一个主节点发出的请求在同一个视图中的顺序是一致的</strong>，<strong>prepare 和 commit 阶段最重要的任务是保证请求在不同视图之间的顺序是一样的</strong>。</p>
<ul>
<li><strong>主节点</strong>收到客户端消息后，<strong>构造 pre-prepare 阶段的消息结构体</strong>&lt;PRE-PREPARE,v,n,d&gt;,m&gt; 并<strong>广播</strong>到集群中的其他节点
<ul>
<li>PRE-PREPARE 标示当前消息所处的协议阶段</li>
<li>v标识当前消息所在的视图编号</li>
<li>n为主节点广播消息的唯一递增编号</li>
<li>d为消息m的消息摘要</li>
<li>m为客户端发来的消息</li>
</ul>
</li>
<li><strong>副本收到主节点消息</strong>后，会对消息进行<strong>有效性检查</strong>，<strong>检查通过会将消息存储在本节点中</strong>，同时副本会进入Prepare 阶段，广播消息&lt;PrePARE,v,n,d,i&raquo;,其中 <strong>i 是本节点的编号</strong>，对消息的有效性检查包括以下几个方面
<ul>
<li>检查收到的消息体中<strong>消息摘要</strong> d ，是否和自己对消息 m 生成的<strong>消息摘要一致</strong>，确保消息的完整性</li>
<li>检查v是否和节点当前<strong>视图编号</strong>v一致</li>
<li>检查编号n是否在水线 h ～H 之间，避免恶意节点快速消耗可用编号</li>
<li>检查之间是否收到过相同编号 n 和 v，但是不同消息摘要 d 的消息</li>
</ul>
</li>
<li><strong>副本收到 2f+1 (包括自己)个一致的PREPARE 消息后，会进入 commit 阶段</strong>，并且<strong>广播消息&lt;COMMIT,v,n,D(m),i&gt;</strong> 给集群中的其他节点。再收到PREPARE消息后，副本<strong>同样会对消息进行有效性检查</strong>，检查的内容是副本收到主节点消息后进行检查的<strong>前三点</strong>。</li>
<li><strong>副本收到2f+1(包括自己)个一致的 COMMIT 消息后执行 m 中包含的操作</strong>，如果有多个m则按照编号n从小到大执行，执行完毕后发送执行成功的消息给客户端。</li>
</ul>
<h2 id="小总结">小总结</h2>
<p>消息通信在后面阶段越来越多，随着客户端消息或者集群节点的增加，集群整体消息感觉是呈线性锯齿状递增或趋于稳定，感觉这个抖动比较厉害，会有消息突刺的现象，<strong>有一种分代垃圾回收年轻代的感觉</strong>。</p>
<h2 id="日志压缩">日志压缩</h2>
<p>集群都会有日志，同步状态传递消息、集群状态变更的日志同步，日志总是不能无限增长的。</p>
<p>PBFT 算法**采用检查点(Checkpoint)**机制来压缩日志，本质是和Raft算法采用快照的方式清理日志是一样的，实现不同。</p>
<p><strong>检查点的含义是当前节点所处理的最新请求编号，大部分节点(2f+1) 已经共识完成的最大请求编号被称为稳定检查点(Stable Checkpoint)</strong>。</p>
<p>为每一个操作创建一个集群中的检查点的代价比较高，所以PBFT会<strong>为每常数个操作创建一个检查点</strong>，<strong>当这个检查点得到集群中多数节点的认可以后，就变成了稳定检查点，稳定检查点的日志之前的日志就成为了过时日志，可以删除</strong>，真好啊，比Raft 好。</p>
<p>当节点 i <strong>生成检查点后会广播消息</strong>&lt;<strong>CHECKPOINT</strong>,n,d,i&gt;，其中 n 是 最后一次执行的消息编号，d 是 n 执行后的状态及状态的摘要。每个节点收到 2f + 1 个相同的 n 和 d 的 CHECKPOINT 消息之后，<strong>检查点就变成了稳定检查点，同时删除本地编号小于或等于n的消息</strong>。</p>
<p>稳定检查点还有<strong>提高水位线(Water Mark)<strong>的作用，当一个稳定检查点被创建的时候，水位低位h 被修改为稳定检查点消息的编号n，水位高位 H 被修改为 h + k，k 是之前用于创建检查点的间隔常数。节点接受消息的编号 n 必须在 水线 h ～ H 之间，主要是</strong>为了防止一个失效节点使用一个很大的编号从而消耗消息的编号空间。</strong>&lt;? todo，<strong>消息的编号空间要求这么苛刻吗</strong>&gt;</p>
<h2 id="视图切换">视图切换</h2>
<p>PBFT 算法的正常流程是主节点广播客户端的消息请求到集群，如果主节点宕机，<strong>视图切换(View-change)机</strong>制提供了一种当主节点出现异常以后依然可以保证集群高可用的机制，<strong>通过计时器来进行切换避免副本长时间等待</strong>。</p>
<p>副本收到请求时，启动一个计时器，如果这个时候刚好有计时器在运行就重置计时器。当主节点宕机的时候，副本 i 会在当前视图 v 中超时，这个时候副本 i 就会触发视图切换的操作，将视图切换为 v + 1。</p>
<ul>
<li>
<p>副本 i 停止接受除检查点消息，视图切换和新视图变更(New View-change)以外的请求，</p>
<p>同时广播消息&lt;VIEW-CHANGE，v+1，n，C，P，i&gt; 到集群</p>
<ul>
<li>n 是节点 i 知道的最后一个稳定检查点的消息编号</li>
<li>C 是节点 i 保存的经过 2f + 1 节点确认的稳定检查点的消息集合</li>
<li>P 是保存了 n 之后所有已经达到 Prepare 阶段消息的集合</li>
</ul>
</li>
<li>
<p>当在视图 v + 1 中的主节点  p1 收到 2f 个有效的将视图变更为 v + 1的消息以后，p1就会广播消息 &lt;NEW-VIEW，v+1，V，Q&gt;</p>
<ul>
<li>V 是 P1 收到的、包括自己发送的视图切换的消息集合</li>
<li>Q 是 Pre-prepare 阶段的消息集合，PRE-PREPARE 消息是从 PREPARE 消息转换过来的</li>
</ul>
</li>
<li>
<p>从节点接受到NEW-VIEW消息后，验证签名，判断 V 和 Q 中的消息是否合法，验证通过后主节点和副本都进入视图 v + 1。当 p1 收到 2f + 1 个 VIEW-CHANGE 消息以后，可以确定稳定检查点之前的消息在视图切换的过程中不会丢失。</p>
<p>但是稳定检查点之后，下一个检查点之前的PREPARE消息可能会被丢弃。</p>
<p>在视图切换到 v +1 后，PBFT 算法会把旧视图中的 PREPARE 消息变为 PRE-PREPARE 消息然后广播。</p>
</li>
<li>
<p>如果集合 p 为空，广播消息 &lt;PRE-PREPARE，v+1，n，null&gt;</p>
</li>
<li>
<p>如果集合P不为空，广播消息&lt;PRE-PREPARE，v+1，n，d&gt;</p>
</li>
</ul>
<p><strong>视图切换机制最为重要的就是 C、P、Q 三个消息的集合，Pre-prepare 和 prepare 阶段最重要的任务就是保证同一个节点发出的请求在同一个视图中的顺序是一致的。</strong></p>
<ul>
<li>
<p>C 确保了视图变更的时候，稳定检查点之前的状态安全</p>
</li>
<li>
<p>P 确保了视图变更前，PREPARE 消息的安全</p>
</li>
<li>
<p>Q确保了视图变更后，P集合中的消息安全</p>
</li>
</ul>
<p>没看懂，但是找到了一个大佬的文章，写的很详细，周末在看<!-- raw HTML omitted --></p>
<p><a href="https://lessisbetter.site/2020/03/22/why-pbft-needs-viewchange/">周末看大彬老师的PBFT-VIEW-CHANGE</a></p>
<h2 id="主动恢复">主动恢复</h2>
<p>传统的PBFT 算法没有实现主动恢复的功能（1999年<a href="http://pmg.csail.mit.edu/papers/osdi99.pdf">初次发布</a>），主动恢复的节点会索取网络中其他节点的视图和最新的区块高度等信息来更新自身的状态，以此来保证与网络中其他节点一致(<a href="http://www.pmg.csail.mit.edu/papers/bft-tocs.pdf">2001年，PBFT-PR</a>)，<strong>Proactive Recovery</strong>。</p>
<p><strong>Raft 算法中采用 leader 记录每个 follower 提交的日志编号，再发送心跳包时携带额外的信息方式来保持同步，PBFT 采用了 视图协商的机制来保持同步。</strong></p>
<p>当<strong>节点日志落后太多</strong>，可能因为网络、磁盘等原因，当它收到主节点发来的消息后，<strong>对消息水线的检查就会失败</strong>，导致<strong>计时器超时</strong>，从而<strong>发送视图变更的请求</strong>，但是只有自己一个节点发送视图变更的请求，<strong>请求消息的数量达不到 2f + 1，使得本来正常运行的节点退化为恶意节点</strong>，尽管时非主观原因导致的，但是为了尽可能保证集群的稳定性，PBFT 加入了视图协商机制。</p>
<p><strong>当一个节点多次尝试视图变更失败后，就会触发视图协商机制来同步集群数据。</strong></p>
<ul>
<li>新增节点 Replica Max 发起 NegotiateView 消息给其他节点</li>
<li>集群中其他节点收到消息以后，返回自己的视图信息、节点ID和节点总数N</li>
<li>新增节点 Replica Max 收到 2f + 1 个相同的消息后，如果 2f + 1 个视图编号和自己不同，则同步视图信息和N</li>
<li>Replica Max 同步完视图信息后，发送 RecoveryToC heckPoint 消息，其中包含自身的检查点信息</li>
<li>其他节点收到 RecoveryToCheckpoint 消息后将自身最新的检查点信息返回给 Replica Max</li>
<li>Replica Max 2f + 1 个消息后，更新自己的检查点到最新，更新完成以后向正常节点索要 P、Q 和 C 的信息(PBFT 算法中 Pre-prepare 阶段、Prepare 阶段和 Commit 阶段的数据)同步至全网最新状态。</li>
</ul>
<h2 id="节点配置更新">节点配置更新</h2>
]]></content>
        </item>
        
        <item>
            <title>The Raft Consensus Algorithm</title>
            <link>https://liguangchang.cn/posts/distributed/distributed-raft/</link>
            <pubDate>Fri, 15 Oct 2021 00:39:41 +0800</pubDate>
            
            <guid>https://liguangchang.cn/posts/distributed/distributed-raft/</guid>
            <description>历史 Raft 算法是 2013 年由斯坦福大学的 Diego Ongaro 和 John Ousterhout 提出的一种适用于非拜占庭容错环境下的分布式一致性算法，用于替代复杂的 Paxos 算法，安全性更高。 Raft 算法能在为</description>
            <content type="html"><![CDATA[<h2 id="历史">历史</h2>
<p>Raft 算法是 2013 年由斯坦福大学的 Diego Ongaro 和  John Ousterhout 提出的一种适用于非拜占庭容错环境下的分布式一致性算法，用于替代复杂的 Paxos 算法，安全性更高。</p>
<p>Raft 算法能在为集群之间部署有限状态机提供一种通用方法，确保计算机集群内的任意节点在某种状态上保持一致，保证在一组服务器在执行一组操作，最后得到一致的结果。</p>
<h2 id="复制状态机">复制状态机</h2>
<p><strong>Repilcated State Machine，RSM</strong></p>
<p>一致性算法是在复制状态机的背景下提出，一致性算法中，一组服务器的状态机是拥有相同状态的副本，即使部分节点宕机，一组服务器仍然能够继续提供服务。</p>
<p>分布式系统中，复制状态机被用来解决各种容错问题。</p>
<p>一般通过复制日志来实现复制状态机，<strong>每个服务器存储者一份包括一系列命令的日志，状态机（State Machine）会按照顺序执行这些命令</strong>。每份日志包含相同的命令，并且顺序相同，每个状态机都会处理相同的命令序列，状态机是确定性的，处理相同的命令，最终会得到相同的结果。</p>
<p>每个服务器上的<strong>一致性模块（Consensus Module）</strong>,接受来自客户端的命令，把命令添加到自己的日志中，状态机按照顺序处理，并将结果返回给客户端，即使有部分节点故障，命令被正确复制，服务器集群还是整体可靠。</p>
<h2 id="算法流程">算法流程</h2>
<ol>
<li>首先在集群中选择一个领导者负责日志的管理</li>
<li>领导者从客户端收到请求后会将请求以日志的形式复制给其他跟随者，并且在保证安全的时候通知其他 Follower 执行日志中的命令，将状态应用到各自的状态机中</li>
<li>Raft 强化了 Leader 的地位，<strong>数据只会从 Leader 流向其他 Follower</strong></li>
<li>当 Leader 故障，其他节点会重新选举新的 Leader ,然后重复日志同步</li>
</ol>
<p>重复的过程被分为三个独立的模块，<strong>领导者选举、日志复制、异常处理</strong></p>
<h2 id="leader选举">Leader选举</h2>
<p>Raft 算法中，节点任意时刻只能处于 Leader、Candidate、Follower 其中一种状态，初始化时所有的节点都处于跟随者的状态，Follower 通过心跳信息来感知其他节点。</p>
<p>通常情况下，集群只有一个Leader ，且其他节点全部都是Follower，Follower 都是被动的，不会发送任何请求，只会简单的响应来自Leader 和 Candidate 的请求，</p>
<ul>
<li>
<p>节点在启动时，都处于 Follower 状态，一段时间内没有收到来自 Leader 的心跳信息，就会从 Follower 转变为候选者，发起选举。如果收到包含自己的多数选票则转变为 Leader。</p>
</li>
<li>
<p>如果发现其他节点比自己更新，则切换到 Follower 状态。<strong>为了确定其他节点比自己更新，Raft 引入了任期 （Term） 的概念。</strong></p>
</li>
<li>
<p>初始化时，Term 为0，当有节点当选 Leader 时，Term 更新为1。</p>
</li>
<li>
<p>新 Leader 选出后，新的 Term 在之前的 Term 基础之上 +1。</p>
</li>
<li>
<p>当节点从 Follower 转变为 Candidate 时，Term 也要 +1。</p>
</li>
<li>
<p><strong>节点间通信会交换当前 Term</strong>，如果一个节点的 Term 比其他节点小，该节点会把自己的任期号更新为较大的。</p>
</li>
<li>
<p>如果 Candidate/Leader 发现自己的 <strong>Term 比其他节点小</strong>，会立刻退回到 Follower 状态。</p>
</li>
<li>
<p>如果一个节点收到<strong>过期的Term会直接拒绝</strong>不进行处理。</p>
</li>
</ul>
<p><strong>Term 在Raft 中起到了逻辑时钟的作用</strong></p>
<h2 id="candidate-成为leader-的要素">Candidate 成为leader 的要素</h2>
<ul>
<li>获取集群多数节点的同意</li>
<li>不存在比自己 term 高的 candidate</li>
<li>不存在其他 leader</li>
</ul>
<h2 id="选举流程">选举流程</h2>
<p>Raft 使用心跳机制来触发 leader 选举流程，领导者<strong>周期性地向所有 follower 发送心跳信息</strong>，每个节点只要能收到 leader / candidate 发来的心跳信息就会一直保持 following 状态。</p>
<p>每个节点本身都有自己的选举超时时间，如果超过这个超时时间没有收到任何消息，就会假设网络中没有 leader，这个时候就会改变自己的状态为  candidate，同时增加自己的 Term，开始竞选 leader。</p>
<p>每个节点在竞选 leader 时回首先给自己投一票，然后并行向其群中其他节点发送请求投票结果，如果其他节点在这轮选举中没有投过票就会给它投一票，最终得到三种结果，当选成功，当选失败，无法确定leader。</p>
<ul>
<li>节点增加自己的 Term ，转换为 candidate</li>
<li>投自己一票，给其他节点发送自己的投票请求</li>
<li>等待其他节点回复
<ul>
<li>赢得选举，当选 leader</li>
<li>被告知其他节点当选leader，自己退回follower</li>
<li>选举超时后没有收到足够多的票，重复选举</li>
</ul>
</li>
</ul>
<p>连续选举失败，出去系统本身原因，就是算法本身达到了不可恢复的状态。为了跳出这样不可用的状态，<strong>candidate 会随机从固定时间区间中选择一个时间作为选举超时时间</strong>，这个每个节点每次等待选举超时时间都不一样，选举超时时间短的节点会有更大的机会获得更多的选票而当选 leader，就减少了因为选票被瓜分而导致选举失败的可能性。</p>
<h2 id="日志复制">日志复制</h2>
<p>leader 负责在任期内的日志复制工作，保证节点一致性。</p>
<p><strong>日志信息表明了 term 任期的 leader append 的 索引为 index 的 什么类型的日志</strong>。（<strong>todo 看etcd 实</strong>现）</p>
<p><strong>相同的初始状态 + 相同的输入 = 一致的最终状态</strong></p>
<p>当客户端请求到集群，如果 follwer 收到，将会把请求转发给 leader，由 leader 统一处理。leader 调度请求，顺序的告知所有 follower 来保证所有的节点状态一致。</p>
<ul>
<li>leader 收到请求打包成日志条目</li>
<li>leader 并行发送日志条目到集群所有节点</li>
<li>leader 收到大多数 follower 收到条目的回复</li>
<li>leader 应用日志条目里面的命令到自己的状态机中(执行命令)</li>
<li>leader 回复 follower ,并让他们执行日志中的命令，达到和自己一致的状态</li>
<li>Log match ，follower 收到消息时，会判断term、index 保证append 顺序一致</li>
</ul>
<p>每个日志条目中，除了要执行的命令还包括 leader 的 term，用于处理异常情况。当日志被复制到大多数节点时，系统即可向客户端返回成功的消息，一旦系统返回了结果，就必须保证系统在任何异常情况都不会发送回滚消息。</p>
<h2 id="brain-split">Brain Split</h2>
<p>在一个任期内最多有一个 leader 被选出，有多余的 leader 被选出成为脑裂(Brain Split)。</p>
<p>同一时刻，集群内有多个 leader ,旧的 leader 在一段时间内可能不会知道新的 leader 已经被选举出来，旧的 leader 可能会读取处陈旧的数据，如果客户端进行写操作，可能会出现数据的覆盖或者丢失。</p>
<p>Raft 通过两点保证不会出现脑裂</p>
<ul>
<li><strong>一个节点在某一个任期内最多只能投一票</strong></li>
<li><strong>只有获得大多数投票才能成为 leader</strong></li>
</ul>
<p>这样保证了同一时间内只有一个 leader，当一个节点崩溃了一段时间后，他的状态已经落后其他节点很多，突然恢复被选举为 leader，这个时候，客户端发来的请求经过复制就会出现集群状态机状态不一致的情况。</p>
<p>其他共识算法会同步落后的日志给 leader，在复制到其他节点，raft 设计者认为这样会增加算法的复杂性，直接放弃了这种方法，<strong>采用拒绝投票给日志没有自己新的节点的方法</strong>，这样<strong>保证了状态比大多数节点落后的节点不会当选 leader</strong>。</p>
<p>比较日志中的<strong>最后一个日志条目的索引值和任期号</strong>，定义谁的日志新。term 大的当选，term 一样，索引值大的日志新。</p>
<h2 id="可用性的时间要求">可用性的时间要求</h2>
<p>Raft 时间的要求</p>
<ul>
<li>服务器故障时间必须比消息交换的时间长，否则每当一个节点要收集足够多选票的时候宕机了，新一轮的投票会重复这个过程，导致无法在有限的时间内选出领导者，</li>
<li>广播的时间必须小于选举超时时间一个数量级，这样领导者才能发送稳定的心跳消息阻止跟随者进入候选者状态。</li>
<li>当 leader 崩溃后，整个系统在选举超时时间中不可用，所以平均故障间隔时间要大于选举超时时间几个数量级，这样系统的可用性才比较高</li>
</ul>
<p><strong>一般，广播时间 10ms，选举时间超时时间 300ms，服务器平均故障时间大于1个月。</strong></p>
<h2 id="自动变更配置">自动变更配置</h2>
<p>硬件故障，集群负载发生了变化，需要集群中的节点数量动态地增加/减少。</p>
<p>从旧配置直接变更到新配置的各种方法都是不安全的，很容易出现脑裂。</p>
<p><strong>获取半数以上的投票在旧的配置和新配置之间投票数肯定是不同的，必然有一个时刻，可同时满足新、旧节点的选举要求，就会出现脑裂情况。</strong></p>
<p>raft 采用了<strong>两阶段提交</strong>来保证安全的变更日志。</p>
<h2 id="配置变更流程">配置变更流程</h2>
<ol>
<li>当leader 收到一个改变配置从 c_old 到 c_new 的请求时，首先会合并新旧配置 merge(c_old，c_new)，并且保存到自己的日志条目中，然后复制到集群中的其他节点，c_new 提交之前，<strong>所有节点的决定都会基于 merge(c_old，c_new) 的配置做决定。</strong></li>
<li>在 merge(c_old，c_new) 被提交之后，leader 创建一条 c_new 的配置复制到集群，c_new 被提交之后，旧配置指定的节点就变得无关紧要，在集群中不可见后就可以直接从集群中移除。</li>
</ol>
<h3 id="配置变更过程中异常情况">配置变更过程中异常情况</h3>
<ul>
<li>
<p><strong>节点宕机</strong></p>
<p>如果leader 在复制包含配置文件的日志时候崩溃，follower 的配置状态处于 merge(c_old，c_new)  /  c_old，无论什么状态，c_new 都不会单方面作出决定。<strong>Leader Completeness</strong>属性保证了只有拥有 merge(c_old，c_new) 日志的节点可以被选为 leader。</p>
</li>
<li>
<p><strong>空白节点加入</strong></p>
<p>新节点本省没有日志存储，是无法提交集群中的任何一个日志的，需要一段时间来追赶。为了避免这种可用时间间隔太长的问题，采取了<strong>节点静默加入集群的方法，节点加入集群后没有投票权，只能同步日志，当心节点已经可以跟上集群日志的时候在投票加入集群</strong></p>
</li>
<li>
<p><strong>旧节点干扰</strong></p>
<p>c_new 被提交后，就需要移除不在c_new 中的节点，<strong>节点被移除后就接受不到 leader 的心跳消息</strong>，这个时候这些节点认为 leader 可能出现了故障就发起选举，正常执行的 leader 收到投票请求后就会退回到 followering 等待新领导者被选出，虽然最终选出了正确的 leader，但是频繁选举会扰乱集群的可用性。</p>
<p>raft 采用了<strong>最小选举超时时间的机制</strong>，当服务器在当前最小的选举超时时间内收到一个请求投票的请求时，不会更新当前的任期号或投出选票，这样就避免了频繁的状态切换。</p>
</li>
<li>
<p><strong>领导者不在集群内</strong> (fixme 不清楚为什么会leader不在新集群中，强行故障?)</p>
<p>如果leader不在新的集群中，当配置文件从 merge(c_old，c_new) 变更到 c_new 时，leader 不在 c_new 时，这个时候就会在<strong>一段时间内发生旧节点管理新集群</strong>的情况。</p>
<p><strong>Raft 在提交 c_new 成功时，leader 的状态变为 followering 就能让领导者在新集群中产生了，触发选主，当然还是要获得半数投票，但是不一定切主。666</strong></p>
</li>
</ul>
<h2 id="日志压缩">日志压缩</h2>
<p>Raft 运行过程中，日志会不断累积，raft <strong>采用快照的方法来压缩日志</strong>，快照时间点的日志全部丢弃，nb，我以为会是lsm 引擎的多层次方式。</p>
<p>每个服务器根据已经提交的日志，会独立创建快照，快照包含</p>
<ul>
<li>状态机最后应用的日志</li>
<li>状态机最后应用日志的Term号</li>
<li>状态机最后应用的配置文件内容</li>
</ul>
<p>Leader 周期性的发送一些快照给 follower,如果与 leader 保持同步的 follower 已经提交了快照的内容，会<strong>直接丢弃收到的快照</strong>，运行缓慢或新加入的节点不会有这些内容，就会接受并应用到自己的状态机中。</p>
<h2 id="节点异常">节点异常</h2>
<ul>
<li>
<p><strong>Leader 不可用</strong></p>
<ol>
<li>leader 和 follower 之间的 heartbeat 异常，导致 follower 发生 election timeout 时</li>
<li>follower 状态变成 candidate ，向其他 follower 发起投票</li>
<li>获得半数投票后，作为新的 leader，步进数 + 1，向follower同步 日志</li>
<li>如果之前的 leader 再次加入集群，两个 leader 比较步进数，步进数低的 leader 将切换自己的状态为 follower</li>
<li>较早之前的leader 中的不一致日志将被清除，并与现在的 leader 中的日志保持一致</li>
</ol>
</li>
<li>
<p><strong>Follower 不可用</strong></p>
<p>集群中的日志内容始终是从 leader 节点同步的，只要这一个节点再次加入集群时重新从 leader 节点处复制日志即可</p>
<ol>
<li>Follower 节点异常，不再同步日志以及接收 heartbeat</li>
<li>Follower 节点恢复，重新加入集群，日志接收同步现有的 leader</li>
</ol>
</li>
<li>
<p><strong>多个 Candidate / Leader</strong></p>
<p>通常是由于数据传输不畅导致，多个 leader 发生在节点隔离，多个 candidate 出现在未选出 leader 的启动初期</p>
<ol>
<li>初始状态，所有的节点都处于 follower 状态</li>
<li>两个节点同时成为 candidate 发起选举，但是都得到了少部分 follower 的接收投票，继续向其他 follower 询问</li>
<li>投过一轮的 follower 会拒绝 candidate 的询问</li>
<li>candidate 也会询问其他 candidate，步进数相同的情况下，candidat 会拒绝其他candidate 的请求</li>
<li>第一轮未选出 leader ，candidate将随机一个等待间隔 (150ms-300ms) 再次发起投票</li>
<li>Candidate 得到半数以上的 follower 的接受，candidate 将成为 leader</li>
<li>其他 candidate 也将再次发起投票，由于已经选出 leader，candidate 将收到拒绝接受的投票</li>
<li>Candidate 被多数节点拒绝之后，并且已知集群中已经存在 leader 后，candidat 将停止投票询问请求，切换为 follower，从 leader 同步日志</li>
</ol>
</li>
</ul>
<p><strong>Raft 通过一系列机制保证了在非拜占庭容错环境下正常的工作，即使出现了网络延迟、节点宕机或者选举冲突的情况下，依然可以保证集群的可用性，通过对节点颁发证书也可以保证节点的可信</strong>。</p>
]]></content>
        </item>
        
        <item>
            <title>Distributed leader election</title>
            <link>https://liguangchang.cn/posts/distributed/distributed-election/</link>
            <pubDate>Thu, 14 Oct 2021 00:00:39 +0800</pubDate>
            
            <guid>https://liguangchang.cn/posts/distributed/distributed-election/</guid>
            <description>分布式系统集群中，选举出来的 leader 节点负责对其他节点的协调和管理，保证集群内节点有序运行和数据的一致性，记录一些选主的算法。 Bully 在所有存活的节点中</description>
            <content type="html"><![CDATA[<p>分布式系统集群中，选举出来的 leader 节点负责对其他节点的协调和管理，保证集群内节点有序运行和数据的一致性，记录一些选主的算法。</p>
<h3 id="bully">Bully</h3>
<p><strong>在所有存活的节点中，选取ID最大的节点作为主节点</strong>。(默认前提:每个节点知道其他节点的ID)</p>
<ul>
<li>
<p>节点角色</p>
<p>节点的角色有 <strong>主节点和普通节点</strong>，初始化时所有节点平等，都是普通节点，都有成为主节点的权利，主节点只有一个，当且仅当主节点故障或者与其他节点失去联系后，才会重新选主。</p>
</li>
<li>
<p>选举涉及到的消息</p>
<ul>
<li>Election 消息，用于发起选举</li>
<li>Alive 消息，对 Election 的应答</li>
<li>Victory 消息，竞选成功的主节点向其他发送宣誓主权的消息</li>
</ul>
</li>
<li>
<p>选举过程</p>
<ol>
<li>集群内每个节点判断自己的ID是否为当前存活节点的最大ID，如果是，向其他节点发送 Victory，宣示主权</li>
<li>当前节点的ID如果不是当前存活节点中最大ID，向比自己ID大的节点的所有节点发送 Election 消息，等待其他节点回复</li>
<li>一定时间内，当前节点没收到其他节点的回复Alive消息，则认为自己为主节点，向其他节点发送Victory 消息，宣誓自己成为主节点</li>
<li>如果收到比自己ID大的节点发送的Alive消息，则等待其他节点发送Victory消息</li>
<li>如果收到比自己ID小的节点发送的Election消息，则回复Alive消息，告知其重新选举</li>
</ol>
<p>普通节点变成主节点的选举过程，不参与选举(不向对其他人投票)，只会同步其他节点victory 消息，有一点倚老卖老的感觉。</p>
<p>如果对集群内节点递增编号，从1到n，集群全部存活的情况下，最后最大的id n 成为了主节点</p>
<p>那么每一步选举产生的消息量</p>
<ol>
<li>n 节点发送 n-1 条 victory 消息</li>
<li>n-1 个节点选举比自己ID打的节点，发送 (n^2 - n)/2 条 Electoion 消息</li>
<li>最大ID节点 n ，再次发送 victory 消息，宣誓主权</li>
<li></li>
<li>n-1 个中间节点会收到ID大于自己ID的节点发送 Alive 消息 (n2+n)/2</li>
</ol>
<p>所有节点之间通信量还是很大的，选举过程遇到故障节点，通信量、和选举时间都会随之增加。</p>
<p>Bully 算法选举速度快，简单易实现，但是每<strong>个节点需要维护集群内所有节点的信息</strong>，<strong>任意一个比当前主节点ID大的新节点或节点故障后恢复加入集群的时候，都可能会出发重新选举，成为新的主节点</strong>，如果频繁退出、加入集群，就会导致频繁切主。</p>
<p><strong>MongoDB 的副本集故障转移功能，就是采用 Bully 算法，采用节点的最后操作时间戳来表示ID，时间戳最新的阶段ID最大。</strong></p>
</li>
</ul>
<h3 id="raft">Raft</h3>
<p><strong>少数服从多数，获得投票最多的节点成为主节点。</strong></p>
<ul>
<li>
<h6 id="节点角色">节点角色</h6>
<ul>
<li>Leader，主节点，同一时刻只能有一个 leader</li>
<li>Candidate，候选节点，每个节点都可以成为 Candidate，Candidate 节点才有可能成为 Leader</li>
<li>Follower，Leader 的跟随者，不能发起选举</li>
</ul>
</li>
<li>
<p>选举流程</p>
<ul>
<li>初始化时，所有节点都是 Follower</li>
<li>开始选举，<strong>所有节点从 Follower 转化为 Candidate ，并向其他节点发送选举请求</strong>。</li>
<li>其他节点根据<strong>收到的选举先后顺序</strong>，回复是否同意成为 Leader （<strong>每一轮选举中，一个节点只能投出一票</strong>）。</li>
<li>若某一个节点<strong>获得超过一半的投票</strong>，则转化为 Leader，<strong>其他节点从 Candidate 降为 Follower</strong> ，Leader 与 Follower 节点之间会定期发送心跳包，检测主节点是否存活。</li>
<li>Leader 任期到了(发现其他节点开始下一轮选举)，<strong>Leader 节点的状态转化为 Follower</strong> ，进入新一轮选主（<strong>正常周期性选举</strong>）。</li>
</ul>
<p>Raft 选举速度快，易于实现，要求节点可以相互通信，并且要获得半数以上的投票数才能选出 Leader，通信量大，<strong>稳定性比Bully 好，新节点加入或者节点故障恢复后，会触发选主，但是不一定会切主，除非新节点货故障后恢复的节点获得半数以上投票。</strong></p>
</li>
</ul>
<p>Bully 像是不公平的选主，Raft 像是公平的选主，下面的 ZAB 像是可以控制的优先队列，秒啊。</p>
<h3 id="zab">ZAB</h3>
<p><strong>具有优先级的民主选举算法</strong></p>
<p>Zookeeper Atomic Broadcast ，为了Zookeeper 实现分布式协调功能设计的，相对于Raft <strong>增加了通过节点ID和数据ID作为参考选主</strong>，<strong>节点ID和数据ID越大，表示数据越新，优先成为主，尽可能保证数据的最新性</strong>。</p>
<p>这样可以通过水平拓展机器的数量来控制迁移主节点，Raft 主节点可能水平拓展也不会改变主节点，人类总喜欢去掌控所有能够掌控的。</p>
<ul>
<li><strong>节点角色</strong>
<ul>
<li><strong>Leader 主节点</strong></li>
<li><strong>Follower 跟随者节点</strong></li>
<li><strong>Observer 观察者，无投票权</strong></li>
</ul>
</li>
<li><strong>选举过程状态变化</strong>
<ul>
<li>Looking 状态，选举状态，当节点处于该状态，会认为当前集群没有 Leader，因此自己进入选举状态</li>
<li>Leading 状态，领导者，已经选出主，当前节点为Leader</li>
<li>Following 状态，跟随着状态，集群有主，其他非主节点状态更新为Following，表示对 Leader 的追随</li>
<li>Observing 状态，观察者模式，表示当前节点为 Observer，持观望态度，没有投票权和选举权</li>
</ul>
</li>
</ul>
<p>投票过程中，每个节点都有一个唯一的三元组（server_id，server_zxID，epoch）</p>
<ol>
<li><strong>server_id 表示节点的唯一ID</strong></li>
<li><strong>server_zxID 表示本节点存放的数据ID，数据ID越大表示数据越新，选举权重越大</strong></li>
<li><strong>epoch 表示当前选举轮数，一般用逻辑时钟表示</strong></li>
</ol>
<p>ZAB 选举算法的核心是少数服从多数，ID大的节点优先成为主，选举过程中通过 <strong>(vote_id，vote_zxID)</strong> 来表明投票给哪个节点，<strong>vote_id</strong> 表示被投票节点的ID，<strong>vote_zxID</strong> 表示被投票节点的服务器 zxID。</p>
<p><strong>选主原则: server_zxID 最大者称为 Leader，若 server_zxID 相同，server_id 最大者成为 Leader</strong></p>
<ul>
<li><strong>选举过程</strong>
<ul>
<li>系统启动，所有节点处于 Looking 状态，epoch =1，zxID =0，每个节点都推选自己，将投票信息广播出去</li>
<li>根据规则，节点的 zx_ID 相同，推选 server_id 最大者为 leader，其他节点修改 vote_id 为最大节点ID，重新广播</li>
<li>最大ID 节点当选 leader ，处于 Leading 状态，维持和其他节点的心跳，其他节点处于 Following 状态</li>
</ul>
</li>
<li>特征
<ul>
<li>算法性能高、广播消息，n 个节点组成的集群，同时广播，集群内通信量为 n * (n-1) 个消息，容易产生广播风暴</li>
<li>除了选举节点，还增加了对比节点ID和数据ID，需要知道所有节点的ID和数据ID，选举时间相对较长</li>
<li>选举稳定，当有新节点加入或节点故障恢复，会触发选主，但是不一定切主，除非节点数据数据ID和节点ID最大，并且获得投票过半，才会导致切主。</li>
</ul>
</li>
</ul>
<h3 id="总结">总结</h3>
<table>
<thead>
<tr>
<th></th>
<th>Bully</th>
<th>Raft</th>
<th>ZAB</th>
</tr>
</thead>
<tbody>
<tr>
<td>消息类型</td>
<td>alive</td>
<td>同意/不同意选举</td>
<td>&lt;epoch,vote_id,vote_zxID&gt;</td>
</tr>
<tr>
<td>选举机制</td>
<td>倾向ID更大节点（霸道）</td>
<td>收到过半投票</td>
<td>倾向让数据最新/ID最大的节点</td>
</tr>
<tr>
<td>选举过程</td>
<td>Leader 无响应/ID最大节点恢复故障时</td>
<td>Candidate可以竞选，每个Follow只有一次投票权</td>
<td>可以多次投票，根据三元组选主</td>
</tr>
<tr>
<td>选举时间</td>
<td>短</td>
<td>较短</td>
<td>较长</td>
</tr>
<tr>
<td>性能</td>
<td>低</td>
<td>高</td>
<td>较高</td>
</tr>
</tbody>
</table>
]]></content>
        </item>
        
        <item>
            <title>分布式协调、同步(中心化)</title>
            <link>https://liguangchang.cn/posts/distributed/distributed-coordination/</link>
            <pubDate>Mon, 11 Oct 2021 00:23:19 +0800</pubDate>
            
            <guid>https://liguangchang.cn/posts/distributed/distributed-coordination/</guid>
            <description>Distributed Mutual Exclusion 分布式互斥: 分布式系统里面排他性的资源访问方式，被互斥访问的共享资源就是临界资源(Critical Resource)。 集中式算法/中央</description>
            <content type="html"><![CDATA[<h2 id="distributed-mutual-exclusion">Distributed Mutual Exclusion</h2>
<p>分布式互斥: 分布式系统里面排他性的资源访问方式，被互斥访问的共享资源就是临界资源(Critical Resource)。</p>
<h2 id="集中式算法中央服务器算法">集中式算法/中央服务器算法</h2>
<p>引入协调者程序，在每个程序在需要访问临界资源时，先给协调者发送请求，没有程序占用就直接授权访问，否则进入队列排队。有程序释放了资源，通知协调者取出队列中的候选者，给它授权，队列中第一个最为候选者被授权，占用临界资源。</p>
<p>协调者代表集中程序或中央服务器，每个程序完成一次临界资源占用，需要和协调者交互三次。</p>
<ol>
<li>客户端程序向协调者申请占用</li>
<li>协调者允许客户端占用</li>
<li>客户端释放资源，通知协调者</li>
</ol>
<p>集中式算法简单、交互量少，客户端只和协调者通信，但是，协调者会成为瓶颈并且不可靠。</p>
<ul>
<li>
<p>通信量和客户端增长线性正比，需要占用资源的客户端越多，客户端和协调者之间的通信量也就越多</p>
</li>
<li>
<p>单点故障，协调者故障，临界资源全部无法访问，整个系统不可用。</p>
</li>
</ul>
<p>通过对中央服务器进行主备来保证可用，故障后备份机可以直接顶上来，数据一致的情况下可以实现分布式协调功能。</p>
<h2 id="协商算法">协商算法</h2>
<p>当客户端要占用临界资源，向系统中的其他程序发送一条请求消息，接收到所有客户端同意消息后，才可以占用临界资源，以民主协商的形式占用资源。</p>
<p>这样<strong>一个客户端占用一次临界资源要和集群内其他节点(客户端)都询问一次</strong>，<strong>接收到其他客户端的ACK后，才可以占用临界资源</strong>，这样一来一回，就是2*(n-1) 次通信，通信量随着集群内节点的数量呈指数增长。</p>
<h3 id="问题">问题</h3>
<p>以上两种算法，依据队列排队、全票协商的机制，能够很方便的实现安全的占用资源，但是性能和可用性都很低。</p>
<ol>
<li>集群内节点拓展，通信量增长容易引起“信令风暴”，类似于单机环境JAVA SYNC大量锁升级后总线风暴，中央协调者压力比较大，如果出现瓶颈，会导致可用性降低甚至不可用。</li>
<li>客户端节点故障不可用，需要占用的客户端节点等不到其他所有的节点ACK，整个系统hang住导致不可用，相比于中央协调者故障可用性更低。</li>
</ol>
<h3 id="改进">改进</h3>
<p>针对上面第二点优化，如果检测到集群中节点故障，直接忽略，不再等待该故障节点的ACK，但是对其他每一个节点进行故障检测又是一个复杂的功能点。</p>
<p>上述两种算法，可以在集群中节点比较少、临界资源访问量少并且都相对比较可靠的情况下使用。</p>
<h2 id="令牌环算法">令牌环算法</h2>
<p>集群内节点构成一个环，令牌按照约定好的方向在集群节点中传递，收到令牌的节点可以占用资源，释放完资源将令牌继续向后传递，如果当前节点不需要访问临界资源，继续将令牌向后传递。是一种比较公平的算法，适合规模小，节点占用临界资源高、占用时间短的场景。</p>
<p>典型应用场景:无人机通信(通信渠道是临界资源)，前几天郑州的无人机掉下来了，被人用信号恶意干扰了，我的天。</p>
<h3 id="缺点">缺点</h3>
<ol>
<li>环内节点都要参与传递令牌，无论是否想要占用资源，如果只有少量节点需要占用资源，将会有很多无效的传递通信，资源浪费，并且真正需要占用资源的节点等待周期较长。</li>
<li>单点故障，直接跳过传递到下一个节点，最简单就是维护前后节点，也是构成环的基本条件，进一步保障可用性，可以维护全量节点信息，防止接连节点的连接故障。或者增加RST，超时断开链接进行复位，重新开始。</li>
</ol>
<h2 id="总结">总结</h2>
<p>上述几种分布式协调算法都是比较简单，适合规模比较小的场景，整体的可用性需要靠每一个节点的可用来保障。</p>
<p>可以说是强行往分布式上靠，感觉和单机环境下的多线程没什么区别，单机多线程下也有公平、非公平、锁饥饿、锁升级、锁降级、总线风暴。。。</p>
<p>上述算法也可以通过增加权重、RST重开、超时/故障检测、Heartbeat+HAProxy 进一步提高可用性、效率，权重像钟表的时分秒的分层次的时间轮算法可以避免OS空转浪费资源。&lt;TODO这一块待研究&gt;</p>
<p>总之，单点、有中心的架构就像墨菲定律，总会故障，还会有瓶颈。</p>
]]></content>
        </item>
        
        <item>
            <title>单机-&gt;分布式</title>
            <link>https://liguangchang.cn/posts/distributed/distributed-introduction/</link>
            <pubDate>Sat, 02 Oct 2021 04:06:19 +0800</pubDate>
            
            <guid>https://liguangchang.cn/posts/distributed/distributed-introduction/</guid>
            <description>记录分布式由单机发展到分布式集群的一些驱动因素和存在的问题，十一回家路上看了一夜，凌晨四点到家编辑一下。。。 单机模式 所有应用程序和数据均部署</description>
            <content type="html"><![CDATA[<p>记录分布式由单机发展到分布式集群的一些驱动因素和存在的问题，十一回家路上看了一夜，凌晨四点到家编辑一下。。。</p>
<h2 id="单机模式">单机模式</h2>
<p>所有应用程序和数据均部署在一台电脑或服务器上，由一台计算机完成所有的处理。</p>
<p>单机模式，性能受限，存在单点失效问题</p>
<h2 id="数据并行分布模式">数据并行/分布模式</h2>
<p>解决单机模式存在的问题，出现了并行计算。</p>
<p>并行计算采用<strong>消息共享模式</strong>使用<strong>多台计算机并行运行或执行多项任务</strong>，核心原理是每台计算机上执行相同的程序，将<strong>数据进行拆分</strong>放到不同的计算机上进行计算。</p>
<p>将应用和数据分离，多个应用进程处理一份数据或者把数据再进行拆分，针对不同的数据进行并行处理。</p>
<p>这样就可以利用多台应用处理更多的请求，可以解决单机的计算性能瓶颈，但是无法提供请求的性能、降低时延。</p>
<h3 id="需要处理的点">需要处理的点</h3>
<ul>
<li>大量请求需要负载均衡到多台应用上【需要负载均衡器以及链路追踪】</li>
<li>请求量大时，数据库IO又成为了新的瓶颈【数据库采取主从方案，保证数据同步一致性达到读写分离的效果】</li>
<li>热点数据，数据库压力依然很大【将热点数据进行缓存】</li>
</ul>
<h3 id="耗时请求依然耗时">耗时请求依然耗时</h3>
<p><strong>数据分布并行模式可以解决性能问题，耗时复杂的请求依然是耗时的，对提升单个任务的执行性能及降低时延无效。</strong></p>
<h2 id="数据并行分布模式-1">数据并行/分布模式</h2>
<p>任务并行指的是，将<strong>单个复杂的任务拆分为多个子任务</strong>，从而使得多个子任务可以在不同的计算机上并行执行，提高单个耗时复杂的请求计算速度。</p>
<p>设计、拆分比较复杂，需要做到可拓展和可维护管理。</p>
<h2 id="分布式">分布式</h2>
<p>分布式就是<strong>将相同或相关的程序运行在多台计算机上，从而实现特定目标的一种计算方式</strong>。</p>
<p>产生分布式的最主要驱动力量，是对于性能、可用性及可扩展性的不懈追求。最终的实现就是用更多的机器处理更多的数据和任务。</p>
<h2 id="指标">指标</h2>
<h3 id="性能指标">性能指标</h3>
<p>指标在一定的标准下得到的平均值进行对比或者统计来看才有意义。</p>
<ul>
<li>
<p>吞吐量（Throughput）一定时间内可以处理的任务数，</p>
<ul>
<li>QPS 每秒查询数，通常对应读操作</li>
<li>TPS 每秒事务数，通常对应写操作</li>
<li>BPS 每秒比特，体现每秒处理的数据量</li>
</ul>
</li>
<li>
<p>响应时间（Response Time），系统响应一个请求或输入的时间，主要体现在时延</p>
</li>
<li>
<p>完成时间（Turnaround Time），系统真正处理完成一个请求花费的时间，任务并行的目的就是缩短任务的时间。</p>
</li>
</ul>
<h3 id="资源占用">资源占用</h3>
<p>Resource Usage，提供正常能力所需要的资源。</p>
<ul>
<li>空载资源占用 没有任何负载时候的占用</li>
<li>满载资源占用 全力运行时占用的资源</li>
</ul>
<h3 id="可用性">可用性</h3>
<p>Availability，系统在面对各种异常时可以正确提供服务的能力，衡量了系统的鲁棒性，是系统容错能力的体现。</p>
<p>可以用系统停止服务的时间与总的时间之比衡量，或者某功能的失败次数与总的请求次数之比来衡量。</p>
<p><strong>可用性允许部分组件失效，系统仍然能够提供服务。</strong></p>
<h3 id="可靠性">可靠性</h3>
<p>Reliability，系统完全不出故障的概率，多用在硬件设备。</p>
<h3 id="可拓展性">可拓展性</h3>
<p>Scalability，分布式系统<strong>通过拓展集群机器规模</strong>提高系统性能(吞吐量、相应时间、完成时间)、存储容量、计算能力的特性，是分布式系统的特有特质。</p>
<p>分布式系统设计的初衷就是利用集群多机器的能力处理单机无法解决的问题，<strong>集群规模取决于单个机器的性能和任务的要求</strong>。</p>
<p>当任务的需求随着具体业务不断提高时，除了<strong>升级系统的性能</strong>做垂直/纵向拓展外(提供单机配置)，另一个做法就是通过<strong>增加机器</strong>的水平去水平/横向拓展系统规模。</p>
<p>最好的分布式系统总是在追求“<strong>线性拓展性</strong>”，某一个指标可以随着集群中机器数量呈线性增长。就像一辆跑车，气缸越多/缸径越小，功率越高，长时间的线性提速体验肯定是要优于短暂的涡轮增压提速，涡轮增压式的提速有一点 Long Tail 的意思。</p>
<p>衡量系统可拓展性的常见指标是<strong>加速比(Speedup)</strong>，也就是拓展后相对拓展前的性能提升，就像跑车的加速度，根据拓展的目标来对比，比如 吞吐量、完成任务时间。</p>
]]></content>
        </item>
        
        <item>
            <title>分布式缓存</title>
            <link>https://liguangchang.cn/posts/distributed/distributed-cache/</link>
            <pubDate>Fri, 01 Oct 2021 12:40:40 +0800</pubDate>
            
            <guid>https://liguangchang.cn/posts/distributed/distributed-cache/</guid>
            <description>Cache 缓存：存储在计算机上的一个原始数据复制集，以便于访问。 属于存储领域，目的是为了让算法便捷高速运行，提升用户体验、系统性能。 Linux 的页表（pag</description>
            <content type="html"><![CDATA[<h2 id="cache">Cache</h2>
<p>缓存：存储在计算机上的一个原始数据复制集，以便于访问。</p>
<p>属于存储领域，目的是为了让算法便捷高速运行，提升用户体验、系统性能。</p>
<p>Linux 的页表（page table）和内存管理单元（MMU，物理硬件）负责将页的虚拟地址映射到物理地址。页表负责记录哪些是物理页，哪些是虚拟页，以及这些页的页表条目(PTE)。MMU 负责进行虚拟地址和物理地址的翻译，翻译过程中需要从页表获取页的PTE，MMU也会使用翻译后备缓存器（TLB）的缓存页号。</p>
<p>缓存无处不在，根据所处位置不通，可以分为</p>
<ul>
<li>客户端缓存</li>
<li>服务端缓存</li>
<li>网络中缓存</li>
</ul>
<p>根据规模和部署方式缓存可以分为</p>
<ul>
<li>单体缓存</li>
<li>缓存集群</li>
<li>分布式缓存</li>
</ul>
<h3 id="客户端页面缓存">客户端页面缓存</h3>
<p>页面缓存可以是对页面自身某些元素或全部元素进行缓存，或者是服务端将静态页面或动态页面的元素进行缓存。将之前渲染的页面保存为文件，再次访问可以避开网络连接，从而减少负载，提升性能，这种事实现自身的缓存和离线应用缓存。</p>
<p>随着<strong>单页面应用</strong>(Single Page Application,SPA**）的广泛应用，加上HTML5支持了<strong>离线缓存和本地存储</strong>，大部分BS应用的页面缓存都可以举重若轻了。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-css" data-lang="css"><span style="display:flex;"><span><span style="color:#f92672">localStorage</span>.<span style="color:#a6e22e">setItem</span><span style="color:#f92672">/</span><span style="color:#f92672">getItem</span><span style="color:#f92672">/</span><span style="color:#f92672">removeItem</span><span style="color:#f92672">/</span><span style="color:#f92672">clear</span>
</span></span></code></pre></div><p>页面缓存涉及到需要缓存的资源列表清单文件 <strong>manifest</strong> text/cache-manifest</p>
<h3 id="浏览器缓存">浏览器缓存</h3>
<p>浏览器缓存是根据一套与服务器约定的规则进行工作的，检查确保副本是最新的，通常只要一次会话。</p>
<p>HTTP 1.0 服务端侧 HTTP头部设置 <strong>Expires</strong> 来告诉客户端<strong>在重新请求文件之前缓存多久是安全的</strong>，可以通过 if-modified-since 的条件请求来使用缓存。发送的时间是文件最初被下载的时间，<strong>如果文件没有改变，服务器可以用 304-Not Modified 来应答</strong>，客户端收到304代码，就可以使用缓存的文件版本了。</p>
<p>HTTP1.1又了较强增强，<strong>缓存系统被形式化，引入了实体标签 e-tag（文件或对象的唯一标识）</strong>，可以请求一个资源，以及提供所持有的文件，然后询问服务器这个文件是否有变化。如果文件的e-tag 是有效的，服务器会生成304-Not Modified 应答，并提供正确文件的e-tag，否则发送200-OK应答。如果是<strong>集群</strong>，则每次都是不同的ID，不建议使用ETag。</p>
<p>配置了<strong>Last-Modified/ETag</strong> 的情况下，浏览器再次访问统一URL时，还是会发送请求到服务器询问文件是否已经修改，如果没有，服务器只会发送一个304回给浏览器，浏览器则直接从本地缓存取数据，如果有变化，就将整个数据重新发给浏览器。</p>
<p>Last-Modified/ETag 和 Cache-Control/Expires 的作用是不一样的，<strong>如果检测到本地的缓存还在有效的时间范围内，浏览器则直接使用本地缓存，不会发送任何请求</strong>。<strong>两者一起使用时，Cache-Control/Expires 的优先级要高于Last-Modfied/ETag</strong>。当本地副本根据 Cache-Control/Expires 发现还在有效期内时，不会再次发送请求去服务器询问修改时间(Last-Modified)或实体标识(e-tag)了。</p>
<p>Cache-Control 与 Expires 的功能一致，都是指明当前资源的有效期，控制浏览器是直接从浏览器缓存取数据还是重新发请求到服务器存取数据。Cache-Control 的选择更多、更细致，如果同时设置，优先级高于Expires。</p>
<p>Cache-Control 设置相对时间，max-age 指明以秒为单位的缓存时间。</p>
<p>Expires 设置以分钟为单位的绝对过期时间。优先级比Cache-Control低，同时设置Expires 和 Cache-Control ，后者生效。</p>
<p>一般情况会一起使用 Cache-Control/Expires 、Last-Modified/ETag，这样即使服务端设置了缓存时间，当用户刷新时，浏览器会忽略缓存继续向服务器发送请求，这时 Last-Modified/ETag 能够很好利用服务端的返回码304,从而减少开销。</p>
<p>HTML页面节点 meta 标签可以告诉浏览器当前页面不被孩奴承诺，每次访问都需要取服务器拉取，但是只有部分浏览器可以支持，一般缓存代理服务器都不支持，因为代理不解析HTML内容本身。</p>
<p><strong>nginx no-cache</strong></p>
<p>more_set_headers &lsquo;Cache-Control: no-cache&rsquo;</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-html" data-lang="html"><span style="display:flex;"><span>&lt;<span style="color:#f92672">meta</span> <span style="color:#a6e22e">http-equiv</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;Pramma&#34;</span> <span style="color:#a6e22e">CONTENT</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;no-cache&#34;</span>&gt;
</span></span><span style="display:flex;"><span>&lt;<span style="color:#f92672">meta</span> <span style="color:#a6e22e">http-equiv</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;Cache-Control&#34;</span> <span style="color:#a6e22e">content</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;no-cache&#34;</span> /&gt;
</span></span><span style="display:flex;"><span>&lt;<span style="color:#f92672">meta</span> <span style="color:#a6e22e">http-equiv</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;expires&#34;</span> <span style="color:#a6e22e">content</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;Wed, 26 Feb 2555 08:21:57 GMT&#34;</span> /&gt;
</span></span><span style="display:flex;"><span>&lt;<span style="color:#f92672">meta</span> <span style="color:#a6e22e">http-equiv</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;Cache-Control&#34;</span> <span style="color:#a6e22e">content</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;no-transform&#34;</span> /&gt;
</span></span><span style="display:flex;"><span>&lt;<span style="color:#f92672">meta</span> <span style="color:#a6e22e">http-equiv</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;Cache-Control&#34;</span> <span style="color:#a6e22e">content</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;no-siteapp&#34;</span> /&gt;
</span></span><span style="display:flex;"><span>&lt;<span style="color:#f92672">meta</span> <span style="color:#a6e22e">http-equiv</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;X-UA-Compatible&#34;</span> <span style="color:#a6e22e">content</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;IE=edge&#34;</span> /&gt;
</span></span></code></pre></div><p>no-cache: 数据内容不能被缓存, 每次请求都重新访问服务器, 若有max-age, 则缓存期间不访问服务器.</p>
<p>no-store: 不仅不能缓存, 连暂存也不可以(即: 临时文件夹中不能暂存该资源)</p>
<p>private(默认): 只能在浏览器中缓存, 只有在第一次请求的时候才访问服务器, 若有max-age, 则缓存期间不访问服务器.</p>
<p>public: 可以被任何缓存区缓存, 如: 浏览器、服务器、代理服务器等</p>
<p>max-age: 相对过期时间, 即以秒为单位的缓存时间.</p>
<p>no-cache, private: 打开新窗口时候重新访问服务器, 若设置max-age, 则缓存期间不访问服务器.</p>
<p>private, 正数的max-age: 后退时候不会访问服务器</p>
<p>no-cache, 正数的max-age: 后退时会访问服务器</p>
<p>点击刷新: 无论如何都会访问服务器.</p>
<p>地址栏回车、连接跳转、新开窗口、前进后退都会影响缓存，F5刷新不会影响。</p>
<p>还有浏览器通过页面指令设置HTTP缓存。。。</p>
<h3 id="网络中的缓存">网络中的缓存</h3>
]]></content>
        </item>
        
        <item>
            <title>TCP Command</title>
            <link>https://liguangchang.cn/posts/tcp/tcp-command/</link>
            <pubDate>Thu, 23 Sep 2021 01:25:43 +0800</pubDate>
            
            <guid>https://liguangchang.cn/posts/tcp/tcp-command/</guid>
            <description>ip curl https://api.myip.com | json nc 我喜欢用这个 nc -vz -w 1 ip port -w 1 # TTL 1s ss ss ss -ltp | grep sshd # 查看进程的端口占用 ss -p | grep 22 # 查看端口被哪个进程占用 ss -tenp | grep 22 # 列出某个端口上</description>
            <content type="html"><![CDATA[<h2 id="ip">ip</h2>
<pre tabindex="0"><code>curl https://api.myip.com | json
</code></pre><h2 id="nc">nc</h2>
<p>我喜欢用这个</p>
<pre tabindex="0"><code>nc -vz -w 1 ip port
-w 1  # TTL 1s 
</code></pre><h2 id="ss">ss</h2>
<p>ss</p>
<pre tabindex="0"><code>ss -ltp  | grep  sshd # 查看进程的端口占用
ss -p    | grep  22   # 查看端口被哪个进程占用
ss -tenp | grep  22   # 列出某个端口上的tcp连接
ss -t  #所有tcp连接
ss -tl #所有处于监听状态的TCP连接
ss -u  #所有udp连接
ss -p  #列出连接时显示进程名字和pid
ss -s  #统计socket
</code></pre><h2 id="netstat">netstat</h2>
<pre tabindex="0"><code>netstat -tunpal | grep sshd | grep LISTEN # 找出进程监听的端口号
netstat -tunpal | grep 22   | grep LISTEN # 找出某个端口号被哪个进程占用
</code></pre><h2 id="lsof">lsof</h2>
<p>这个命令可以表明，socket 其实是五元组(协议)，同一个端口号可以被多个进程的不同协议绑定</p>
<pre tabindex="0"><code>lsof -p pid     #列出进程打开的文件
lsof -i tcp     #列出所有tcp连接
lsof -i udp
lsof -i :55555  #列出占用端口的连接
lsof -i tcp:55555
lsof -i udp:55555
lsof -c name    #列出进程名开头以 name 打开的文件
</code></pre><h2 id="sock">sock</h2>
<h2 id="tcpdump">tcpdump</h2>
]]></content>
        </item>
        
        <item>
            <title>TCP状态转换</title>
            <link>https://liguangchang.cn/posts/tcp/tcp-status/</link>
            <pubDate>Wed, 22 Sep 2021 23:12:55 +0800</pubDate>
            
            <guid>https://liguangchang.cn/posts/tcp/tcp-status/</guid>
            <description>TIME_WAIT TIME_WAIT 状态也称为2MSL等待状态，该状态中，TCP会等待两倍于最大段生存期(Maximum Segment Lifetime，MSL)的时间，有时也被称作加倍</description>
            <content type="html"><![CDATA[<h2 id="time_wait">TIME_WAIT</h2>
<p>TIME_WAIT 状态也称为2MSL等待状态，该状态中，<strong>TCP会等待两倍于最大段生存期(Maximum Segment Lifetime，MSL)的时间</strong>，有时也被称作加倍等待。每个实现都必须为最大段生存期选择一个数值，代表<strong>任何报文段在被丢弃前在网络中被允许存在的最长时间</strong>。</p>
<p><strong>由于TCP数据报被IP数据包承载，IP数据报TTL字段和跳数限制字段又限制了IP数据报的有效生存时间。</strong></p>
<p>RFC 将最大段的生存期设为2分钟，最大段的生存期的数值可以为 30s、1分钟或者2分钟。</p>
<p>Linux 可以修改 net.ipv4.tcp_fin_timeout 数值记录了 2MSL 状态需要等待的超时时间(以秒为单位)。</p>
<p>如果已经设置了MSL的数值，当TCP执行一个主动关闭并发送最终的ACK时，连接必须处于TIME_WAIT 状态并持续两倍于最大生存期的时间。这样就<strong>能够让TCP重新发送最终的ACK以避免出现丢失的情况</strong>。重发最终的ACK不是因为TCP重传了ACK，而是因为通信的另一方重传了它的FIN。TCP总是重传FIN，直到它收到一个最终的ACK。</p>
<p>当TCP处于等待状态时，通信双方将该连接(四元组)定义为<strong>不可重新使用</strong>。只有2MSL等待结束时，或一条新连接使用的初始序列号超过了连接之前的实例所使用的最高序列号时，或者允许使用时间戳选项来区分之前连接实例的报文段以避免混淆时，这条连接才能被再次使用。</p>
<p>有些系统实现，如果一个端口号被处于2MSL等待状态的任何通信段所用，那么该端口号将不能再次使用。 但有些实现API都绕开了这个约束，及时2MSL 等待占用了端口号，还会分配本地端口号。</p>
<h3 id="防止端口号被打开">防止端口号被打开</h3>
<p>TCP 还是会<strong>防止端口号被处于2MSL等待状态的同一连接的其他实例重新打开</strong>。当一个连接处于2MSL等待状态时，任何延迟到达的报文段都将被丢弃。一个连接是通过地址和端口号的5元组定义的。如果该连接处于2MSL等待状态，那么在这段时间内将不能被重新使用，当这条正确的连接信息最终被建立起来后，这条连接之前的实例所传输的延迟报文段是不能被当作新连接的一部分来解读的。</p>
<h3 id="客户端2msl">客户端2MSL</h3>
<p>通常客户端主动发起关闭，并进入 TIME_WAIT 状态，服务器通常执行被动关闭操作而且不会直接进入 TIME_WAIT 状态。关闭一个客户端再重新启动，通常OS会分配临时的端口号，实际上是出于安全考虑推荐的随机方法[RFC6056]。<strong>客户端能够快速产生大量的连接(尤其是同一个客户端)，不得不再临时端口号供应紧张时延迟一会儿来等待其他连接的终止。</strong></p>
<h3 id="服务端2msl">服务端2MSL</h3>
<p>对于服务端，如果终止一个已经建立了一条连接的服务器进程，然后立即尝试重新启动它，服务器不能为该程序的通信端分配对应的端口号(地址已经占用了)，这是<strong>因为当连接进入2MSL 时，端口号仍然是连接的一部分</strong>。</p>
<h2 id="静默时间">静默时间</h2>
<p>在本地与外部ip地址、端口号都相同的情况下，<strong>2MSL 状态能够防止新的连接将前一个连接的延迟报文段解释成自身数据的状况</strong>，只有在与处于2MSL等待状态的连接相关的主机未关闭的条件下才具有意义。</p>
<p>如果一台与处于TIME_WAIT状态下的连接相关联的主机崩溃，然后在<strong>MSL内重启</strong>，使用与主机崩溃之前处于TIME_WAIT 状态的连接相同的IP地址与端口号，这个时候，<strong>该连接在主机崩溃之前产生的延迟报文段会被认为属于主机重启的后创建的新连接</strong>，这种处理方式将不会考虑在主机重启之后新连接是如何选择初始序列号的。</p>
<p>为了防止MSL内重启延迟报文混淆，RFC0793 指出<strong>在崩溃或者重启后 TCP 协议应当在创建的连接之前等待相当于一个MSL的时间</strong>。该段时间被称为静默时间。只有极少数遵循了这一点，因为绝大多数的主机在崩溃之后都需要超过一个MSL的时间才能重新启动。</p>
<h2 id="fiin_wait_2状态">FIIN_WAIT_2状态</h2>
]]></content>
        </item>
        
        <item>
            <title>TCP选项</title>
            <link>https://liguangchang.cn/posts/tcp/tcp-options/</link>
            <pubDate>Fri, 17 Sep 2021 02:30:10 +0800</pubDate>
            
            <guid>https://liguangchang.cn/posts/tcp/tcp-options/</guid>
            <description>TCP头部包含了多个选项，选项列表结束(End of Option List ,EOL)、无操作(No operation，NOP) 以及最大段大小 (Maximum Segment Size，MSS)</description>
            <content type="html"><![CDATA[<p>TCP头部包含了多个选项，选项列表结束(End of Option List ,EOL)、无操作(No operation，NOP) 以及最大段大小 (Maximum Segment Size，MSS) 是定义于原始TCP规范中的选项。</p>
<p>NOP 选项是允许发送这在必要的时候用多个4字节组填充某个字段。</p>
<p>TCP头部的长度应该是32bit的倍数，因为TCP头部长度字段是以此为单位的。</p>
<p>EOL指出了选项列表的结尾，说明无需对选项列表再进行处理。</p>
<h3 id="最大段大小">最大段大小</h3>
<p><strong>Maximus Segment Size，MSS</strong></p>
<p><strong>MSS 是 TCP允许从对方接收的最大报文段，因此这也是通信对方在发送数据时能够使用的最大报文段。</strong></p>
<p>最大段只记录TCP数据的字节数而不包括其他相关的TCP与IP头部。当建立一条TCP连接时，通信的每一方都要在SYN报文段的MSS选项中说明自己允许的最大段大小。这16位的选项能够说明最大段大小的数值。</p>
<p>没有指明的情况，<strong>最大段大小默认是536字节</strong>。如果按照最小的TCP和IP头部计算，TCP协议要求在每次发送最大段大小为536字节，这样就正好能够组成一个576(20+20+536) 字节的IPv4数据报。</p>
<p><strong>IPV4 协议中，常见最大段大小是 1460，IPv4数据报大小也相应增加40个字节 （总共 1500 字节，以太网中最大传输单元与互联网路径最大传输单元的典型数值)，20 字节的TCP头部，20字节的IP头部。</strong></p>
<p>当使用IPv6协议时，最大段大小通常为1440字节，由于IPv6的头部比IPv4多20字节，因此最大段的数值相应减少20字节。</p>
<p>65535 是一个特殊数值，与IPV6 超长数据报一起用来指定一个表示无限大的有效最大段大小值。发送方的最大段大小等于路径MTU的数值减去60字节(40字节用于IPv6头部，20字节用于TCP头部)。<strong>最大段并不是TCP通信双方协商的结果，而是一个限定值。当通信的一方将自己的最大段选项发送给对方时，已经表明自己不愿意在整个连接过程当中接受到任何大于该尺寸的报文段。</strong></p>
<h3 id="选择确认选项">选择确认选项</h3>
<p><strong>TCP采用累积ACK进行确认，不能正确地确认之前已经接受的数据。由于接受的数据是无序的，所以接受到数据的序列号也不是连续的。这种情况下，TCP接收方的数据队列中会出现空洞的情况。</strong></p>
<p><strong>TCP的选择确认（SACK），能够让发送方了解接受方当前的空洞 (以及在序列空间中超出空洞的乱序数据块)，就能在报文段丢失或被接受方遗漏时，更好地进行重传工作。</strong></p>
<p>通过接收<strong>SYN</strong> (或者 SYN+ACK) 报文段中的 “允许选择确认“ 选项，TCP通信方会了解到自身具有了发布 SACK 信息的能力。<strong>当接受到乱序的数据时，它就能提供一个 SACK 选项来描述这些乱序的数据，从而帮助对方有效地进行重传</strong>。<strong>SACK 信息保存于ACK选项中，包含了接受方已经成功接受的数据块的序列号范围</strong>。每一个范围被称为一个SACK快，由一对32位的序列号表示。</p>
<p>SACK 选项 包含了 n 个 SACK 块，n个块的长度为 8n + 2 个字节，增加的2个字节用于保存SACK选项的种类与长度。<strong>由于TCP头部选项的长度有限，并且通常和TSOPT选项一块使用，需要额外的10字节(2字节的填充)，因此一个报文段中发送的最大SACK 块数目为3</strong>。</p>
<p><strong>三个块表明可以向发送端报告三个空缺，若不受拥塞控制限制，SACK选项可在一个RTT时间填补3个空缺。</strong></p>
<p><strong>虽然只有SYN报文段才能包含 &ldquo;允许选择确认&quot;选项，但是只要发送方已经发送了该选项，SACK块就能够通过任何报文段发送出去</strong>？？？</p>
<h3 id="窗口缩放选项">窗口缩放选项</h3>
<p><strong>窗口缩放选项(WSOPT)能够有效地将TCP窗口通告字段的范围从16位增加到30位。</strong></p>
<p>TCP头部不需要改变窗口通告字段的大小，仍然维持16位的数值。使用另一个选项作为这16位数值的比例因子（S）。比例因子能够使窗口字段值有效的左移。可以将窗口数值扩大到原先的2^S 倍。</p>
<p>一个字节的移动可以用 [0-14]来计数，0 表示没有任何比例，最大的比例值是14，它能够提供一个最大为 1073 725 440 字节(65535 * 2^14) 的窗口，接近 2^30-1(1G)。可以理解TCP 使用一个32位的值来维护窗口的大小。</p>
<p><strong>该选项只会出现在一个 SYN 报文段中，因此当连接建立以后比例因子是与方向绑定的。</strong></p>
<p>为了保证窗口调整，通信双方都需要在SYN报文段中包含该选项。主动打开连接的一方利用自己的 SYN 中发送该选项，被动打开连接的一方只能在接受到的 SYN 中指出该选项时才能发送。</p>
<p><strong>每个方向的比例因子可各不相同，如果主动打开连接的一方发送了一个非0的比例因子但却没有收到来自对方的窗口缩放选项，它将会自己发送与接收的比例因子数值都设为0。</strong></p>
<p>假设正在使用窗口缩放选项，发送出去的窗口移动数值为 S，收到的窗口移动数值为 R。从对方接收到的每一个 16 位的通告窗口都需要左移 R 位才能获得真实的窗口大小。<strong>每次向对方发送窗口通告时，都会将32位的窗口大小向右移动 S 位，然后将16位的数值填充到TCP头部。</strong></p>
<p>窗口的移动数据是由 TCP 通信方根据接受到缓存的大小自动选取的。缓存的大小是由系统设定的，但是应用程序通常都具有改变大小的能力。当TCP协议被用于大带宽、高延迟网络上提供海量数据传输服务时，窗口缩放选项就非常有意义。</p>
<h3 id="时间戳选项">时间戳选项</h3>
<p><strong>时间戳选项</strong>，<strong>TSopt</strong>，要求发送方在每一个报文段中添加2个4字节的时间戳数值。<strong>接受方将会在确认中反应这些数值，允许发送方针对每一个接收到的ACK估算TCP连接的往返时间。</strong></p>
<p>当使用时间戳选项时</p>
<ol>
<li>发送方将一个32位的数值填充到时间戳数值字段(TSV或TSval) 作为时间戳选项的第一个部分，第二部分为0。</li>
<li>接受方将收到的时间戳数字原封不动地填充至第二部分的时间戳回显重试字段(TSER或TSecr)</li>
</ol>
<p>由于包含了时间戳选项，TCP头部长度会增加10字节（8字节用于保存两个时间戳数值，另外两个数值则用于指明选项的数值与长度）。</p>
<p>接受者不关心时间戳单元或数值到底是什么，只会对它接收到的信息作出响应，该选项不要求两台主机之间进行任何形式的时钟同步。RFC1323 推荐发送者每秒钟至少将时间戳数值加1。</p>
<p>估算一条TCP连接的往返时间主要是为了设置重传超时，告知TCP通信方何时应该重新发送可能已经丢失的报文段。借助时间戳选项，能够获得往返时间相对精准的测量结果。在使用时间戳之前，大多TCP通信会针对每个窗口的数据抽取一个往返时间样本。时间戳选项使我们获得了更多的样本，从而提升了精确估算往返时间的能力。</p>
<h3 id="防回绕序列号">防回绕序列号</h3>
<p><strong>Protection Against Wrapped  Sequence numbers，PAWS。</strong></p>
<p>时间戳选项允许更高频率的往返时间样本，数据量很大，连接时间长的情况，个别报文延迟，序列号转了一圈，重置为0，接受端让发送方重传，在延迟的报文完全丢失的情况下，没有问题。<strong>如果延迟的报文段延迟后又到达了，并且间隔时间小于MSL限制</strong>，这个时候接受端收到两个一样序列号的报文段，直接<strong>丢弃掉与最近接收到的报文段时间戳相差最圆的那个报文段</strong>，放回绕是<strong>为接受者提供了避免接收旧报文段与判断报文段正确性的方法</strong>。</p>
<p>连接中的报文延迟被关闭，又以同样的四元组被重新打开，延迟的报文段又被视为有效数据重新进入新连接的数据流中，开启时间戳选项之后，这样的问题就能够避免。</p>
<p>假设一个TCP连接启用了窗口缩放和时间戳选项，在传输数据量很大时。如果有报文段丢失发生了重传，如果该报文段丢失与重新出现的时间差小于一个报文段在网络中存在的最大时间(MSL)，服务端就能正常接受到这个报文段，否则当路由器发现TTL期满后就会丢弃该报文段。</p>
<h3 id="用户超时选项">用户超时选项</h3>
<p><strong>USER_TIMEOUT，UTO 指明了TCP 发送者在确认对方未能接收数据之前愿意等待该数据ACK确认的时间。RFC0793，UTO 是TCP协议本地配置的一个参数。</strong></p>
<p>用户超时选项允许TCP通信方将自己的UTO 数值告知连接的对方，这样就方便了TCP接受方调整自己的行为。NAT 设备也能够解释这些信息以帮助他们的连接活动计时器。</p>
<p><strong>用户超时的选项是建议性的</strong>，因为即便连接的一端希望使用一个大的或小的数值，也不意味着另一端就必须遵从。RFC 1122 定义，建议当TCP连接到达3次重传阈值时应爱通知应用程序，当超过大于100秒时应该关闭连接。长的用户超时设置会导致资源耗尽，短的用户超时设置可能会导致一些连接过早的断开，因此需要为用户超时选项的可能数值设置上下边界。</p>
<p>USER_TIMEOUT  = min(U_LIMIT,max(ADV_UTO,REMOTE_UTO,L_LIMIT))，并不能保证同一连接的两端会获得相同的用户超时数值。</p>
<p>ADV_UTO 是本端告知远端通信方的用户超时选项数值</p>
<p>REMOTE_UTO 是远端通信方告知的用户超时选项数值</p>
<p>U_LIMIT 是本地系统对用户超时选项设定的数值上边界，L_LIMIT 是下边界</p>
<p>任何情况下，L_LIMIT 的数值必须大于对应连接的重传超时数值，L_LIMIT 的数值一般推荐为 100 秒，可以保持与 RFC1122 兼容。</p>
<p>建立连接的SYN 报文段、首个非SYN 报文段以及USER_TIMEOUT 的数值发生任何改变的报文段，都会包含用户超时选项。该选项是由一个15位的数值部分与一个1位的单位部分构成。单位部分用于说明数值的计量单位是分钟(1)还是秒(0)。</p>
<h3 id="认证选项">认证选项</h3>
<p><strong>TCP Authentication Option,TCP-AO，认证选项用于增强连接的安全性</strong>，设计的目的在于增强与替换较早的TCP-MD5 机制[RFC2385]。</p>
<p>使用一种加密散列算法以及TCP连接双方共同维护的一个秘密值来认证一个报文段。不仅提供了各种加密算法吗，还使用&quot;带内&quot;信令来确认密钥是否改变，与TCP-MD5 相比有很大的提高。但是，该选项没有提供一个全面密钥管理方案，通信双方不得不采用一种方法在TCP认证运行之前建立出一套共享密钥。</p>
<p>当发送数据时，TCP 会根据共享的密钥生成一个通信密钥，并根据一个特殊的加密算法[RFC5926]计算散列值。接受者装配有相同的密钥，同样也能够生成通信密钥。借助通信密钥接受者，接受者可以确认到达的报文段是否在传输过程中被篡改过。该选项可以针对各种TCP欺骗攻击提供强有力的抵御策略。</p>
<p><strong>由于需要创建并分发一个共享密钥，该选项没有得到广泛应用。</strong></p>
<h3 id="tcp-路径最大传输单元发现">TCP 路径最大传输单元发现</h3>
]]></content>
        </item>
        
        <item>
            <title>Redis 数据结构</title>
            <link>https://liguangchang.cn/posts/redis/redis-dso/</link>
            <pubDate>Tue, 14 Sep 2021 00:40:34 +0800</pubDate>
            
            <guid>https://liguangchang.cn/posts/redis/redis-dso/</guid>
            <description></description>
            <content type="html"><![CDATA[]]></content>
        </item>
        
        <item>
            <title>TCP应用</title>
            <link>https://liguangchang.cn/posts/tcp/tcp-apply/</link>
            <pubDate>Sat, 04 Sep 2021 09:56:34 +0800</pubDate>
            
            <guid>https://liguangchang.cn/posts/tcp/tcp-apply/</guid>
            <description>扫描主机 扫描端口 防御扫描 探测防火墙 跟踪路由 探测网络性能 干扰连接，重置回话，检查盲注攻击漏洞</description>
            <content type="html"><![CDATA[<p>扫描主机</p>
<p>扫描端口</p>
<p>防御扫描</p>
<p>探测防火墙</p>
<p>跟踪路由</p>
<p>探测网络性能</p>
<p>干扰连接，重置回话，检查盲注攻击漏洞</p>
]]></content>
        </item>
        
        <item>
            <title>TCP数据传输-分片、滑动窗口、重发、流控制</title>
            <link>https://liguangchang.cn/posts/tcp/tcp-transmission/</link>
            <pubDate>Wed, 01 Sep 2021 01:28:08 +0800</pubDate>
            
            <guid>https://liguangchang.cn/posts/tcp/tcp-transmission/</guid>
            <description>通信问题 自身不包含可靠传递数据机制的协议，他们可能会使用用一种像数据校验和或者CRC这样的数学函数来检测收到的有差错的数据，但是他们不会去纠</description>
            <content type="html"><![CDATA[<h2 id="通信问题">通信问题</h2>
<p>自身不包含可靠传递数据机制的协议，他们可能会使用用一种像数据校验和或者CRC这样的数学函数来检测收到的有差错的数据，但是他们不会去纠正差错。以太网和基于其上的其他协议，协议提供了一定次数的重试，如果还是不成功则放弃。</p>
<p>使用差错校正码(基本是添加一些冗余的比特，使得即使某些比特被毁，真实的信息也可以被恢复回来)来纠正通信问题是处理差错的一种非常重要的方法。</p>
<p>另外一种方法是简单的 “<strong>尝试重新发送</strong>&quot; ,直到信息最终被接收，这种方法被称为<strong>自动重复请求</strong>(Automatic Repeat Request，ARQ)，构成了许多通信协议的基础，包括TCP在内。</p>
<p>客户端可服务器之间的通信是一个数据传输过程，通信的消息将以数据包形式进行传输，为了更有效的进行通信，TCP协议在数据进行数据传输时，使用滑动窗口机制来同时发送多个数据包，当数据包丢失时，TCP协议利用数据重发功能重新发送数据包，因接收端接收数据包的能力不同，TCP流控制会根据接收能力发送适当数量的数据包。</p>
<h2 id="多跳通信信道问题">多跳通信信道问题</h2>
<p>差错类型(分组比特差错)</p>
<p>分组重新排序</p>
<p>分组复制</p>
<p>分组泯灭(丢失)</p>
<h2 id="通过重发分组处理分组丢失的问题">通过重发分组处理分组丢失的问题</h2>
<p>重发分组直到它被正确的接收来解决分组丢失、比特差错，需要判断</p>
<ol>
<li>接收方是否收到分组</li>
<li>接受方接收到的分组是否与之前的发送方发送的一样。</li>
</ol>
<p>接收方给发送方发信号以确定自己已经接收到一个分组，称为确认或者<strong>ACK</strong>(acknowledgement)。就是发送方发送一个分组，然后等待一个ACK。接收方收到这个分组时，发送对应的ACK。方发送发收到这个ACK，再发送另一个分组，一直继续。</p>
<ol>
<li>
<p>发送方对一个ACK  应该等待多长时间?</p>
</li>
<li>
<p>ACK 丢失怎么办？</p>
<p>ACK 丢失，发送方不能轻易地把这种情况与原分组丢失的情况区分出来，所以它简单的再次发送原分组。这样接收方就可能会收到两个或更多的拷贝，因此必须准备好处理这种重复分组的情况。</p>
<p>接受方收到被传送分组的重复(duplicate)副本，可以通过<strong>序列号</strong>(sequence number) 来处理。基本上在源端发送时，每个唯一的分组都有一个新的序列号，这个序列号由分组自身一直携带着。接受方可以使用这个唯一的序列号来判断它是否已经见过这个分组，如果见过就丢弃它。</p>
</li>
<li>
<p>分组被接收到了，里面有错怎么办？</p>
<p>使用编码来检测一个大的分组中的差错一般都很简单，仅使用比其自身小很多的一些比特即可纠正，更简单的编码一般不能纠正差错，但是能检测他们(这就是校验和与CRC受欢迎的原因)，为了检测分组里的差错，使用一种<strong>检验和</strong>形式。当一个接受方收到一个含有差错的分组时，它不发送ACK，最后发送方重发完整到达的无差错的分组。</p>
</li>
</ol>
<h2 id="数据分片">数据分片</h2>
<p>数据从主机传送到另一个主机往往要经过路由器、网关等设备，网络设备对数据处理有一定的限制，不能处理超过额外字节的数据，所以发送数据的时候需要确定发送的数据的最大字节数。这个最大字节数被称为<strong>最大消息长度</strong>(Maximum Segment Size，MSS)，当要发送的数据超过该值，就需要将数据分为多个包，以此发送，该操作叫做数据分片。</p>
<p>那不同网络设备 和 MSS 怎么取舍，过一个设备分片多次？</p>
<p>MSS 是TCP数据包每次能够传输的最大数据量。通常最大值为1460 字节，(回忆一下，以太网数据桢最大传输单元MTU 通常1500字节)，</p>
<p>如果发送的数据包大小大于MSS值，数据包将会被分片传输。</p>
<p>在TCP前两次握手时，TCP首部包含<strong>MSS</strong>选项，互相通知对方网络接口能够适应的MSS大小，然后双方使用较小的MSS值进行传输。</p>
<h2 id="停止和等待">停止和等待</h2>
<p>发送方发送一个分组，等待一个ACK，等不到就重发可以保证可靠，但是效率不高。如果一个分组的发送都要很长时间(推迟或延迟)，发送方注入一个分组到通信链路中，然后停下来等待知道它收到ACK，这个协议也被称为 &ldquo;<strong>停止和等待</strong>&quot;。这种一个分组接连一个分组的同步发送，使得<strong>吞吐量</strong>性能(每单位时间发送在网络中的数据量) 与 <strong>M/R</strong> 成正比，M 是分组大小，R 是往返时间 (Round-Trip Time，RTT)。如果有分组丢失或损害，吞吐量更低。<strong>吞吐质</strong>(每单位时间传送的有用数据量)明显要比吞吐量低。</p>
<h2 id="多个分组进入让网络更繁忙">多个分组进入让网络更繁忙</h2>
<p>不会损害和丢失太多分组的网络，低吞吐量的原因是网络经常没有处于繁忙状态。如果允许同一时间多个分组进入网络，就可以使它更繁忙，从而得到更高的吞吐量。</p>
<p>允许多个分组同时进入网络后，发送方不仅要决定什么时候注入一个分组到网络中，还要考虑注入多少个。并且必须要指出在等待ACK时，怎么<strong>维持计时器</strong>，同时还必须要保存每个还没确认的分组的一个副本以防需要重传。</p>
<p>接受方需要有一个更复杂的<strong>ACK机制</strong>：<strong>可以区分哪些分组已经收到，哪些还没有</strong>。接受方可能需要一个更复杂的缓存(分组保存)机制允许<strong>维护次序杂乱的分组</strong>(那些比预想要先到的分组更早到达的分组，因为丢包和次序重排的原因)，除非简单的抛弃这些分组(效率降低)。</p>
<p>另外还要有<strong>差速控制</strong>，如果接受方的接受速率比发送方的发送速率要慢，发送发简单地以很高速速率发送很多分组，接受方可能会因为处理或内存限制而丢到这些分组。中间的路由器也是会有这些问题。</p>
<h2 id="滑动窗口机制">滑动窗口机制</h2>
<p>在进行数据传输时，如果传输的数据比较大，就需要拆分为多个数据包进行发送。TCP协议需要对数据进行确认后，才可以发送下一个数据包。</p>
<p>发送端每发送一个数据包，都需要得到接受端的确认应答以后，才可以发送下一个数据包，这样以来，就会在等待确认应答包环节浪费时间。为了避免这种情况，TCP引入了滑动窗口概念。窗口大小指的是不需要等待确认应答包而可以继续发送数据包的最大值(<strong>已经被发送和注入单还没完全确认的分组数量</strong>)，避免了网络的吞吐量降低。如果把通信会话中的所有分组排成长长的一行，但只能通过一个小孔观察他们，就只能看到他们的一个子集，像通过一个窗口观察一样。窗口的这种滑动，给这种类型的协议增加了一个名字，<strong>滑动窗口</strong>(<strong>sliding window</strong>)协议。</p>
<p>窗口大小是指可以发送数据包的最大数量，可以分为两部分，一部分是数据已经发送，但是没有得到确认应答包；第二部分表示允许发送，但未发送的数据包。</p>
<p>当发送了最大数量的数据包(窗口大小数据包)，有时不会同时收到这些数据包的确认应答包，而是收到部分确认应答包。这个时候窗口就通过滑动的方式，向后移动，确保下一次发送仍然可以发送窗口大小的数据包。</p>
<p>窗口结构在发送发和接受方都有，<strong>在发送方，窗口记录哪些分组可以被释放、哪些分组正在等待ACK，以及哪些分组还不能被发送。在接受方，记录着哪些分组已经被接受和确认，哪些分组是下一步期望的(和已经分配多少内存来保存它们)，以及哪些分组即使被接受也将会因内存限制而被丢弃，操作系统内核位了维护这个滑动窗口，需要开辟发送缓冲区来记录当前还有哪些数据没有应答，只有确认应答的数据，才能从缓存区删掉</strong>。</p>
<h2 id="数据重发">数据重发</h2>
<p>在进行数据包传输时，难免会出现数据丢失情况。</p>
<ul>
<li><strong>未使用滑动窗口机制，发送的数据包没有收到确认应答包，数据都会被重发</strong></li>
<li><strong>使用了滑动窗口，确认应答包丢失，也不会导致数据包重发</strong></li>
<li><strong>发送的数据包丢失，将导致数据包重发。</strong></li>
</ul>
<h3 id="确认应答包丢失">确认应答包丢失</h3>
<p><strong>前面发送的数据包没有收到对应的确认应答，当收到后面数据包的确认应答包，表示前面的数据包已经成功被接受端接收了，发送端不需要重新发送前面的数据包。</strong></p>
<p>那意思是只有窗口大小里面都失败才会重发？</p>
<p>为什么滑动窗口确认包丢失可以不重发？</p>
<h3 id="发送数据包丢失">发送数据包丢失</h3>
<p><strong>发送端的部分数据包没有到达接收端。</strong></p>
<p><strong>如果在接受端收到的数据包，不是本应该要接收的数据包，就会给发送端返回消息，告诉发送端自己应该接收到的数据包。如果发送端连续3次收到这样的数据包，就认为该数据包成功发送到接收端，这时就开始重发该数据包。</strong></p>
<p><strong>同时在收到不是希望的序号+1包时，也会确认收到数据包，并且在发送端重发是，确认返回下次应该收到的最新的序号+1数据包。</strong></p>
<p>可以调整嘛？怎么调整可以达到最优吞吐量？</p>
<h2 id="变量窗口">变量窗口</h2>
<h3 id="流量控制">流量控制</h3>
<p>为了处理的那个接受方相对发送发太慢时产生的问题，在接受方跟不上时会强迫发送方慢下来，这称为<strong>流量控制(flow control)</strong>。一种方式是基于<strong>速率</strong>(rate-based)流量控制，它是给发送方指定某个速率，同时<strong>确保数据永远不能超过这个速率发送</strong>。这种类型的流量控制最适合流应用程序，可被用于广播和组网发现。另外一种方式就是基于窗口流量控制，是使用滑动窗口时最流行的方法，<strong>窗口的大小不是固定的，而是允许随着时间变动的</strong>。可以变动，就必须有一种方法让接受方通知发送方使用多大的窗口。这个一般称为<strong>窗口通告(window advertisement)</strong>，或简单地称为<strong>窗口更新(window update)</strong>。发送方(窗口通告的接受者)使用该值调整其窗口的大小，窗口更新和ACK 是由同一个分组携带的，意味着<strong>发送方往往会在它的窗口滑动到右边的同时调整它的大小</strong>。</p>
<p>在使用滑动窗口机制进行数据传输时，发送方根据实际情况发送数据包，接收端接收数据包，但是接收端处理数据的能力是不同的。</p>
<ul>
<li><strong>窗口过小</strong>，发送端发送少量的数据包，接收端很快就处理了，并且还能处理更多的数据包，当传输比较大的数据时，需要不停地等待发送方，造成很大的延迟，也就是饥饿现象(都喜欢整出来这样的一个名词)。</li>
<li><strong>窗口过大</strong>，发送端发送大量的数据包，接收端处理不了那么多的数据包，就会堵塞链路，如果丢弃这些本应该接收的数据包，又会触发重发机制</li>
</ul>
<p>为了避免两端数据速率的不对称，TCP 提供了流控制，就是使用了不同的窗口大小发送数据包，发送端第一次从窗口大小 (窗口大小是根据链路带宽的大小来决定的) 发送数据包，接收端收到这些数据包，并返回确认应答包，告诉发送端自己下次希望收到的数据包是多少 (新的窗口大小 )，发送端收到确认应答包以后，将以该窗口大小进行发送数据包。</p>
<h3 id="带流控制的流程">带流控制的流程</h3>
<ul>
<li>发送端根据当前的链路带宽大小决定了发送数据包的窗口大小，如果当前窗口为3，可以发送3个数据包</li>
<li>接收端收到数据包，但是只能处理2个数据包，第三个数据包就没有被处理，确认应答包反馈希望下次窗口大小为2</li>
<li>发送端收到确认应答包，知道了希望的窗口大小为2，并且上次发送的数据包处理了2个，还有1个没处理，第三个数据包还需要重发</li>
</ul>
<p>如果接收端返回的确认应答包中，窗口设置为0，表示当前不能接收到任何数据(缓冲区满了)，发送端将不会在发送数据包，只有等待接收端发送窗口更新通知才可以继续发送数据包。</p>
<p>如果这个时候更新的通知在传输中丢失了，那么就可能导致无法继续通信。为了避免这样的情况发生，发送端会时不时地发送窗口探测包(发送端等待时间超过了重发超时时间)，该包仅1字节，用来获取最新的窗口大小信息，接收端收到发送端的探测包，再次发送窗口大小更新包。</p>
<p>每次应答都多了一个下次窗口的大小，如果发送端很快，接收端很慢，不是会拖垮发送端的速度，视频的话，因为一方网卡，就会有声音、画面延迟，卡屏，不卡的一方是正常的视频，只是收到对方的视频是卡的，好像就是快的快，慢的慢。这个流控制没感觉到让快的快，慢的慢慢的快，不能让慢的一方在中间缓存层?中慢慢处理？</p>
<h3 id="拥塞控制">拥塞控制</h3>
<p>在发送发第一次发送数据时，是不知道对接受方的影响的。在没有收到任何一个ACK 之前，发送方允许注入 W 个分组到网络中。如果发送发和接受方足够快，网络中没有丢失一个分组以及有无穷的空间的话，这意味着通信速率正比于(SW/R) b/s，W 是窗口，S 是分组大小(bit)，R 是往返时间(RTT)。当来自接受方的窗口通道夹带着发送方的值W时，那么发送方的全部速率就被限制而不能超越接受方。这种方法可以很好的保护接受方，但是对于中间网络(有限内存的路由器)，他们与低速网络链路抗争着。当这种情况出现时，发送方的速率可能超过某个路由器的能力，从而导致丢包，这由一种特殊的称为**拥塞控制(congestion control)**的流量控制形式来处理，涉及到发送方减低发送速度不至于压垮与其接受方之间的网络。</p>
<p>使用一个窗口通告来告之发送方为接受方减慢速度，这个称为明确发信，因为有一个协议字段专用于通告发送方正在发生什么，另一个选项可能被用于猜测(guess)它需要慢下来。这种方法设计隐私(implicit) 发信&mdash;&mdash;设计根据其他某些证据来决定速度。</p>
<h3 id="拥塞控制技术">拥塞控制技术</h3>
<h2 id="重传超时">重传超时</h2>
<p>基于重传的可靠协议要面对的重要性能问题是要等待多久才能判定一个分组已丢失并将它重发。</p>
<p>发送方在重发一个分组之前应等待的时间量大概是下面时间的总和</p>
<ul>
<li>发送分组所用的时间</li>
<li>接受方处理它和发送一个ACK所用的时间</li>
<li>ACK 返回到发送方所用的时间</li>
<li>发送方处理ACK所用的时间</li>
</ul>
<p>然而，上面的时候没有一个可以确切知道的，另外这些时间还会随着网络设备的额外负载的变化而变化。</p>
<p><strong>往返时间估计(round-trip time estimation)</strong>：让协议去估计它们，是一个统计过程。</p>
<p>选择一组 RTT 样本的样本均值作为真实的RTT是最有可能的，这个平均值自然地会随着时间改变，因为通信穿过的网络的路径可能会改变。往返时间估计直接用于触发重传的时间计时值是 不合理的，会引起一些不必要的重传或者网络空闲。</p>
<h2 id="设置rtt">设置RTT</h2>
<p>todo</p>
<h2 id="tcp的可靠性">TCP的可靠性</h2>
<p>TCP 提供了一个字节流接口，TCP必须把一个发送应用程序的字节流转换成一组IP可以携带的分组，这被称为<strong>组包(packetization)</strong>。这些分组包含序列号，该序列号在TCP中实际代表了每个分组的第一个字节在整个数据流中的字节偏移，而不是分组号。这允许分组在传送中是可变大小的，并允许他们组合，称为<strong>重新组包(repacketization)</strong>。应用程序数据被打散成TCP认为的最佳大小的块来发送，一般使得每个报文段按照不会被分片的单个IP层数据报的大小来划分，由TCP传给IP的块称为<strong>报文段(segment)</strong>。</p>
<p><strong>TCP维持了一个强制的校验和</strong>，该检验和涉及它的头部、任何相关应用程序数据和IP头部的所有字段。这是一个端到端的伪头部。它用于检测传送中引入的比特差错。如果一个带无效校验和的报文段到达，TCP会丢弃它，<strong>不为被丢弃的分组发送任何确认</strong>。TCP接受端可能会对一个以前的(已经确认的)报文段进行确认，以帮助发送方计算它的拥塞控制。TCP校验和使用的数学函数与其他互联网协议一样。对于大数据的传送，对这个校验和要注意是否强壮，必要的应用程序应该用自己的差错保护方法(更强的校验和或CRC)，或者使用一种中间层来达到同样的效果。</p>
<p>当TCP发送一组报文时，它通常设置一个重传计时器，等待对方的确认接收。TCP不会为每个报文段设置一个不同的重传计时器。相反，发送一个窗口的数据，它只设置一个计时器，当ACK报文到达时再更新超时，如果有一个确认没有及时接收到，这个报文段就会被重传。</p>
<p>当TCP接收到连接的另一端的数据时，他会发送一个确认。这个确认可能不会立即发送，而一般会延迟片刻。TCP 使用的ACK 是累积的，从某种意义来讲，一个指示字节号N的ACK暗示所有直到N的字节(但不包含N)已经成功被接收了。这对于ACK丢失来说带来了一定的鲁棒性&mdash;&mdash;&ndash;如果一个ACK丢失，很有可能后续的ACK就足以确认前面的报文段了。</p>
<p>TCP 给应用程序提供一种<strong>双工</strong>服务。就是说数据可向两个方向流动，两个方向互相独立。因此，连接的每个端点必须对每个方向维持数据流的一个序列号。<strong>一旦建立了一个连接，这个连接的一个方向上的包含数据流的每个TCP报文段也包含了相反方向上的报文段的一个ACK</strong>。每个报文段也包含了一个窗口通告以实现相反方向上的流量控制。为此，在一个连接中，当一个TCP报文段到达时，窗口可能像前移动，窗口大小可能改变，同时新数据可能已到达。</p>
<p>一个完整的TCP连接是双向和对称的，数据可以在两个方向上平等地流动。</p>
<p>一旦建立了一个连接，这个连接的一个方向上的包含数据流的每个TCP报文段也包含了相反方向上的报文段的一个ACK ???</p>
<p>使用序列号，一个TCP接受端可丢弃重复的报文段和记录以杂乱次序到达的报文段。因为TCP使用IP来封装传递它的报文段，IP不提供重复消除或保证次序正确的功能。然而TCP是一个字节流协议，绝不会以杂乱的次序给接受应用程序发送数据。因此，TCP接受端可能会被迫先保持大序列号的数据不交给应用程序，直到缺失的小序列号的报文段(一个“洞“)被填满。</p>
<p>设计的真好啊</p>
<ul>
<li><input disabled="" type="checkbox"> Nagle</li>
<li><input disabled="" type="checkbox"> 拥塞控制算法</li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>TCP报文格式、连接管理</title>
            <link>https://liguangchang.cn/posts/tcp/tcp-connect-management/</link>
            <pubDate>Tue, 31 Aug 2021 22:56:43 +0800</pubDate>
            
            <guid>https://liguangchang.cn/posts/tcp/tcp-connect-management/</guid>
            <description>传输层(Transport Layer)是 OSI 协议的第四层协议，是唯一负责总体的数据传输和数据控制传输层的一层协议 传输层作用 网际层提供了主机之间</description>
            <content type="html"><![CDATA[<p>传输层(Transport Layer)是 OSI 协议的第四层协议，是唯一负责总体的数据传输和数据控制传输层的一层协议</p>
<h2 id="传输层作用">传输层作用</h2>
<p>网际层提供了主机之间的逻辑通道，通过寻址的方式，把数据包从一个主机发到另一个主机上。如果一个主机有多个进程同时在使用网络连接，那么数据包到达主机之后，如何区分它属于哪一个进程?为了区分数据包所属的进程，就需要用到传输层。</p>
<ul>
<li>为网络应用程序提供接口</li>
<li>为端到端连接提供流量控制、差错控制、服务质量等管理服务</li>
<li>提供多路复用、多路分解机制</li>
</ul>
<h2 id="传输协议类型">传输协议类型</h2>
<p>针对不同情况下的额数据质量保证，传输层提哦给你了两种数据传输协议类型。</p>
<h3 id="面向连接">面向连接</h3>
<p>通信双方在通信时，要事先建立一条通信线路，然后进行通信</p>
<ol>
<li>建立连接</li>
<li>数据传输</li>
<li>释放连接</li>
</ol>
<h3 id="无连接">无连接</h3>
<p>通信双方不需要事先建立通信线路，而是把每个带有目的地址的包(报文分组)发送到线路上，由系统选定线路进行传输，不需要目标方进行回复。</p>
<h2 id="端口和套接字">端口和套接字</h2>
<p>为了区分同一个主机上不同应用程序的数据包，传输层提供了端口和套接字概念。</p>
<p>数据链路层，MAC地址寻址来寻找局域网中的主机</p>
<p>网际层，通过IP地址来寻找网络中互连的主机或路由器</p>
<p>传输层，通过端口进行寻址，来识别同一计算机中同时通信的不同应用程序</p>
<h3 id="套接字">套接字</h3>
<p>应用层通过传输层进行数据通信时，TCP和UDP会遇到需要同时为多个应用程序进程并发服务的问题。</p>
<p>多个TCP连接或多个应用程序进程可能需要通过同一个TCP协议端口传输数据，为了区分不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP/IP协议交互提供了称为套接字的接口，区分不同应用程序进程间的网络通信和连接。</p>
<p>套接字是一个四元组，发送方IP:PORT,接收方IP:PORT</p>
<h3 id="多路复用和多路分解">多路复用和多路分解</h3>
<p>主机之间通信(进程通信)，往往同时需要运行多个应用程序。为了能够让一个计算机同时支持多个网络程序，并且同时保持与多台计算机进行连接，就需要用到多路复用和多路分解。</p>
<ul>
<li>
<p>多路复用</p>
<p>从源主机的不同套接字中收集数据块，并为每个数据块封装首部信息，从而生成报文段，然后将报文段传递到网络层中</p>
</li>
<li>
<p>多路分解</p>
<p>将传输层报文段中的数据交付到正确的套接字</p>
</li>
</ul>
<p>差不多就是扇入和扇出的意思。</p>
<h2 id="netwox-建立tcp服务端客户端">Netwox 建立TCP服务端客户端</h2>
<h3 id="简单通信">简单通信</h3>
<pre tabindex="0"><code>c1 netwox 89 -P 89 模拟服务端开启端口监听 89 端口
c2 netwox 87 -i c1 -p 89 连接 c1 89 端口&#39;
</code></pre><h3 id="远程操作-查看下载上传文件">远程操作-查看/下载/上传文件</h3>
<pre tabindex="0"><code>c1 netwox 93 -P 7878
c2 netwox 95 -i c1 -p 7878 -f file_path/file_name  #查看文件内容
c2 netwox 95 -i c1 -p 7878 -f &#34;file_path/file_name&#34; -F 要保存到的文件名 # 下载文件
c2 netwox 96 -i c1 -p 7878 -f 文件 -F 服务端文件名
</code></pre><h2 id="tcp">TCP</h2>
<p>传输控制协议 Transmission Control Protocol ,是一种面向连接的、可靠的、基于字节流的传输层控制协议。</p>
<p>TCP协议中，通过三次握手建立连接，通信结束后，还需要断开连接。如果没有被正确的发送到目的地时，将会重新发送数据包。</p>
<h3 id="特性作用">特性/作用</h3>
<ul>
<li>面向流的处理 以流的形式处理数据，把接收到的数据组成长度不等的段，在传递到网际层</li>
<li>重新排序 如果数据以错误的顺序到达目的地，TCP模块能够对数据重新排列，来恢复原始数据</li>
<li>流量控制 能够确保数据传输不会超过目的计算机接收数据的能力</li>
<li>优先级与安全 为TCP连接设置可选的优先级和安全级别</li>
<li>适当的关闭 以确保所有的数据被发送或接收以后，在进行关闭连接</li>
</ul>
<h2 id="tcp数据格式">TCP数据格式</h2>
<h3 id="头部和封装">头部和封装</h3>
<p>TCP在IP数据报中的封装</p>
<p>[ IP头部协议(ipv4)/下一个头部(ipv6) ]  IPv4 为20字节，不带选项，IPv6为40字节</p>
<p>[ TCP头部 ] 20字节，不带选项，常见选项包括 最大段大小、时间戳、窗口缩放和选择性ACK</p>
<p>[ TCP(应用程序数据) ]</p>
<h3 id="tcp头部">TCP头部</h3>
<h3 id="源端口和目的端口字段">源端口和目的端口字段</h3>
<p>各占 16 位，2^16=65536</p>
<h3 id="序列号字段">序列号字段</h3>
<h4 id="seq">SEQ</h4>
<p>Sequence Number，32位，表示本报文段所发送数据的第一个字节的编号，32位无符号数，到达2^32-1 后在循环到0，在TCP连接中，所传送的字节流的每一个字节都会按顺序编号。当SYN标记不为1时，这是当前数据分段第一个字母的序列号，如果SYN的值时1时，这个字段的值就是初始序列值(ISN)，用于对序列号进行同步。这时，第一个字节的序列号比这个字段的值大1，也就是ISN加1。</p>
<h3 id="确认号字段">确认号字段</h3>
<h4 id="ack">ACK</h4>
<p>Acknowledgement Number，ACK Number,占32位。表示接收方期望收到发送方下一个报文段的第一个字节数据的编号。其值是接收计算机即将收到的下一个序列号，也就是下一个接收的字节的序列号加1。</p>
<p>发送一个ACK与发送任何一个TCP报文段的开销是一样的，因为那个32位的ACK号字段一直都是头部的一部分，ACK位字段也一样。</p>
<h3 id="数据偏移字段">数据偏移字段</h3>
<h4 id="tcp首部长度">TCP首部长度</h4>
<p>Header Length,数据偏移是值数据段中数据部分起始处距离TCP数据段起始处的字节偏移量，占4位。也是在确定TCP数据段头部分的长度，告诉接受端的应用程序，数据从何处开始。</p>
<h3 id="保留字段">保留字段</h3>
<h4 id="reserved">Reserved</h4>
<p>占4位，为TCP将来的发展预留空间，目前全部为0。</p>
<h3 id="标志位字段">标志位字段</h3>
<h4 id="cwr">CWR</h4>
<p>Congestion Window Reduce ，拥塞窗口减少标志，用来表明它收到了设置ECE标志的TCP包，并且，发送方收到消息之后，通过减少发送窗口的大小来降低发送速率。</p>
<h4 id="ece">ECE</h4>
<p>ECN Echo，用来在TCP三次握手时表明一个TCP段是具备ECN功能的，在数据传输过程中，它也用来表明接收到的TCP包的IP头部的ECN</p>
<p>被设置为11，即网络线路拥堵。</p>
<h4 id="urg">URG</h4>
<p>urgent，表示本报文段中发送的数据是否包含紧急数据，URG=1 时表示有紧急数据，当URG=1 时，后面的紧急指针字段才有效。</p>
<h4 id="ack-1">ACK</h4>
<p>表示前面的确认号字段是否有效，ACK=1 时表示有效，只有当ACK=1 时，前面的确认号字段才有效，TCP规定，连接建立后，ACK必须为1。</p>
<p>TCP可以被描述为&quot;一种带累积正向确认的滑动窗口协议&quot;。</p>
<p>ACK号字段被构建用于指明在接受方已经顺序收到的最大字节(加1)。TCP还有一个选择确认(selective ACKnowledgment，SACK)选项。可以允许接受方告诉发送方它正确地接收到了次序杂乱的数据。每当一个具有选择重发(selective repeat) 能力的TCP发送方搭配时，就可以实现性能的显著改善</p>
<h4 id="psh">PSH</h4>
<p>Push，告诉对方收到该报文段后是否立即把数据推送给上层，如果值为1，表示应当立即把数据提交给上层，而不是缓存起来。</p>
<h4 id="rst">RST</h4>
<p>表示是否重置连接，如果RST=1，说明TCP连接出现了严重错误(eg:主机崩溃)，必须释放连接，然后在重新建立连接。</p>
<h4 id="syn">SYN</h4>
<p>在建立连接时使用，用来同步序号。</p>
<p>当SYN=1，ACK=0 时，表示这是一个请求建立连接的报文段。</p>
<p>当SYN=1，ACK=1 时，表示对方同意建立连接。</p>
<p>SYN=1 说明这个是一个请求连接或同意建立连接的报文，只有在前两次握手中SYN才为1。</p>
<p>当建立一个新连接时，从客户机发送至服务器的第一个报文段的SYN位字段被启用。这样的报文段称为SYN报文段，或简单地称为SYN。然后序列号包含了在本次连接的这个方向上要使用的第一个序列号，后续序列号和返回的ACK号也在这个方向上(连接都是双向的)。⚠️这个数字不是0和1，而是另一个数字，经常时随机选择的，称为初始序列号(Initial Sequence Number，ISN)。ISN不是0和1，是因为这是一种安全措施。发送在本次连接的这个方向上的数据的第一个字节的序列号是ISN加1，因为SYN位字段会消耗一个序列号，消耗一个序列号也意味着使用重传进行可靠传输。因此SYN和应用程序字节(还有FIN)是被可靠传输的。不消耗序列号的ACK则不是。</p>
<h4 id="fin">FIN</h4>
<p>标记数据是否发送完毕，如果FIN=1，表示数据已经发送完成，可以释放连接。</p>
<h3 id="窗口大小字段">窗口大小字段</h3>
<h4 id="窗口大小">窗口大小</h4>
<p>Window Size，16字节，表示从Ack Number 开始还可以接收多少字节的数据量，也表示当前接收端的接收窗口还有多少剩余空间，该字段可以用于TCP的流量控制。</p>
<h3 id="tcp检验和字段">TCP检验和字段</h3>
<h4 id="校验位">校验位</h4>
<p>TCP CheckSum，占16位，用于确认传输的数据是否有损坏。</p>
<p>发送端基于数据内容校验生成一个数值，接受端根据接收的数据校验生成一个值，两个值必须相同，才能证明数据时有效的，如果两个值不同，则丢掉这个数据包。</p>
<p>Checksum 是根据伪头+TCP头+TCP数据三部分进行计算的。</p>
<h3 id="紧急指针字段">紧急指针字段</h3>
<h4 id="紧急指针">紧急指针</h4>
<p>Urgent Pointer，仅当前面的URG控制位为1时才有意义。</p>
<p>指出本数据段中为紧急睡的字节数，占16位。当所有紧急数据处理完后，TCP就会告诉应用程序恢复到正常操作。即使当前窗口大小为0，也是可以发送紧急数据的，因为紧急数据无须缓存。</p>
<h3 id="可选项字段">可选项字段</h3>
<h4 id="选项">选项</h4>
<p>Option，长度不定，但长度必须是32bits的整数倍。</p>
<h2 id="tcp连接管理">TCP连接管理</h2>
<h3 id="建立连接">建立连接</h3>
<p>TCP是面向连接的单播协议，所以在发送数据之前，通信双方必须每次发出的请求都需要对方进行确认，在彼此之间建立一条连接。TCP客户端与TCP服务器在通信之前需要完成三次握手才能建立连接。</p>
<p>三次握手的目的不仅仅是让通信双方了解一个连接正在建立，双方具有通信的条件，还在于利用数据包的选项来承载特殊的信息。交换初始序列号(Initial Sequence Number，ISN)。</p>
<h4 id="第一次握手">第一次握手</h4>
<p>客户端向服务器发送 SYN 报文段 (SEQ=SYN_client=1)，并指明想要连接的端口号和它的客户端初始序列号(ISN)， 并进入 SYN_SENT 状态，等待服务器确认。</p>
<p>SYN，SEQ=ISN_client</p>
<h4 id="第二次握手">第二次握手</h4>
<ul>
<li>服务器向客户端发送一个 SYN 报文段(SEQ=ISN_server)作为响应，并包含了它的初始序列号(ISN=ISN_server)，建立连接的请求，此时服务器进入 SYN_RECV 状态。</li>
<li>为了确认客户端的请求同步信息SYN，服务端将其包含的ISN数值加1后作为返回的ACK数值，回复客户端确认消息 (ACK=SYN_client+1)，每发送一个SYN,序列号就会自动加1.这样如果出现丢失的情况，该SYN段将会重传。</li>
</ul>
<p>SYN+ACK，Seq=ISN_server，ACK=ISN_client+1</p>
<h4 id="第三次握手">第三次握手</h4>
<p>客户端收到服务器的回复 (Seq+ACK 报文)，客户端在向服务端发送确认包 (ACK=ISN_server+1)，Seq=ISN_client+1，此包发送完毕客户端可服务器进入 ESTABLISHED 状态，完成三次握手。</p>
<p>通过</p>
<p>ACK，Seq=ISN_client+1，ACK=ISN_server+1</p>
<p>SEQ 表示请求序列号，ACK 是确认序列号，SYN 和 ACK 为标志位。</p>
<p>发送首个SYN的一方被认为是主动打开的一个连接，也就是客户端。</p>
<h3 id="tcp断开连接">TCP断开连接</h3>
<p>当客户端和服务端不再进行通信时，都会以4次挥手的方式结束连接。连接任何一方都能够发起一个关闭操作，还支持双方同时关闭连接的操作。大部分都是客户端发起连接关闭，下面把主动发起关闭的一段当作客户端。两次FIN，两次确认。</p>
<ol>
<li>
<p>客户端向服务端发送断开TCP连接请求的 [FIN,ACK,SEQ] 报文，在报文中随机生成一个序列号 SEQ=K，表示<strong>要断开TCP连接</strong>。ACK用于确认对方最近一次发来的数据L。</p>
</li>
<li>
<p>服务端收到客户端发来的断开TCP连接请求后，回复发送 ACK=k+1报文确认收到请求，SEQ=L，<strong>表示收到断开请求</strong>，回复的是客户端请求。</p>
<p>这将导致app 发起自己的关闭操作，<strong>被动关闭身份转变为主动关闭，发送自己的FIN</strong>，序列号SEQ为L， ACK = k + 1。</p>
</li>
<li>
<p>服务端在回复完客户端的TCP断开请求后，不会马上进行TCP连接的断开。服务端会先确认断开前，所有传输到客户端的数据是否已经传输完毕，<strong>确认数据传输 完毕后才进行断开</strong>，向客户端发送 [FIN,ACK] 报文，设置字段值为1。再次随机生成一个序列号 SEQ = z。由于还是对客户端发来的 TCP 断开请求序列号 SEQ = x 进行回复，因此 ACK 依然为 x + 1。</p>
</li>
<li>
<p>客户端收到服务器发来的TCP断开连接数据包后将进行回复，表示收到断开 TCP 连接数据包。向服务器发送ACK报文，<strong>确认FIN报文</strong>，序列号 SEQ = k。回复的是服务器，ACK 字段的值在服务器发来断开TCP连接请求序列号 SEQ = L的基础上加1，得到 ACK = L +1。</p>
</li>
</ol>
<h3 id="tcp半关闭">TCP半关闭</h3>
<p>TCP协议还支持连接处于<strong>半开启状态</strong>，这种情况并不常见。存在半开启状态的原因在于TCP的通信模型是双向的。这也意味着<strong>在两个方向中可能会出现只有一个方向正在进行数据传输的情况。</strong></p>
<p><strong>TCP的半关闭操作是指仅关闭数据流的一个传输方向</strong>，而两个半关闭操作合在一起就能够关闭整个连接。因此TCP协议规定通信的任何一方在完成数据发送任务后都能够发送一个FIN。当通信的另一方己收到这个FIN时，就会告知应用程序对方已经终止了对应方向的数据传输。当程序发布关闭操作请求后**，通信双方往往通过发送FIN段来关闭双向的数据传输。**</p>
<p><strong>半关闭就是，我已经完成了数据传输，并发送了一个FIN给对方，但是我仍然希望接受来自对方的数据，知道它发送一个FIN给我。</strong></p>
<ol>
<li>发起半关闭的一方，发送FIN字段，接受方接收到，进行ACK确认。</li>
<li>接受方可以继续发送任意数量的数据段</li>
<li>接受方完成了数据传输后，发送一个FIN来关闭本方的连接，同时向发起半关闭的应用程序发出一个文件尾指示，第二个FIN被确认，整个连接完全关闭。</li>
</ol>
<h3 id="同时打开与关闭">同时打开与关闭</h3>
<p>在特定安排情况下，有可能两个应用程序同时主动打开连接。通信双方在接受到对方的SYN之前必须先发送一个SYN，两个SYN必须经过网络送达对方。该场景还要求通信双方都拥有一个IP地址和端口号，并且将其告知对方。</p>
<p>这种情况下，服务器始终是连接的被动打开者，而非主动打开者，各自的客户端也会选择不同的端口号。因此，可以被区分为两个不同的TCP连接。</p>
<p>一个同时打开的过程需要交换4个报文段，比普通的三次握手增加了一个。由于通信双方都扮演了客户端与服务端的角色，因此不能够将任何一方称作客户端活服务端。数据包的SYN位将置位直到接收到一个ACK数据包为止，两个SYN，两个ACK。</p>
<p>同时关闭与正常关闭相似，只是报文段的顺序是交叉的。</p>
<h3 id="初始序列号">初始序列号</h3>
<p>当一个连接打开时，任何拥有合适的IP地址、端口号、符合逻辑的序列号(窗口中)以及正确校验和的报文段都将被对方接收。在连接中，TCP报文段在经过网络路由后可能会存在<strong>延迟抵达与排序混乱</strong>的情况。这个问题需要仔细选择初始版本号。</p>
<p>在发送用于建立连接的SYN之前，通信双方会选择一个初始序列号。初始序列号会随时间而改变，因此每一个连接都拥有不同的初始序列号。<strong>初始序列号可以被看作一个32位的计数器，每4微秒加1，为了在一个连接的报文段安排序列号，防止出现与其他连接的序列号重叠</strong>。尤其对于同一连接的两个不同实例而言，新的序列号不能出现重叠的情况。</p>
<p>由于序列号连接是被一对端点所唯一标识的，其中包括2个IP地址和2个端口号构成的4元组，因此即便是同一个连接也会出现不同的实例。如果<strong>由于连接延迟的报文段的长时间延迟被关闭，然后又以相同的4元组被重新打开，延迟的报文又被视为有效数据重新进入新连接的数据流中</strong>。一个对数据完整性有较高要求的应用程序也可以在应用曾利用CRC或校验和保证数据在传输过程中没有出现任何错误。</p>
<p>一个TCP报文只有同时具备连接的4元组与当前活动窗口的序列号，才会在通信过程中被认为是正确的。也在侧面反映了<strong>TCP的脆弱性</strong>：如果选择合适的序列号、IP地址以及端口号，任何一个人都能伪造出一个TCP报文段，从而打断了TCP的正常连接。一种抵御上述行为的方法是使初始序列号(或者临时端口号)使变得相对难以被猜出，而另一种方法则是加密。</p>
<h3 id="初始序列号实现">初始序列号实现</h3>
<p>现代系统通常采用半随机的方法选择初始序列号，Linux 系统采用了一个相对复杂的过程来选择它的初始话序列号。</p>
<p>Linux 采用基于时钟的方案，并且针对每一个连接为时钟设置随机的偏移量。随机偏移量是在连接标识(4元组)的基础上利用加密散列函数得到的。散列函数的输入每隔5分钟就会改变一次。在32位的初始序列号中，最高的8位是一个保密的序列号，而剩余的各位则由散列函数生成。</p>
<p>Windows 系统采用了一种基于RC4的类似方案。</p>
]]></content>
        </item>
        
        <item>
            <title>Prometheus</title>
            <link>https://liguangchang.cn/posts/go/prometheus/</link>
            <pubDate>Sat, 21 Aug 2021 11:26:29 +0800</pubDate>
            
            <guid>https://liguangchang.cn/posts/go/prometheus/</guid>
            <description>Prometheus 由 SoundCloud 用Go语言编写并开源的监控告警系统，自带时序数据库，采用 Pull 方式获取监控信息，提供了多维度的数据模型和灵活的查询接口。 不仅可以通过静态文</description>
            <content type="html"><![CDATA[<p>Prometheus 由 SoundCloud 用Go语言编写并开源的监控告警系统，自带时序数据库，采用 Pull 方式获取监控信息，提供了多维度的数据模型和灵活的查询接口。</p>
<p>不仅可以通过静态文件配置监控对象，还支持自动发现机制，能够通过 K8s、etcd、Consul、DNS 等多种方式动态获取监控对象。</p>
<p>单机可以采集数百个节点的监控数据，每秒可以采集一千万个指标，还支持远端存储。</p>
<h2 id="监控系统">监控系统</h2>
<h2 id="架构">架构</h2>
<h3 id="pull">Pull</h3>
<p>Prometheus 通过 HTTP 周期性的抓取被监控组件的状态，任意组件只要提供对应的 HTTP 接口并且符合 Prometheus 定义的数据格式，就可以接入 Prometheus 监控</p>
<p>通过 Pull 的方式调用被监控数据获取监控数据的方式，能够自动进行上游监控和水平监控，配置更少，更容易拓展、实现高可用、降低耦合，可以避免推送系统中容易出现的推送数据失败导致瘫痪的问题，采集端无感监控系统的存在，独立监控系统之外，增强了监控系统整体的可控性，但是需要管理多个 exporter。</p>
<h3 id="获取监控对象">获取监控对象</h3>
<ul>
<li>通过配置文件静态配置</li>
<li>支持 Zookeeper、Consul、Kubernetes 动态发现</li>
</ul>
<h3 id="存储">存储</h3>
<p>Storage 通过一定规则清理和整理数据，把得到的结果存储到新的时间序列中。</p>
<ul>
<li>
<p>本地存储（自带时间序数据库，大量数据有瓶颈）</p>
</li>
<li>
<p>远端存储，通过中间层的适配器转化实现 Prometheus 存储的 remote write ,remote read 接口接入</p>
<p>支持常用的 Kakfa、OpenTSDB、InfluxDB、ElasticSearch</p>
</li>
</ul>
<h3 id="查询">查询</h3>
<p>Prometheus 通过 PromQL 和其他 API 可视化展示收集的数据，支持 Grafana、自带的 PromDash 、自身提供的模版引擎、HTTP API</p>
<h3 id="pushgateway">PushGateway</h3>
<p>对于某些系统通过 Push 方式实现的推送，Prometheus 提供了对 PushGateway 的支持，这些系统主动过推送 metrics  到  PushGateway，Prometheus 定时去 Gateway 上抓取数据。</p>
<h3 id="alertmanager">AlertManager</h3>
<p>AltertManager 是独立于 Prometheus 的一个组件，在触发了预先设置的高级规则后，Prometheus 将会推送告警信息到 AlertManager</p>
<p>AlertManager 告警方式，可以通过邮件、slack、或者 dingTalk 等途径推送。</p>
<p>AlertManager 支持高可用部署，为了解决多个 AlertManager 重复告警问题，引入了 Gossip，在多个 AlertManager 之间同步告警信息</p>
<h2 id="其他开源监控工具">其他开源监控工具</h2>
<p>RDD (Round Robin Database 环形数据库)</p>
<p>RDD 存储： 将整个数据存储空间构成圆环，指针指向最新的数据位置并且随着数据读写移动，如果此时没有获取监控数据，RDD 会使用默认的 unknown 填充，保证数据对齐，每个数据库文件都以 .rdd 结尾，大小是固定的。</p>
<ul>
<li>Zabbix （公司在用。。。）,1998 年基于c + php + 关系型数据库 实现，性能不行，支持主动推送、被动拉取</li>
<li>Nagios   1999 年c 语言实现，老牌监控，主要针对主机、网络监控，比较稳定，通过 plugin 采集各种监控数据</li>
<li>Open-Falcon 小米开源 Go 语言实现，RDD 存储，加入一致性 Hash 进行数据分片，可以对接 OpenTSDB，容器监控支持力度有限</li>
</ul>
<h2 id="安装配置">安装配置</h2>
<p><a href="https://prometheus.io/download/">下载</a>对应 OS 的压缩包，</p>
<h2 id="metric">metric</h2>
<p>Prometheus metric 统一定义为，涉及 指标名称和标签两部分</p>
<pre tabindex="0"><code>&lt;metric name&gt; {&lt;lable name&gt;=&lt;label value&gt;,...}
</code></pre><ul>
<li>
<p>metric name</p>
<p>说明 metric 含义，必须由字面量、数值下划线或者冒号组成，符合正则表达式 { [[a-zA-Z_:]][][a-zA-Z_:]* }</p>
<p>其中的冒号指标不能用于exporter。</p>
</li>
<li>
<p>metric label</p>
<p>体现指标的维度特征，用于过滤、聚合，通过 label_name 和 label_value 这种键值对形成多种维度。</p>
<p>有些 label  是以 “—“ 开头的，这些 label 是在 Prometheus 内部使用。</p>
</li>
</ul>
<h3 id="metric-category">metric category</h3>
<p><strong>长尾效应</strong>：统计学术语，主要描述 极低值(价值、数值)的个体数量占了总体的绝大多数。</p>
<p>Prometheus 指标分为 counter (计数器)、Gauge (仪表盘)、Histogram (直方图)、Summary (摘要)</p>
<ul>
<li>
<p>counter</p>
<p>只增不减，eg: 机器启动时间、HTTP 访问量</p>
</li>
<li>
<p>Gauge</p>
<p>指标的实时变化情况，可增可减，eg: CPU、内存的使用量、网络IO 大小，大部分数据都是 Gauge 类型的。</p>
</li>
<li>
<p>Summary</p>
<p>高级指标，采样点分位图的到数据的分布情况，用于凸显数据的分布情况。</p>
<p>如果想要了解某个时间段内请求的响应时间，通常使用平均响应时间(无法体现数据的长尾效应)，可以使用 Summary/Histogram</p>
</li>
<li>
<p>Histogram</p>
<p>反应某个区间内的样本个数，通过 {le=&ldquo;上边界&rdquo;} 指定这个范围内的样本数</p>
</li>
</ul>
<h3 id="数据样本">数据样本</h3>
<p>Prometheus 采集的数据样本都是以时间序列保存的，每个样本都由三部分组成，指标、样本值、时间戳</p>
<p>样本值(64位浮点数) 和时间戳(ms) 的组合代表这个时间点采集到的监控数值，这些时序数据首先被保存子啊内存中，然后被批量刷新到磁盘。</p>
<h3 id="数据采集">数据采集</h3>
<p>Pushtgateway 组件接受客户端发送过来的数据，按照 Job 和 instance 两个层级进行组织，支持数据的追加和删除，为防止数据丢失，还支持本地存储</p>
<ul>
<li>
<p>实时性</p>
<p>Push 实时性相对较好，可以将采集数据立即上报到监控中心</p>
<p>Pull 方式通常进行周期性采集，采集时间为 30s 或更长时间，实时性要求非常高的的监控可以采用 Push 方式。</p>
</li>
<li>
<p>状态保存</p>
<p>Push 方式通常在采集完成后立即上报，本地不会保存此采集数据，Agent 本身是没有状态的，Master 需要维护各种 Agent状态</p>
<p>Pull 方式，Agent 本身有一定的数据存储能力，Master 只负责简单的数据拉取，而且本身可以做到无状态。</p>
</li>
<li>
<p>控制能力</p>
<p>Push 方式，控制方是 Agent ,Agent 上报的数据决定了上报的周期和内容</p>
<p>Pull 方式，Master 更加主动，控制采集的内容和频率</p>
</li>
<li>
<p>配置的复杂性</p>
<p>Push 方式，每个 Agent 需要配置 Master 地址</p>
<p>Pull 方式，通常通过批量配置或者自动发现来获取所有采集点，相对简单，并且可以做到和 Agent 充分解耦，Agent 不用感知 Master 存在。</p>
</li>
</ul>
<h3 id="服务发现">服务发现</h3>
<ul>
<li>
<p>静态文件配置</p>
<p>适用于有固定的监控环境，只需要配置监控对象的ip+port 就行，后面进行周期性的调度就可以。</p>
</li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>Golang Programming Language</title>
            <link>https://liguangchang.cn/posts/go/go-basic/</link>
            <pubDate>Wed, 11 Aug 2021 01:17:20 +0800</pubDate>
            
            <guid>https://liguangchang.cn/posts/go/go-basic/</guid>
            <description>package main import ( &amp;#34;fmt&amp;#34; &amp;#34;image&amp;#34; &amp;#34;image/color&amp;#34; &amp;#34;image/gif&amp;#34; &amp;#34;io&amp;#34; &amp;#34;log&amp;#34; &amp;#34;math&amp;#34; &amp;#34;math/rand&amp;#34; &amp;#34;net/http&amp;#34; &amp;#34;sync&amp;#34; ) var mu sync.Mutex var count int func main() { http.HandleFunc(&amp;#34;/&amp;#34;, handler) http.HandleFunc(&amp;#34;/count&amp;#34;, counter) http.HandleFunc(&amp;#34;/lsr&amp;#34;, func(w http.ResponseWriter, r *http.Request) { //handler(w,r) lissajous(w) }) log.Fatal(http.ListenAndServe(&amp;#34;localhost:8000&amp;#34;, nil)) } func handler(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, &amp;#34;%s\t\t%s\t%s\n&amp;#34;, r.Method, r.URL, r.Proto) for k, v := range r.Header { fmt.Fprintf(w, &amp;#34;Header[%q]=%q\n&amp;#34;, k, v) } fmt.Fprintf(w, &amp;#34;Host = %q\n&amp;#34;, r.Host) fmt.Fprintf(w, &amp;#34;RemoteAddr</description>
            <content type="html"><![CDATA[<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;image&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;image/color&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;image/gif&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;io&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;log&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;math&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;math/rand&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;net/http&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;sync&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">mu</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">Mutex</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">count</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">HandleFunc</span>(<span style="color:#e6db74">&#34;/&#34;</span>, <span style="color:#a6e22e">handler</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">HandleFunc</span>(<span style="color:#e6db74">&#34;/count&#34;</span>, <span style="color:#a6e22e">counter</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">HandleFunc</span>(<span style="color:#e6db74">&#34;/lsr&#34;</span>, <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">w</span> <span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">ResponseWriter</span>, <span style="color:#a6e22e">r</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Request</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//handler(w,r)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">lissajous</span>(<span style="color:#a6e22e">w</span>)
</span></span><span style="display:flex;"><span>	})
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Fatal</span>(<span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">ListenAndServe</span>(<span style="color:#e6db74">&#34;localhost:8000&#34;</span>, <span style="color:#66d9ef">nil</span>))
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">handler</span>(<span style="color:#a6e22e">w</span> <span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">ResponseWriter</span>, <span style="color:#a6e22e">r</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Request</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Fprintf</span>(<span style="color:#a6e22e">w</span>, <span style="color:#e6db74">&#34;%s\t\t%s\t%s\n&#34;</span>, <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">Method</span>, <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">URL</span>, <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">Proto</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">Header</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Fprintf</span>(<span style="color:#a6e22e">w</span>, <span style="color:#e6db74">&#34;Header[%q]=%q\n&#34;</span>, <span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">v</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Fprintf</span>(<span style="color:#a6e22e">w</span>, <span style="color:#e6db74">&#34;Host = %q\n&#34;</span>, <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">Host</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Fprintf</span>(<span style="color:#a6e22e">w</span>, <span style="color:#e6db74">&#34;RemoteAddr = %q\n&#34;</span>, <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">RemoteAddr</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">ParseForm</span>(); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Print</span>(<span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">Form</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Fprintf</span>(<span style="color:#a6e22e">w</span>, <span style="color:#e6db74">&#34;Form[%q] = %q\n&#34;</span>, <span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">v</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">Lock</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">count</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">Unlock</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//fmt.Fprintf(w, &#34;HTTP.METHOD:%s\nURL.PATH=%q\n&#34;, r.Method, r.URL.Path)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//count
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">counter</span>(<span style="color:#a6e22e">w</span> <span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">ResponseWriter</span>, <span style="color:#a6e22e">r</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Request</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">Lock</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Fprintf</span>(<span style="color:#a6e22e">w</span>, <span style="color:#e6db74">&#34;Count %d\n&#34;</span>, <span style="color:#a6e22e">count</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">Unlock</span>()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">lissajous</span>(<span style="color:#a6e22e">out</span> <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Writer</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">Lock</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">count</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">Unlock</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">palette</span> = []<span style="color:#a6e22e">color</span>.<span style="color:#a6e22e">Color</span>{<span style="color:#a6e22e">color</span>.<span style="color:#a6e22e">Opaque</span>, <span style="color:#a6e22e">color</span>.<span style="color:#a6e22e">Black</span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">const</span> (
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">whiteIndex</span> = <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">blackIndex</span> = <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>	)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">const</span> (
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">cycles</span>  = <span style="color:#ae81ff">5</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">res</span>     = <span style="color:#ae81ff">0.001</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">size</span>    = <span style="color:#ae81ff">100</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">nframes</span> = <span style="color:#ae81ff">64</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">delay</span>   = <span style="color:#ae81ff">8</span>
</span></span><span style="display:flex;"><span>	)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">freq</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">rand</span>.<span style="color:#a6e22e">Float64</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">anim</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">gif</span>.<span style="color:#a6e22e">GIF</span>{<span style="color:#a6e22e">LoopCount</span>: <span style="color:#a6e22e">nframes</span>}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">phase</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0.0</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">nframes</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">rect</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">image</span>.<span style="color:#a6e22e">Rect</span>(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">2</span><span style="color:#f92672">*</span><span style="color:#a6e22e">size</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span><span style="color:#f92672">*</span><span style="color:#a6e22e">size</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">img</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">image</span>.<span style="color:#a6e22e">NewPaletted</span>(<span style="color:#a6e22e">rect</span>, <span style="color:#a6e22e">palette</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">t</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0.0</span>; <span style="color:#a6e22e">t</span> &lt; <span style="color:#a6e22e">cycles</span><span style="color:#f92672">*</span><span style="color:#ae81ff">2</span><span style="color:#f92672">*</span><span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">Pi</span>; <span style="color:#a6e22e">t</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">res</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">x</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">Sin</span>(<span style="color:#a6e22e">t</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">y</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">Sin</span>(<span style="color:#a6e22e">t</span><span style="color:#f92672">*</span><span style="color:#a6e22e">freq</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">phase</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">img</span>.<span style="color:#a6e22e">SetColorIndex</span>(<span style="color:#a6e22e">size</span><span style="color:#f92672">+</span>int(<span style="color:#a6e22e">x</span><span style="color:#f92672">*</span><span style="color:#a6e22e">size</span><span style="color:#f92672">+</span><span style="color:#ae81ff">0.5</span>), <span style="color:#a6e22e">size</span><span style="color:#f92672">+</span>int(<span style="color:#a6e22e">y</span><span style="color:#f92672">*</span><span style="color:#a6e22e">size</span><span style="color:#f92672">+</span><span style="color:#ae81ff">0.5</span>), <span style="color:#a6e22e">blackIndex</span>)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">phase</span> <span style="color:#f92672">+=</span> <span style="color:#ae81ff">0.1</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">anim</span>.<span style="color:#a6e22e">Delay</span> = append(<span style="color:#a6e22e">anim</span>.<span style="color:#a6e22e">Delay</span>, <span style="color:#a6e22e">delay</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">anim</span>.<span style="color:#a6e22e">Image</span> = append(<span style="color:#a6e22e">anim</span>.<span style="color:#a6e22e">Image</span>, <span style="color:#a6e22e">img</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">gif</span>.<span style="color:#a6e22e">EncodeAll</span>(<span style="color:#a6e22e">out</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">anim</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="printf-verb">printf verb</h2>
<table>
<thead>
<tr>
<th>Verb</th>
<th>Desc</th>
</tr>
</thead>
<tbody>
<tr>
<td>%d</td>
<td>十进制</td>
</tr>
<tr>
<td>%x %o %b</td>
<td>十六进制、八进制、二进制整数</td>
</tr>
<tr>
<td>%f %g %e</td>
<td>浮点数，g自动保持足够的精度，最简洁，e有指数，f无指数</td>
</tr>
<tr>
<td>%t</td>
<td>布尔型</td>
</tr>
<tr>
<td>%c</td>
<td>字符 unicode码点</td>
</tr>
<tr>
<td>%s</td>
<td>字符串</td>
</tr>
<tr>
<td>%q</td>
<td>带引号的字符串/字符</td>
</tr>
<tr>
<td>%v</td>
<td>内置格式的任何值</td>
</tr>
<tr>
<td>%T</td>
<td>任何值的类型</td>
</tr>
<tr>
<td>%%</td>
<td>百分号</td>
</tr>
<tr>
<td>%[1]</td>
<td>重复使用第一个操作数</td>
</tr>
<tr>
<td>%#</td>
<td>输出相应的前缀</td>
</tr>
</tbody>
</table>
<h2 id="new">new</h2>
<p>New 是一种内置创建变量的函数，new(T) 创建一个未命名的T类型变量，初始化为T类型的零值，并返回其地址*T，和取地址的普通局部变量没有什么不同，只是不需要引入一个虚拟的名字。</p>
<h2 id="escape">escape</h2>
<p><strong>每一次变量逃逸都需要一次额外的内存分配过程</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">global</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">f</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">x</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">x</span> = <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// f() 返回 global 还可以访问 x ，x 从 f 中逃逸，x 使用堆空间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">global</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">x</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">g</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">y</span> <span style="color:#f92672">:=</span> new(<span style="color:#66d9ef">int</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">*</span><span style="color:#a6e22e">y</span> = <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="多重赋值推演">多重赋值推演</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span> = <span style="color:#a6e22e">y</span>, <span style="color:#a6e22e">x</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">j</span> = <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>
</span></span></code></pre></div><h2 id="基本数据类型">基本数据类型</h2>
<ul>
<li>
<p>Int、uint = 运算平台上运算效率最高的值</p>
</li>
<li>
<p>uintptr 大小不明确，足以完整存放指针</p>
</li>
<li>
<p>Rune = int32 四个字节，适合UTF-8 的变长1-4 个</p>
</li>
<li>
<p>二元操作符优先级</p>
<ul>
<li>
<ul>
<li>/  % &laquo;  &raquo; &amp; &amp;^ + &mdash; | ^ == != &lt; &lt;= &gt; &gt;= &amp;&amp; || 降序</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>取模结果正负号和被除数一致</strong>，-5%3 = -2</p>
</li>
<li>
<p>一元运算符</p>
<ul>
<li>整数 +1 = 0+1，-x = 0-x</li>
<li>浮点数和复数 +x =x，-x=x的负数</li>
</ul>
</li>
<li>
<p>溢出丢弃</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">u</span> <span style="color:#66d9ef">uint8</span> = <span style="color:#ae81ff">255</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//255 0 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">u</span>,<span style="color:#a6e22e">u</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,<span style="color:#a6e22e">u</span><span style="color:#f92672">*</span><span style="color:#a6e22e">u</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">i</span> <span style="color:#66d9ef">int8</span> = <span style="color:#ae81ff">127</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">i</span>,<span style="color:#a6e22e">i</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,<span style="color:#a6e22e">i</span><span style="color:#f92672">*</span><span style="color:#a6e22e">i</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e">//127 -128 1
</span></span></span></code></pre></div></li>
<li>
<p>浮点数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#f92672">-</span><span style="color:#ae81ff">5</span><span style="color:#f92672">%</span><span style="color:#ae81ff">3</span>)<span style="color:#75715e">//-2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#f92672">-</span><span style="color:#ae81ff">5</span><span style="color:#f92672">%-</span><span style="color:#ae81ff">3</span>)<span style="color:#75715e">//-2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)<span style="color:#75715e">//1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)<span style="color:#75715e">//-1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#f92672">-</span><span style="color:#ae81ff">1.1</span>)<span style="color:#75715e">//-1.1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#f92672">+</span><span style="color:#ae81ff">1.1</span>)<span style="color:#75715e">//1.1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">u</span> <span style="color:#66d9ef">uint8</span> = <span style="color:#ae81ff">255</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//255 0 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">u</span>,<span style="color:#a6e22e">u</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,<span style="color:#a6e22e">u</span><span style="color:#f92672">*</span><span style="color:#a6e22e">u</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">i</span> <span style="color:#66d9ef">int8</span> = <span style="color:#ae81ff">127</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">i</span>,<span style="color:#a6e22e">i</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,<span style="color:#a6e22e">i</span><span style="color:#f92672">*</span><span style="color:#a6e22e">i</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//127 -128 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">NaN</span>())
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//NaN
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">z</span> <span style="color:#66d9ef">float64</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">z</span>,<span style="color:#f92672">-</span><span style="color:#a6e22e">z</span>,<span style="color:#ae81ff">1</span><span style="color:#f92672">/</span><span style="color:#a6e22e">z</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">/</span><span style="color:#a6e22e">z</span>,<span style="color:#a6e22e">z</span><span style="color:#f92672">/</span><span style="color:#a6e22e">z</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//0 -0 +Inf -Inf NaN
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">IsNaN</span>(<span style="color:#a6e22e">z</span><span style="color:#f92672">/</span><span style="color:#a6e22e">z</span>))<span style="color:#75715e">//true
</span></span></span></code></pre></div></li>
<li>
<p>字符串</p>
<p>字符串的第i个字节不一定就是第i个字符，因为非ASCII字符的UTF-8码点需要两个或更多的字节。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>	<span style="color:#a6e22e">s</span><span style="color:#f92672">:=</span><span style="color:#e6db74">&#34;hello&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">t</span><span style="color:#f92672">:=</span><span style="color:#a6e22e">s</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">s</span><span style="color:#f92672">+=</span><span style="color:#e6db74">&#34;,golang&#34;</span> <span style="color:#75715e">//重新赋值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s</span>)<span style="color:#75715e">//hello,golang
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">t</span>)<span style="color:#75715e">//hello
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s</span>[<span style="color:#ae81ff">0</span>])<span style="color:#75715e">//104
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">字符串不可变</span> = <span style="color:#a6e22e">共用一段底层内存</span><span style="color:#960050;background-color:#1e0010">，</span><span style="color:#a6e22e">子串的生成操作开销很低</span><span style="color:#960050;background-color:#1e0010">，</span><span style="color:#a6e22e">不会分配新的内存</span><span style="color:#960050;background-color:#1e0010">。</span>
</span></span></code></pre></div><p>因为文件都是UTF-8编码格式，字符串会按照UTF-8解读，字符串可以包含Unicode码点。</p>
</li>
</ul>
]]></content>
        </item>
        
    </channel>
</rss>
